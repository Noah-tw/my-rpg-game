<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>The Promised Dawn: A Game for Noah's Friends</title>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>



       /* 1. FIXED CONSOLE LAYOUT */
        body { 
            margin: 0; overflow: hidden; background: #111; 
            font-family: 'VT323', monospace; user-select: none; 
            /* CENTER THE CONSOLE */
            display: flex; justify-content: center; align-items: center; height: 100vh; 
        }
        
        #game-wrapper { 
            position: relative; 
            /* FIXED RESOLUTION (Matches Canvas) */
            width: 960px; height: 720px; 
            background: #000; 
            box-shadow: 0 0 50px #000; 
            border: 4px solid #333;
            overflow: hidden; 
        }

        canvas { display: block; image-rendering: pixelated; background: #080808; }
        
        /* 2. UI LAYER FIX (Crucial for visibility) */
        .ui-layer { 
            position: absolute; 
            top: 0; left: 0; 
            width: 100%; height: 100%; 
            pointer-events: none; 
            display: flex; flex-direction: column; justify-content: space-between; 
            z-index: 500; /* Ensure it sits ON TOP of the canvas */
        }
        
        #hud-top { padding: 15px; display: flex; gap: 15px; align-items: flex-start; }
}
        .stat-col { display: flex; flex-direction: column; gap: 5px; }
        .stat-box { background: rgba(0,0,0,0.85); border: 2px solid #888; padding: 5px 15px; color: #fff; font-size: 26px; display: flex; align-items: center; gap: 10px; border-radius: 8px; box-shadow: 0 4px 0 #111; }
        
        .bar-w { width: 200px; height: 24px; background: #222; position: relative; border: 2px solid #555; border-radius: 4px; overflow: hidden; }
        .bar-f { height: 100%; transition: width 0.2s; }
        
        .xp-w { width: 200px; height: 12px; background: #222; position: relative; border: 2px solid #555; border-radius: 4px; overflow: hidden; margin-top: 5px; }
        .xp-f { height: 100%; background: #ffd700; width: 0%; transition: width 0.2s; }

        /* --- NEW PIXEL ART MINIMAP --- */
    /* --- NEW PIXEL ART MINIMAP --- */
   /* --- NEW PIXEL ART MINIMAP --- */
    
   /* --- NEW PIXEL ART MINIMAP --- */
    
    /* Keep the Pulse Animation for the Red Dot */
    @keyframes playerPulse {
        0% { transform: translate(calc(-50% + 8px), calc(-50% + 8px)) scale(1); box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7); }
        70% { transform: translate(calc(-50% + 8px), calc(-50% + 8px)) scale(1.1); box-shadow: 0 0 0 6px rgba(255, 0, 0, 0); }
        100% { transform: translate(calc(-50% + 8px), calc(-50% + 8px)) scale(1); box-shadow: 0 0 0 0 rgba(255, 0, 0, 0); }
    }

    #minimap-container { 
        width: 180px; 
        height: 180px;
        margin-left: auto;
        
        /* BOTTOM LAYER: Original Semi-Transparent Black */
        background: rgba(0, 0, 0, 0.5); 
        
        /* Frame Styles */
        border: none;       
        outline: 4px solid #8d6e63;
        box-sizing: border-box;
        
        box-shadow: 
            0 0 0 2px #000,              
            0 0 0 6px #5d4037,           
            0 10px 20px rgba(0,0,0,0.8); 
        
        position: relative; 
    }

    /* MIDDLE LAYER (The Map Canvas) */
    #minimap {
        display: block;        
        width: 180px;          
        height: 180px;         
        
        border: none !important;      
        background: transparent !important; 
        box-shadow: none !important;
        margin: 0; padding: 0;
        
        image-rendering: pixelated;
        transform: translate(8px, 8px); /* Alignment Fix */
    }

    /* TOP LAYER (The Player Dot - NEW STYLE) */
    #mini-player {
        position: absolute;
        width: 6px; height: 6px; 
        background: #ff0000;
        border-radius: 50%;      /* Round Dot */
        
        /* White border */
        border: 2px solid #fff;
        
        z-index: 10;
        pointer-events: none;

        /* Pulse Animation + Alignment */
        transform: translate(calc(-50% + 8px), calc(-50% + 8px));
        animation: playerPulse 1.5s infinite;
    }





    /* The Red Player Dot */
    #mini-player {
        position: absolute;
        width: 6px; height: 6px;
        background: #ff0000;
        border: 2px solid #fff;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        box-shadow: 0 0 5px #ff0000;
        z-index: 10;
        pointer-events: none;
    }

    /* Optional: A faint grid overlay for texture */
    #minimap-overlay {
        position: absolute; top:0; left:0; width:100%; height:100%;
        background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
        background-size: 100% 4px, 6px 100%;
        pointer-events: none;
        z-index: 5;
    }





#quest-panel { 
        /* HIDE ON START */
        display: none; 

        position: absolute !important;
        
        /* POSITION: Top Right (Under Minimap) */
        top: 230px !important; 
        right: 15px !important;
        left: auto !important;
        bottom: auto !important;
        
        /* SIZE */
        width: 180px !important;
        height: auto !important;
        
        /* VISUALS */
        background: rgba(0, 0, 0, 0.6) !important; 
        border: 2px solid rgba(241, 196, 15, 0.6) !important;
        border-radius: 8px !important;
        padding: 10px !important;
        
        /* TEXT RESTORED */
        color: #eee !important;
        font-family: 'VT323', monospace !important;
        font-size: 24px !important;  /* Increased from 20px -> 24px */
        line-height: 1.1 !important;
        text-shadow: 2px 2px 0 #000 !important; /* Stronger shadow for contrast */
        
        box-shadow: 0 4px 10px rgba(0,0,0,0.5) !important; 
        pointer-events: none !important;
        z-index: 1000 !important;
    }
 #skill-bar { display: flex; justify-content: center; gap: 12px; padding-bottom: 25px; pointer-events: auto; }
      


.slot { 
            width: 65px; height: 65px; background: #1a1a1a; border: 3px solid #555; 
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            position: relative; color: #fff; 
            
            /* CHANGED HERE: Disable Mouse */
            cursor: default; 
            pointer-events: none;

            border-radius: 10px; transition: 0.1s;
            box-shadow: 0 5px 0 #111;
        }




        .slot:hover { border-color: #ffd700; background: #333; transform: translateY(-3px); }
        .slot:active { transform: translateY(2px); box-shadow: 0 0 0 #000; }
        .slot.locked { filter: grayscale(100%); opacity: 0.6; cursor: not-allowed; border-color: #333; }
        .slot.locked::after { content: "üîí"; font-size: 30px; position: absolute; top: 15px; text-shadow: 0 0 5px #000; }
        
        .slot.active-tool { border-color: #00e676; box-shadow: 0 0 15px #00e676; transform: translateY(-5px); background: #222; }

        .key-hint { position: absolute; top: 2px; left: 5px; color: #ffd700; font-weight: bold; font-size: 16px; text-shadow: 1px 1px 0 #000; }
        .icon { font-size: 32px; margin-top: 5px; filter: drop-shadow(0 3px 0 #000); }
        /* Removed 'transition' to fix the visual lag when cooldown starts */
        .cd { position: absolute; bottom: 0; left: 0; width: 100%; background: rgba(0,0,0,0.8); height: 0%; border-radius: 0 0 8px 8px; }

        #rpg-chat {
            position: absolute; bottom: 130px; left: 50%; transform: translateX(-50%);
            width: 700px; min-height: 100px;
            overflow: visible; /* ALLOWS PORTRAITS TO STICK OUT */
            background: rgba(10, 10, 10, 0.95);
            border: 4px double #888;
            border-radius: 12px;
            display: flex; flex-direction: column; justify-content: flex-start;
            padding: 15px 25px; pointer-events: none;
            transition: opacity 0.2s; opacity: 0;
            z-index: 500;
            box-shadow: 0 10px 30px #000;
        }





/* --- RESTORED STANDARD CHAT STYLES --- */
#chat-name { 
    color: #f1c40f; 
    font-size: 26px; 
    font-weight: bold; 
    margin-bottom: 8px; 
    text-transform: uppercase; 
    border-bottom: 2px solid #444; 
    display: inline-block; 
    letter-spacing: 1px; 
}

#chat-text { 
    color: #fff; 
    font-size: 24px; 
    line-height: 1.3; 
    white-space: pre-wrap; 
    text-shadow: 1px 1px 0 #000; 
}




/* --- SPECIAL PREMIUM CHAT BOX --- */
/* ========================================= */
/*  "VINTAGE SKETCHBOOK" CHAT DESIGN         */
/* ========================================= */
/* ========================================= */
/*  "ANCIENT PARCHMENT" CHAT DESIGN          */
/* ========================================= */

/* ========================================= */
/*  "LEGENDARY SCROLL" CHAT DESIGN           */
/* ========================================= */

/* ========================================= */
/*  "LEGENDARY SCROLL" CHAT DESIGN           */
/* ========================================= */

/* ========================================= */
/*  "LEGENDARY SCROLL" CHAT DESIGN           */
/* ========================================= */

/* ========================================= */
/*  "LEGENDARY SCROLL" CHAT DESIGN           */
/* ========================================= */

/* ========================================= */
/*  "LEGENDARY SCROLL" CHAT DESIGN           */
/* ========================================= */

/* ========================================= */
/*  "LEGENDARY SCROLL" CHAT DESIGN           */
/* ========================================= */

#special-chat {
    position: absolute; 
    
    /* 1. MOVED UP (Was 70px -> Now 85px) */
    bottom: 85px; 
    
    left: 50%; transform: translateX(-50%);
    
    /* SIZE */
    width: 540px; 
    min-height: 140px;
    
    /* PARCHMENT TEXTURE */
    background-color: #f3e5ab; 
    background-image: radial-gradient(circle, transparent 40%, rgba(161, 136, 127, 0.2) 100%);
    
    /* RIPPED EDGES & BORDER */
    border-radius: 5px 255px 5px 25px / 255px 5px 225px 5px;
    border: 3px solid #5d4037; 
    
    box-shadow: 
        inset 0 0 80px rgba(141, 110, 99, 0.25), 
        0 20px 40px rgba(0,0,0,0.6); 

    display: none; 
    flex-direction: column; justify-content: center;
    
    /* 2. PADDING ADJUSTMENT (Push text slightly higher inside the box) */
    padding: 25px; 
    padding-bottom: 35px; /* Added extra bottom padding */
    
    pointer-events: none;
    z-index: 600; 
}
/* --- DYNAMIC ALIGNMENT --- */

/* NOAH: Image Left, Text Pushed Right */
#special-chat.talk-noah {
    padding-left: 200px !important; /* Adjusted for smaller image */
    padding-right: 30px !important;
    align-items: flex-start; 
    text-align: left;
}

/* DORIS: Image Right, Text Pushed Left */
#special-chat.talk-doris {
    padding-right: 200px !important; /* Adjusted for smaller image */
    padding-left: 30px !important;
    
    /* Force text to align LEFT */
    align-items: flex-start !important; 
    text-align: left !important;
}

/* --- TYPOGRAPHY --- */

#sp-name {
    color: #8b0000; 
    font-size: 32px; /* Slightly smaller */
    font-weight: 900; 
    margin-bottom: 5px; 
    font-family: 'Georgia', 'Times New Roman', serif; 
    letter-spacing: 1px;
    text-transform: uppercase;
    border-bottom: 2px solid #8b0000; 
    display: inline-block;
    text-shadow: none;
}

#sp-text {
    color: #212121; 
    font-size: 22px; /* Slightly smaller for better fit */
    line-height: 1.2; 
    font-family: 'Georgia', serif; 
    font-weight: 600; 
    text-shadow: none;
}

/* --- PORTRAIT POSITIONING --- */
.portrait-canvas {
    position: absolute;
    bottom: 0;
    pointer-events: none;
    z-index: 605; 
    image-rendering: pixelated;
    background: transparent !important;
}

/* NOAH: Left, Bottom Aligned */
/* NOAH: Left, Bottom Aligned */
/* NOAH: Left, Bottom Aligned */
#canvas-noah {
    left: -175px; 
    
    /* MOVED UP SLIGHTLY (Was -80px -> Now -65px) */
    bottom: -65px; 
    
    width: 540px; 
    height: 540px;
    
    display: none;
    filter: drop-shadow(8px 8px 5px rgba(0,0,0,0.4));
    animation: slideInLeft 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28) forwards;
}


/* DORIS: Right, Bottom Aligned */
#canvas-doris {
    right: -80px; 
    
    /* CHANGE THIS LINE (Moved down another 10px) */
    bottom: -120px; 
    
    /* UNIFIED SIZE: 400px */
    width: 400px; height: 400px;
    
    display: none;
    filter: drop-shadow(-8px 8px 5px rgba(0,0,0,0.4));
    animation: slideInRight 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28) forwards;
}

@keyframes slideInLeft { from{opacity:0; transform:translateX(-40px)} to{opacity:1; transform:translateX(0)} }
@keyframes slideInRight { from{opacity:0; transform:translateX(40px)} to{opacity:1; transform:translateX(0)} }




        .float-txt { 
            position: absolute; font-weight: 900; font-size: 38px; pointer-events: none;
            animation: floatUp 0.8s forwards; 
            -webkit-text-stroke: 1.0px black; 
            text-shadow: 2px 2px 0 #000;
            z-index: 100; font-family: 'Arial Black', sans-serif;
        }
        @keyframes floatUp { 
            0% { transform: translate(-50%, 0) scale(0.5); opacity:0; } 
            20% { transform: translate(-50%, -30px) scale(1.2); opacity:1; }
            100% { transform: translate(-50%, -80px) scale(1.0); opacity:0; } 
        }

        #death-screen {
            position: absolute; top:0; left:0; width:100%; height:100%; 
            background: rgba(20, 0, 0, 0.95);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 2000; color: #fff; text-align: center;
        }

        /* --- ALWAYS HIGHLIGHT WIN/DIE BUTTONS --- */
        #btn-win, #btn-die {
            border-color: #ffd700 !important; 
            color: #ffd700 !important;
            background: #222 !important;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5) !important;
            animation: btnPulse 1.5s infinite alternate;
        }
        
        @keyframes btnPulse {
            from { transform: scale(1.0); box-shadow: 0 0 10px rgba(255, 215, 0, 0.3); }
            to { transform: scale(1.05); box-shadow: 0 0 25px rgba(255, 215, 0, 0.8); }
        }

	

	#win-screen {
            position: absolute; top:0; left:0; width:100%; height:100%; 
            background: rgba(0, 20, 0, 0.95);
            display: none; /* This hides it until you actually win */
            flex-direction: column; justify-content: center; align-items: center;
            z-index: 2000; color: #fff; text-align: center;
        }




        .cert-card { border: 8px double #ffd700; background: #111; padding: 40px; border-radius: 10px; box-shadow: 0 0 50px #ffd700; max-width: 750px; animation: popIn 0.5s; }
        @keyframes popIn { from {transform:scale(0);} to {transform:scale(1);} }

        #start-menu { position: absolute; top:0; left:0; width:100%; height:100%; background: #080808; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 999; pointer-events: auto; }
        .cls-btn { width: 240px; padding: 25px; margin: 15px; background: #222; border: 3px solid #555; color: #fff; text-align: center; cursor: pointer; transition: 0.2s; font-size: 28px; display: inline-block; border-radius: 8px; }
        .cls-btn:hover { border-color: #ffd700; background: #333; transform: scale(1.05); box-shadow: 0 0 20px #ffd700; }
        #title-txt { font-size:90px; color:#4fc3f7; text-shadow: 5px 5px #000, 0 0 30px #4fc3f7; cursor: pointer; margin-bottom: 20px; font-family: 'VT323'; letter-spacing: 5px; }

        /* --- CONFIRMATION MODAL --- */
        #confirm-modal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95); z-index: 6000; /* Highest Priority */
            display: none; justify-content: center; align-items: center; pointer-events: auto;
        }
        /* Highlight state for Confirm Buttons */
        #conf-yes.selected { background: #c0392b; border-color: #fff; transform: scale(1.1); box-shadow: 0 0 20px #c0392b; }
        #conf-no.selected { background: #555; border-color: #fff; transform: scale(1.1); }
        
        /* --- REGION 9: FARM UI OVERLAYS --- */
        #farm-ui-layer { display:none; position: absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index: 1500; }
        
        .farm-menu {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: #2e1a0b; border: 4px solid #a1887f; border-radius: 10px;
            padding: 20px; width: 600px; display: none; pointer-events: auto;
            color: #fff; box-shadow: 0 10px 50px #000;
        }
        .farm-menu h2 { margin-top:0; color: #ffd700; text-align: center; border-bottom: 2px solid #5d4037; }
        .farm-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .farm-btn { background: #5d4037; color:white; border:2px solid #8d6e63; padding:10px; cursor:pointer; font-family:'VT323'; font-size:20px; }
        .farm-btn:hover { background: #795548; border-color:#ffd700; }
        .close-btn { background: #c0392b; margin-top:15px; width:100%; }

        #farm-stats {
            position: absolute; top: 15px; left: 500px;
            background: rgba(46, 125, 50, 0.9); border: 2px solid #81c784; 
            padding: 10px 20px; color: #fff; font-size: 24px; border-radius: 8px;
            display: none;
        }




  /* --- EPIC HERO'S JOURNEY ART --- */
        /* --- AAA RPG COVER ART --- */
       /* --- AAA RPG COVER ART (Golden Hour Edition) --- */
        /* --- AAA RPG COVER ART (Golden Hour Edition) --- */
        #main-menu { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 3000; pointer-events: auto; 
            /* SKY: Cinematic Gradient (Deep Teal -> Sunset Gold) */
            background: linear-gradient(to bottom, #0f2027 0%, #203a43 40%, #ff7e5f 80%, #feb47b 100%);
            overflow: hidden;
        }

        /* SUN GLOW */
        .celestial-body {
            position: absolute; bottom: 30%; left: 50%; transform: translateX(-50%);
            width: 400px; height: 400px;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, rgba(255,200,100,0) 70%);
            border-radius: 50%; pointer-events: none; z-index: 1;
        }

        /* ATMOSPHERE: GOD RAYS */
        .god-rays {
            position: absolute; top: -50%; right: -20%; width: 100%; height: 200%;
            background: repeating-linear-gradient(
                -45deg, transparent, transparent 50px, 
                rgba(255, 255, 255, 0.03) 50px, rgba(255, 255, 255, 0.03) 80px
            );
            pointer-events: none; z-index: 20; opacity: 0.7;
        }

        /* LAYER 1: Distant Mountains (Purple/Blue) */
        .mnt-1 {
            position: absolute; bottom: 20%; left: 0; width: 100%; height: 40%;
            background: #2c3e50; opacity: 0.6;
            clip-path: polygon(0% 100%, 0% 40%, 10% 70%, 20% 40%, 35% 80%, 50% 20%, 65% 60%, 80% 30%, 100% 50%, 100% 100%);
            z-index: 2;
        }

        /* LAYER 2: The Ruins (Silhouetted Castle) */
        .scene-ruins {
            position: absolute; bottom: 32%; left: 45%; 
            width: 120px; height: 140px;
            background: #1a1a1a;
            clip-path: polygon(
                5% 100%, 10% 50%, 5% 50%, 5% 20%, 15% 0%, 25% 20%, 25% 50%, 
                35% 50%, 35% 30%, 65% 30%, 65% 50%, 
                75% 50%, 75% 15%, 85% 0%, 95% 20%, 95% 100%
            );
            z-index: 3; opacity: 0.8;
        }

        /* LAYER 3: Mid Hills (Hides the bottom of ruins) */
        .mnt-2 {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 40%;
            background: linear-gradient(to bottom, #3a2e2a, #231612);
            clip-path: ellipse(80% 50% at 50% 100%);
            z-index: 4;
        }

        /* LAYER 4: The Path (SVG Winding Road) */
        .scene-path-svg {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 45%;
            z-index: 5; pointer-events: none;
            filter: drop-shadow(0 0 10px rgba(0,0,0,0.5));
        }

        /* LAYER 5: Foreground Cliff (Detailed Rock) */
        .cliff-foreground {
            position: absolute; bottom: -50px; right: -50px; 
            width: 60%; height: 50%; z-index: 10;
            background: linear-gradient(135deg, #1a1a1a 30%, #000 100%);
            clip-path: polygon(10% 100%, 0% 30%, 15% 25%, 25% 35%, 35% 20%, 50% 25%, 65% 10%, 80% 15%, 100% 0%, 100% 100%);
        }
        
        /* Cliff Rim Light (Golden Edge) */
        .cliff-highlight {
            position: absolute; bottom: -50px; right: -50px; 
            width: 60%; height: 50%; z-index: 11;
            background: rgba(255, 160, 0, 0.1);
            clip-path: polygon(
                10% 100%, 0% 30%, 15% 25%, 25% 35%, 35% 20%, 50% 25%, 65% 10%, 80% 15%, 100% 0%, 
                100% 5%, 80% 20%, 65% 15%, 50% 30%, 35% 25%, 0% 35%, 15% 100%
            );
            pointer-events: none;
        }

        /* LAYER 6: HERO */
        .hero-container {
            position: absolute; bottom: 22%; right: 18%;
            width: 80px; height: 140px; z-index: 15;
            transform: scale(0.9);
        }
        .hero-cape {
            position: absolute; top: 32px; left: -20px;
            width: 50px; height: 90px;
            background: #800000;
            transform-origin: top right; border-radius: 0 0 0 90%;
            animation: windBlow 3s ease-in-out infinite alternate;
        }
        @keyframes windBlow { 0% { transform: rotate(5deg) skewX(5deg); } 100% { transform: rotate(15deg) skewX(15deg) scaleX(1.1); } }
        .hero-leg { position: absolute; bottom: 0; width: 14px; height: 50px; background: #080808; z-index: 1; }
        .hero-body { position: absolute; bottom: 45px; left: 10px; width: 45px; height: 55px; background: #080808; clip-path: polygon(0 0, 100% 0, 85% 100%, 15% 100%); z-index: 2; }
        .hero-head { position: absolute; bottom: 100px; left: 20px; width: 25px; height: 30px; background: #080808; border-radius: 5px; z-index: 3; }
        .hero-sword {
            position: absolute; bottom: -10px; left: 35px; width: 6px; height: 130px;
            background: linear-gradient(to right, #222, #888, #222); z-index: 5;
        }
        .hero-arm { position: absolute; bottom: 85px; left: 35px; width: 12px; height: 35px; background: #080808; transform: rotate(-15deg); z-index: 4; }

        /* PARTICLES */
        .ember {
            position: absolute; width: 4px; height: 4px; background: #ffd700;
            border-radius: 50%; box-shadow: 0 0 10px #ff9800;
            animation: rise 5s linear infinite; opacity: 0; z-index: 30;
        }
        @keyframes rise { 0% { transform: translateY(0) scale(1); opacity: 0; } 50% { opacity: 1; } 100% { transform: translateY(-300px) scale(0); opacity: 0; } }












        /* MENU PAGES */
        .menu-page { position: absolute; top:0; left:0; width:100%; height:100%; display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 10; animation: fadeIn 0.5s; }
        .menu-page.active { display: flex; }
        @keyframes fadeIn { from{opacity:0; transform:translateY(10px);} to{opacity:1; transform:translateY(0);} }

        /* TEXT & BUTTONS */
        h1.game-title { 
            font-size: 100px; 
            /* Metallic Gold Gradient */
            background: linear-gradient(to bottom, #fffbe3 20%, #ffd700 50%, #b8860b 80%);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            /* Heavy Shadow for 3D effect */
            filter: drop-shadow(0px 5px 0px #000);
            margin-bottom: 5px; letter-spacing: 8px; text-align: center; 
            font-family: 'VT323'; cursor: pointer; text-transform: uppercase;
        }




        .subtitle { color: #aab; font-size: 24px; letter-spacing: 3px; margin-bottom: 50px; text-shadow: 2px 2px 0 #000; }
        
        .btn-main { 
            width: 300px; padding: 18px; margin: 12px; 
            background: rgba(46, 26, 11, 0.9); /* Dark Leather Brown */
            border: 2px solid #8d6e63; border-left: 6px solid #a1887f;



border-left: 6px solid #555; color: #fff; font-size: 28px; cursor: pointer; font-family: 'VT323'; text-align: left; padding-left: 40px; transition: 0.2s; position: relative; }
        


.btn-main:hover { 
            background: #3e2723; /* Lighter Brown */
            border-color: #ffd700; border-left-color: #ffd700; 
            padding-left: 55px; color: #ffd700; 
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5); 
        }

        /* CLASS CARDS */
        .class-grid { display: flex; gap: 30px; margin-bottom: 40px; }
        .class-card { width: 200px; height: 320px; background: rgba(10, 10, 10, 0.9); border: 3px solid #444; border-radius: 8px; display: flex; flex-direction: column; align-items: center; cursor: pointer; transition: 0.3s; padding: 20px; position: relative; overflow: hidden; }
        .class-card:hover { transform: translateY(-10px); border-color: #fff; box-shadow: 0 0 25px rgba(255,255,255,0.2); }
        .class-card[data-cls="warrior"]:hover { border-color: #e53935; box-shadow: 0 0 25px #e53935; }
        .class-card[data-cls="mage"]:hover { border-color: #8e24aa; box-shadow: 0 0 25px #8e24aa; }


        .class-card[data-cls="rogue"]:hover { border-color: #fdd835; box-shadow: 0 0 25px #fdd835; }
        
        /* RESTORED ICONS */
        .cls-icon-lg { font-size: 50px; margin-bottom: 5px; filter: drop-shadow(0 4px 0 #000); }
        
        .cls-name { font-size: 24px; color: #fff; margin-bottom: 5px; border-bottom: 1px solid rgba(255,255,255,0.2); width: 80%; text-align: center; font-weight: bold; letter-spacing: 2px; }
        
        .class-card canvas { margin-top: 10px; filter: drop-shadow(0 5px 5px rgba(0,0,0,0.5)); transition: 0.3s; }
        .class-card:hover canvas { transform: scale(1.1); filter: drop-shadow(0 10px 10px rgba(0,0,0,0.8)); }

        


/* CONTINUE SLOTS (Visual Only) */
/* KEYBOARD NAVIGATION & SLOTS */
        .btn-main.selected, .btn-main:hover { 
            background: #3e2723; border-color: #ffd700; border-left-color: #ffd700; 
            padding-left: 55px; color: #ffd700; box-shadow: 0 0 20px rgba(255, 215, 0, 0.5); 
        }

        .class-card.selected, .class-card:hover { transform: translateY(-10px); border-color: #fff; box-shadow: 0 0 25px rgba(255,255,255,0.2); }
        .class-card[data-cls="warrior"].selected { border-color: #e53935; box-shadow: 0 0 25px #e53935; }
        .class-card[data-cls="mage"].selected { border-color: #8e24aa; box-shadow: 0 0 25px #8e24aa; }
        .class-card[data-cls="rogue"].selected { border-color: #fdd835; box-shadow: 0 0 25px #fdd835; }

        .save-slot { width: 600px; height: 80px; background: rgba(0,0,0,0.8); border: 2px dashed #555; margin: 10px; display: flex; align-items: center; justify-content: center; color: #777; font-size: 24px; transition: 0.2s; }
        .save-slot.selected, .save-slot:hover { border-color: #ffd700; transform: scale(1.02); box-shadow: 0 0 15px rgba(255,215,0,0.3); background: #222; }

        .btn-back.selected, .btn-back:hover { background: #e74c3c; box-shadow: 0 0 15px #e74c3c; transform: scale(1.05); }


        

.btn-back { margin-top: 30px; width: 200px; text-align: center; background: #c0392b; border: none; padding: 10px; color: white; cursor: pointer; font-size: 22px; font-family: inherit; }




        /* --- SYSTEM HINT (Bottom Right) --- */
        /* --- SYSTEM HINT (Bottom Right - REDESIGNED) --- */
        /* ========================================= */
    /* 1. SYSTEM HINT (Bottom Right - FINAL)     */
    /* ========================================= */
    #sys-hint {
        position: absolute; 
        bottom: 25px; right: 25px; 
        width: 70px; height: 70px; 
        
        display: flex; justify-content: center; align-items: center;
        
        cursor: pointer; pointer-events: auto;
        z-index: 1000;

        /* TRANSPARENCY SETTINGS */
        opacity: 0.4;  /* 40% visible by default (Ghost mode) */
        transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    #sys-hint:hover { 
        opacity: 1; 
        transform: scale(1.15) rotate(-15deg); /* ORBIT EFFECT */
    }
    
    #sys-hint:active { transform: scale(0.95) rotate(-15deg); }
    
    /* ICON (Floppy Disk) */
    #sys-hint .icon { 
        font-size: 75px; 
        line-height: 1;
        filter: drop-shadow(0 5px 5px rgba(0,0,0,0.5)); 
        color: #fff;
    }

    /* BADGE ([S] Key) */
    #sys-hint .key { 
        position: absolute;
        top: 50%; left: 50%; 
        transform: translate(-50%, -40%); /* CENTERED */
        
        background: #c62828; /* RED */
        border: 2px solid #ffcdd2; 
        border-radius: 6px;
        
        color: #fff;
        font-family: 'VT323', monospace;
        font-size: 32px; 
        font-weight: bold;
        line-height: 1;
        padding: 2px 8px;
        
        box-shadow: 0 4px 8px rgba(0,0,0,0.8);
        text-shadow: 2px 2px 0 #000;
        z-index: 10;
    }
    
    #sys-hint:hover .key {
        background: #e53935; 
        border-color: #fff;
        box-shadow: 0 0 15px #e53935;
    }

    /* ========================================= */
    /* 2. PAUSE MENU OVERLAY (Restored Styles)   */
    /* ========================================= */
    #pause-menu {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        
        /* CHANGED: 0.5 (50% transparent) instead of 0.9 */
        background: rgba(0, 0, 0, 0.5); 
        
        /* CHANGED: Less blur so you can see details */
        backdrop-filter: blur(3px);
        
        z-index: 2000; pointer-events: auto;
        display: flex; justify-content: center; align-items: center;
    }

    .menu-panel {
        width: 550px; 
        background: linear-gradient(135deg, #1a1a1a 0%, #080808 100%);
        border: 4px solid #5d4037;
        border-top: 6px solid #ffd700;
        border-radius: 12px;
        box-shadow: 0 0 80px rgba(0,0,0,1);
        padding: 40px;
        text-align: center;
        animation: slideUp 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
    }
    @keyframes slideUp { from { transform: translateY(50px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

    .menu-header {
        color: #ffd700; 
        font-size: 70px; 
        margin: 0 0 40px 0;
        font-family: 'Times New Roman', serif; 
        letter-spacing: 8px;
        border-bottom: 2px solid #333; padding-bottom: 20px;
        text-shadow: 0 5px 0 #000;
    }

    .menu-grid { display: flex; flex-direction: column; gap: 25px; }

    .m-btn {
        background: #222; border: 3px solid #444; padding: 25px;
        display: flex; align-items: center; gap: 30px;
        cursor: pointer; transition: 0.2s; position: relative;
        overflow: hidden; border-radius: 8px;
    }
    .m-btn.selected, .m-btn:hover { background: #333; border-color: #ffd700; transform: scale(1.05); box-shadow: 0 0 30px rgba(255, 215, 0, 0.3); }
    .m-btn:active { transform: scale(0.98); }
    
    .quit-btn.selected, .quit-btn:hover { opacity: 1; transform: scale(1.1); text-shadow: 0 0 10px #c0392b; background: rgba(192, 57, 43, 0.1); border-color: #c0392b; }
    .m-btn:active { transform: scale(0.98); }
    
    .m-btn::before { content:''; position: absolute; left: 0; top: 0; height: 100%; width: 10px; background: #ffd700; opacity: 0; transition: 0.2s; }
    .m-btn:hover::before { opacity: 1; }

    .m-icon { font-size: 55px; filter: drop-shadow(0 3px 0 #000); }
    .m-txt { font-size: 40px; color: #fff; font-weight: bold; letter-spacing: 2px; line-height: 1; text-transform:uppercase; font-family: 'VT323'; }
    .m-sub { font-size: 20px; color: #888; margin-top: 8px; font-style: italic; font-family:'Times New Roman'; }

    .quit-btn {
        margin-top: 40px; padding: 15px; color: #c0392b; 
        border: 2px solid transparent; cursor: pointer; 
        font-size: 32px; font-weight: bold; letter-spacing: 2px;
        transition: 0.2s; opacity: 0.8; font-family: 'VT323';
    }
    .quit-btn:hover { opacity: 1; transform: scale(1.1); text-shadow: 0 0 10px #c0392b; }
    </style>


    </style>
</head>
<body>

<div id="game-wrapper">





    <canvas id="cvs" width="960" height="720"></canvas>
    
    <!-- REGION 9: Farm Menus -->
    
   




    <div class="ui-layer">
        <div id="hud-top">
            <div class="stat-col">
                <div class="stat-box">‚ù§Ô∏è 
    <div class="bar-w">
        <div id="hp-bar" class="bar-f" style="background:#e74c3c; width:100%"></div>
    </div>
</div>

                <div class="xp-w"><div id="xp-bar" class="xp-f"></div></div>
            </div>
            <div class="stat-box">LVL <span id="lvl-val" style="color:#ffd700; margin-left:5px">1</span></div>
            <div id="minimap-container">
            <canvas id="minimap"></canvas>
            <div id="mini-player"></div>     <!-- The Red Dot -->
        </div>
        </div>
        <div id="quest-panel">
            <div style="color:#ffd700; font-weight:bold; border-bottom:1px solid #555; margin-bottom:5px;">CURRENT MISSION</div>
            <div id="quest-txt">Loading...</div>
        </div>


        <!-- 1. STANDARD BOX (For Elder Man, Intro, Mobs) -->
<div id="rpg-chat">
    <div id="chat-name"></div>
    <div id="chat-text"></div>
</div>

<!-- 2. SPECIAL BOX (Only for Noah & Doris) -->
<div id="special-chat">
    <div id="sp-name"></div>
    <div id="sp-text"></div>
    <!-- Portraits live here now -->
    <canvas id="canvas-noah" class="portrait-canvas" width="1500" height="1500"></canvas>
    <canvas id="canvas-doris" class="portrait-canvas" width="900" height="900"></canvas>
</div>
       




 <div id="skill-bar"></div>

        



        <!-- 1. THE CORNER HINT (Redesigned: Transparent & Corner) -->
    <div id="sys-hint" onclick="togglePauseMenu()">
        <div class="icon">üíæ</div>
        <div class="key">[S]</div>
    </div>

    <!-- 2. THE PAUSE MENU (No Settings, Big Text) -->
   <!-- 2. THE PAUSE MENU (Updated Labels) -->
    <div id="pause-menu" style="display:none;">
        <div class="menu-panel">
            <h2 class="menu-header">SYSTEM</h2>
            
            <div class="menu-grid">
                <!-- SAVE OPTION -->
                <div class="m-btn" onclick="triggerSaveUI()">
                    <span class="m-icon">üíæ</span>
                    <div style="display:flex; flex-direction:column; align-items:flex-start;">
                        <span class="m-txt">SAVE GAME</span>
                        <span class="m-sub">Record your progress</span>
                    </div>
                </div>

                <!-- CLOSE MENU (Formerly RESUME) -->
                <div class="m-btn" onclick="togglePauseMenu()">
                    <span class="m-icon">‚úñ</span>
                    <div style="display:flex; flex-direction:column; align-items:flex-start;">
                        <span class="m-txt">CLOSE MENU</span>
                        <span class="m-sub">Back to adventure</span>
                    </div>
                </div>
            </div>

           <!-- QUIT GAME (Formerly EXIT TO TITLE) -->
            <div class="quit-btn" onclick="returnToMenu(); togglePauseMenu();">
                QUIT GAME
            </div>

            <!-- KEYBOARD HINTS FOOTER -->
            <div style="margin-top: 25px; border-top: 2px solid #333; padding-top: 15px; display: flex; justify-content: space-between; font-size: 22px; color: #aaa; font-family: 'VT323';">
                <span><span style="color:#ffd700">[‚Üï]</span> MOVE</span>
                <span><span style="color:#2e7d32">[SPC]</span> SELECT</span>
                <span><span style="color:#c62828">[ESC]</span> CLOSE</span>
            </div>
        </div>
    </div>













    <!-- 4. THE SAVE SLOT MENU (With Delete) -->
   <!-- 3. THE SAVE SLOT MENU (With Delete) -->
    <div id="save-menu" style="display:none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); z-index: 2100; justify-content: center; align-items: center; pointer-events: auto;">
        
        <div class="menu-panel" style="width: 550px; padding: 30px;">
            <h2 class="menu-header" style="margin-bottom: 20px; font-size: 60px;">SELECT SLOT</h2>
            
            <div class="menu-grid" style="gap: 15px;">
                
                <!-- SLOT 1 ROW -->
                <div style="display:flex; gap:10px; width:100%;">
                    <!-- Save Button -->
                    <div class="m-btn" onclick="finalSave('rpg_save_slot_1')" style="padding: 15px; flex-grow: 1;">
                        <span class="m-icon" style="font-size: 35px;">üíæ</span>
                        <div style="display:flex; flex-direction:column; align-items:flex-start;">
                            <span class="m-txt" style="font-size: 28px;">SLOT 1</span>
                            <span id="save-info-1" class="m-sub" style="font-size:16px; color:#888;">Checking...</span>
                        </div>
                    </div>
                    <!-- Delete Button -->
                    <div class="m-btn" onclick="deleteSlot('rpg_save_slot_1', 'save-info-1')" style="padding: 0; width: 70px; justify-content: center; border-color:#c0392b; background:#2c0b0b;">
                        <span style="font-size: 30px;">üóëÔ∏è</span>
                    </div>
                </div>

                <!-- SLOT 2 ROW -->
                <div style="display:flex; gap:10px; width:100%;">
                    <div class="m-btn" onclick="finalSave('rpg_save_slot_2')" style="padding: 15px; flex-grow: 1;">
                        <span class="m-icon" style="font-size: 35px;">üíæ</span>
                        <div style="display:flex; flex-direction:column; align-items:flex-start;">
                            <span class="m-txt" style="font-size: 28px;">SLOT 2</span>
                            <span id="save-info-2" class="m-sub" style="font-size:16px; color:#888;">Checking...</span>
                        </div>
                    </div>
                    <div class="m-btn" onclick="deleteSlot('rpg_save_slot_2', 'save-info-2')" style="padding: 0; width: 70px; justify-content: center; border-color:#c0392b; background:#2c0b0b;">
                        <span style="font-size: 30px;">üóëÔ∏è</span>
                    </div>
                </div>

                <!-- SLOT 3 ROW -->
                <div style="display:flex; gap:10px; width:100%;">
                    <div class="m-btn" onclick="finalSave('rpg_save_slot_3')" style="padding: 15px; flex-grow: 1;">
                        <span class="m-icon" style="font-size: 35px;">üíæ</span>
                        <div style="display:flex; flex-direction:column; align-items:flex-start;">
                            <span class="m-txt" style="font-size: 28px;">SLOT 3</span>
                            <span id="save-info-3" class="m-sub" style="font-size:16px; color:#888;">Checking...</span>
                        </div>
                    </div>
                    <div class="m-btn" onclick="deleteSlot('rpg_save_slot_3', 'save-info-3')" style="padding: 0; width: 70px; justify-content: center; border-color:#c0392b; background:#2c0b0b;">
                        <span style="font-size: 30px;">üóëÔ∏è</span>
                    </div>
                </div>

                <!-- Back Button -->
                <div class="m-btn" style="border-color:#555; padding: 10px; justify-content: center;" onclick="closeSaveMenu()">
                    <span class="m-icon" style="font-size: 24px;">‚Ü©Ô∏è</span>
                    <span class="m-txt" style="font-size: 24px;">BACK</span>
                </div>
            </div>
        </div>
    </div>





    </div>

    <div id="win-screen">




        <div class="cert-card">
            <h1 style="color:#ffd700; font-size:60px; margin:0; text-shadow:0 0 10px #ffd700;">JOURNEY COMPLETE</h1>
            <p style="font-size:24px; color:#aaa; margin-top:10px;">The world is safe.</p>
            <hr style="border-color:#444; margin: 20px 0;">
            <p style="font-size:32px; color:#fff;">To the bravest soul...</p>
            <h2 style="font-size:55px; color:#ffd700; margin:10px 0; text-shadow: 0 0 20px #ffd700;">NOAH'S LOYAL KNIGHT</h2>
            <div style="background:#222; padding:20px; border-radius:8px; margin-top:20px; text-align:center;">
                <p style="font-size:24px; color:#f1c40f; margin:5px;">‚ú® A SPECIAL MESSAGE ‚ú®</p>
                <p style="font-size:26px; color:#fff; font-style:italic;">"It is a blessing to have you in my life."</p>
                <p style="font-size:22px; color:#aaa;">Thank you for being here.</p>
            </div>
            <!-- WIN BUTTON (Added ID) -->
            <button id="btn-win" onclick="S.audio.play('class_choose'); document.getElementById('win-screen').style.display='none'" 
                    style="padding:15px 40px; font-size:24px; cursor:pointer; background:#2e7d32; color:#fff; border:2px solid #fff; margin-top:30px; border-radius:5px;">
                Return to World
            </button>
            <div style="margin-top:15px; color:#aaa;">[SPACE] TO CONTINUE</div>
        </div>
    </div>







<!-- DEATH SCREEN -->
    <div id="death-screen" style="display:none;">
        <div class="cert-card" style="border-color:#c0392b; box-shadow: 0 0 50px #c0392b;">
            <h1 style="color:#e74c3c; font-size:60px; margin:0; text-shadow:0 0 10px #c0392b;">YOU HAVE FALLEN</h1>
            <p style="font-size:24px; color:#aaa; margin-top:10px;">Your journey ends here.</p>
            <hr style="border-color:#444; margin: 20px 0;">
            <p style="font-size:32px; color:#fff;">Defeated by...</p>
            <h2 id="death-msg" style="font-size:55px; color:#e74c3c; margin:10px 0; text-shadow: 0 0 20px #c0392b;">UNKNOWN</h2>
           
           <!-- DEATH BUTTON (Added ID) -->
           <button id="btn-die" onclick="returnToMenu()" 
                    style="padding:15px 40px; font-size:24px; cursor:pointer; background:#c0392b; color:#fff; border:2px solid #fff; margin-top:30px; border-radius:5px;">
                Return to Menu
            </button>
            <div style="margin-top:15px; color:#aaa;">[SPACE] TO CONTINUE</div>
        </div>
    </div>









<!-- MAIN MENU WRAPPER -->
    <div id="main-menu">
        <!-- 0. SKY & ATMOSPHERE -->
        <div class="celestial-body"></div> <!-- The glowing sun aura -->
        <div class="god-rays"></div>
        <div id="ember-layer"></div>

        <!-- 1. BACKGROUND (Far away) -->
        <div class="mnt-1"></div> <!-- Purple mountains -->
        
        <!-- 2. THE DESTINATION -->
        <!-- Placed here so it sits BEHIND the mid-hills -->
        <div class="scene-ruins"></div> 
        
        <!-- 3. MID GROUND (Hills that hide the bottom of ruins) -->
        <div class="mnt-2"></div>
        
        <!-- 4. THE WINDING PATH (SVG) -->
        <!-- Logic: Starts bottom-left, Curves S-shape, Ends top-center (480,100) behind hills -->
        <svg class="scene-path-svg" viewBox="0 0 960 360" preserveAspectRatio="none">
            <defs>
                <linearGradient id="pathGrad" x1="0%" y1="100%" x2="0%" y2="0%">
                    <stop offset="0%" style="stop-color:#5d4037;stop-opacity:1" />  <!-- Dark Dirt near camera -->
                    <stop offset="60%" style="stop-color:#8d6e63;stop-opacity:1" /> <!-- Lighter Dirt mid -->
                    <stop offset="100%" style="stop-color:#a1887f;stop-opacity:0" /> <!-- Fades out at horizon -->
                </linearGradient>
            </defs>
            <!-- 
               M 200,360 = Start at bottom left (Camera)
               C ...     = Bezier Curve
               Ends at 480,120 = The horizon line near ruins
            -->
            <path d="M 150,400 
                     C 300,300 600,300 500,180 
                     S 450,150 480,120 
                     L 520,120 
                     S 550,150 600,180
                     C 700,300 400,300 250,400 Z" 
                  fill="url(#pathGrad)" />
        </svg>

        <!-- 5. FOREGROUND (The Cliff) -->
        <div class="cliff-foreground"></div>
        <div class="cliff-highlight"></div> <!-- Adds the 3D rock edge detail -->

        <!-- 6. THE HERO (Standing on the Cliff) -->
        <div class="hero-container">
            <div class="hero-cape"></div>
            <div class="hero-leg" style="left:15px; transform:skewX(5deg)"></div>
            <div class="hero-leg" style="left:40px; transform:skewX(-5deg)"></div>
            <div class="hero-body"></div>
            <div class="hero-head"></div>
            <div class="hero-sword"></div>
            <div class="hero-arm"></div>
        </div>




        <!-- PAGE 1: HOME -->
        <div id="page-home" class="menu-page active">
            
            <!-- NEW TITLE CONTAINER -->
            <div style="text-align:center; position:relative; z-index:50; margin-bottom:30px;">
                
                <!-- Dedication Text -->
                <div style="font-size:16px; color:#aaa; letter-spacing:4px; margin-bottom:5px; text-transform:uppercase; font-family:'VT323';">
                    A GAME FOR NOAH'S FRIENDS
                </div>

                <!-- MAIN TITLE -->
                <h1 class="game-title" onclick="eggTitle()" style="
                    font-family: 'Times New Roman', serif;
                    font-weight: 900; 
                    font-size: 80px; 
                    letter-spacing: 10px; 
                    margin: 0;
                    text-transform: uppercase;
                    /* Cinematic Gold Gradient */
                    background: linear-gradient(to bottom, #fff 10%, #ffd700 50%, #d4af37 100%);
                    -webkit-background-clip: text; 
                    -webkit-text-fill-color: transparent;
                    /* Deep Shadow */
                    filter: drop-shadow(0 5px 0 rgba(0,0,0,0.8));
                ">
                    THE PROMISED DAWN
                </h1>

                <!-- Divider Line -->
                <div style="width: 300px; height: 3px; background: #ffd700; margin: 10px auto; opacity: 0.8; box-shadow: 0 0 10px #ffd700;"></div>
            </div>

            <!-- BUTTONS -->
            <div class="btn-main" onmouseenter="AudioSys.play('menu_scroll')" onclick="Menu.goto('classes')">START NEW GAME</div>
            <div class="btn-main" onmouseenter="AudioSys.play('menu_scroll')" onclick="Menu.goto('load')">CONTINUE</div>
            
            <!-- KEYBOARD HINT -->
            <div style="margin-top: 30px; color: #777; font-size: 20px; letter-spacing: 2px; text-shadow: 1px 1px 0 #000;">
                <span style="color:#ffd700">[ARROWS]</span> MOVE &nbsp;&nbsp; <span style="color:#ffd700">[SPACE]</span> SELECT
            </div>
        </div>




       <!-- PAGE 2: CLASS SELECTION -->
        <div id="page-classes" class="menu-page">
            <h2 style="color:#fff; font-size:40px; margin-bottom:30px; text-shadow:2px 2px 0 #000;">CHOOSE YOUR HERO</h2>
            
            <div class="class-grid">



                <!-- WARRIOR -->
<div class="class-card" data-cls="warrior" onclick="startNewGame('warrior')" onmouseenter="AudioSys.play('class_hover')">
    <div class="cls-icon-lg">‚öîÔ∏è</div>
    <div class="cls-name">WARRIOR</div>
    <!-- WIDER CANVAS -->
    <canvas id="preview-warrior" width="160" height="140"></canvas>
</div>
<!-- MAGE -->
<div class="class-card" data-cls="mage" onclick="startNewGame('mage')" onmouseenter="AudioSys.play('class_hover')">
    <div class="cls-icon-lg">üî•</div>
    <div class="cls-name">MAGE</div>
    <!-- WIDER CANVAS -->
    <canvas id="preview-mage" width="160" height="140"></canvas>
</div>
<!-- RANGER -->
<div class="class-card" data-cls="rogue" onclick="startNewGame('rogue')" onmouseenter="AudioSys.play('class_hover')">
    <div class="cls-icon-lg">üèπ</div>
    <div class="cls-name">RANGER</div>
    <!-- WIDER CANVAS -->
    <canvas id="preview-rogue" width="160" height="140"></canvas>
</div>
            </div>

            <button class="btn-back" onclick="Menu.goto('home')">BACK</button>
        </div>






      <!-- PAGE 3: CONTINUE (With Delete Options) -->
<div id="page-load" class="menu-page">
    <h2 style="color:#fff; font-size:40px; margin-bottom:30px; text-shadow:2px 2px 0 #000;">LOAD GAME</h2>
    
    <!-- SLOT 1 ROW -->
    <div style="display:flex; width:700px; gap:10px; margin:10px;">
        <div id="slot-btn-1" class="save-slot" onclick="loadGame('rpg_save_slot_1')" style="width:auto; flex-grow:1; margin:0; cursor:pointer;">
            <span>[ SLOT 1 - EMPTY ]</span>
        </div>
        <div id="del-btn-1" class="save-slot" onclick="deleteSlot('rpg_save_slot_1', 'slot-btn-1')" style="width:80px; margin:0; cursor:pointer; border-color:#c0392b; color:#c0392b;">
            üóëÔ∏è
        </div>
    </div>

    <!-- SLOT 2 ROW -->
    <div style="display:flex; width:700px; gap:10px; margin:10px;">
        <div id="slot-btn-2" class="save-slot" onclick="loadGame('rpg_save_slot_2')" style="width:auto; flex-grow:1; margin:0; cursor:pointer;">
            <span>[ SLOT 2 - EMPTY ]</span>
        </div>
        <div id="del-btn-2" class="save-slot" onclick="deleteSlot('rpg_save_slot_2', 'slot-btn-2')" style="width:80px; margin:0; cursor:pointer; border-color:#c0392b; color:#c0392b;">
            üóëÔ∏è
        </div>
    </div>

    <!-- SLOT 3 ROW -->
    <div style="display:flex; width:700px; gap:10px; margin:10px;">
        <div id="slot-btn-3" class="save-slot" onclick="loadGame('rpg_save_slot_3')" style="width:auto; flex-grow:1; margin:0; cursor:pointer;">
            <span>[ SLOT 3 - EMPTY ]</span>
        </div>
        <div id="del-btn-3" class="save-slot" onclick="deleteSlot('rpg_save_slot_3', 'slot-btn-3')" style="width:80px; margin:0; cursor:pointer; border-color:#c0392b; color:#c0392b;">
            üóëÔ∏è
        </div>
    </div>

    <button class="btn-back" onclick="Menu.goto('home')">BACK</button>
</div>





    </div>


</div>

    <!-- MOVED CONFIRMATION MODAL HERE (So it sits on top of Main Menu) -->
    <div id="confirm-modal" style="display:none;">
        <div class="menu-panel" style="border-color:#c0392b;">
            <h2 class="menu-header" style="font-size:50px; color:#c0392b; border-color:#555;">DELETE SAVE?</h2>
            <p style="font-size:24px; color:#ccc; margin-bottom:30px;">This cannot be undone.</p>
            
            <div style="display:flex; gap:20px; justify-content:center;">
                <!-- YES BUTTON -->
                <div id="conf-yes" class="m-btn" style="padding:15px; width:120px; justify-content:center; border-color:#444;" 
                     onclick="ConfirmBox.resolve(true)" onmouseenter="ConfirmBox.hover(0)">
                    <span class="m-txt">YES</span>
                </div>
                <!-- NO BUTTON -->
                <div id="conf-no" class="m-btn" style="padding:15px; width:120px; justify-content:center; border-color:#444;" 
                     onclick="ConfirmBox.resolve(false)" onmouseenter="ConfirmBox.hover(1)">
                    <span class="m-txt">NO</span>
                </div>
            </div>
            
            <!-- KEYBOARD HINT -->
            <div style="margin-top:20px; font-size:18px; color:#555;">
                [ARROWS] Choose &nbsp; [SPACE] Confirm
            </div>
        </div>
    </div>


<!-- LOAD FARM LOGIC MODULE -->
<script src="farm.js"></script>

<script>
// --- NEW MENU LOGIC ---


const Menu = {
    selIdx: 0, // Tracks which button is selected

    goto: function(pageId) {
        document.querySelectorAll('.menu-page').forEach(el => el.classList.remove('active'));
        const target = document.getElementById('page-' + pageId);
        if(target) target.classList.add('active');
        if(typeof AudioSys !== 'undefined') AudioSys.play('menu_tab');

        if(pageId === 'load') this.updateSlots();
        
        // RESET KEYBOARD SELECTION ON PAGE CHANGE
        this.selIdx = 0;
        setTimeout(() => this.updateSelection(null), 50); 
    },

    // --- KEYBOARD INPUT HANDLER ---
    handleInput: function(e) {
        // Only run if Main Menu is visible
        if(document.getElementById('main-menu').style.display === 'none') return;
        
        // 1. Wake Audio
        if(typeof AudioSys !== 'undefined' && AudioSys.ctx.state === 'suspended') AudioSys.ctx.resume();

        const key = e.key.toLowerCase();
        const validKeys = ['arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' '];
        if(!validKeys.includes(key)) return;

        e.preventDefault(); // Stop page scrolling

        // Find clickable items on current page
        const page = document.querySelector('.menu-page.active');
        if(!page) return;
        
        // Get all buttons that are currently visible
        let targets = Array.from(page.querySelectorAll('.btn-main, .class-card, .save-slot, .btn-back'));
        targets = targets.filter(el => {
            const style = window.getComputedStyle(el);
            return style.display !== 'none' && style.visibility !== 'hidden' && el.offsetParent !== null;
        });

        if(targets.length === 0) return;

        // --- ARROW NAVIGATION (Spatial Search) ---
        if(key.includes('arrow')) {
            const cur = targets[this.selIdx] || targets[0];
            const r1 = cur.getBoundingClientRect();
            const c1 = { x: r1.left + r1.width/2, y: r1.top + r1.height/2 };

            let best = null, minDist = Infinity;

            targets.forEach((t, i) => {
                if(i === this.selIdx) return;
                const r2 = t.getBoundingClientRect();
                const c2 = { x: r2.left + r2.width/2, y: r2.top + r2.height/2 };
                
                const dx = c2.x - c1.x; // Horizontal difference
                const dy = c2.y - c1.y; // Vertical difference

                let isValid = false;
                let weightedDist = Infinity;

                // STRICT GRID NAVIGATION:
                // We add a huge "Penalty" (x10) if the item is not aligned in the direction you are pressing.
                // This ensures "Down" prefers buttons strictly below, and "Right" prefers buttons strictly to the right.

                // DOWN: Must be below (>10px). Penalty for Horizontal offset.
                if(key === 'arrowdown' && dy > 10) { 
                    isValid = true;
                    weightedDist = Math.abs(dy) + (Math.abs(dx) * 10); 
                }
                // UP: Must be above (<-10px). Penalty for Horizontal offset.
                if(key === 'arrowup' && dy < -10) { 
                    isValid = true;
                    weightedDist = Math.abs(dy) + (Math.abs(dx) * 10);
                }
                // RIGHT: Must be to right (>10px). Penalty for Vertical offset.
                if(key === 'arrowright' && dx > 10) { 
                    isValid = true;
                    weightedDist = Math.abs(dx) + (Math.abs(dy) * 10);
                }
                // LEFT: Must be to left (<-10px). Penalty for Vertical offset.
                if(key === 'arrowleft' && dx < -10) { 
                    isValid = true;
                    weightedDist = Math.abs(dx) + (Math.abs(dy) * 10);
                }

                if(isValid && weightedDist < minDist) { 
                    minDist = weightedDist; 
                    best = i; 
                }
            });



            if(best !== null) {
                this.selIdx = best;
                AudioSys.play('menu_scroll');
                this.updateSelection(targets);
            }
        }

        // --- SPACEBAR ACTION ---
        if(key === ' ') {
            if(targets[this.selIdx]) targets[this.selIdx].click();
        }
    },

    updateSelection: function(targets) {
        if(!targets) {
             const page = document.querySelector('.menu-page.active');
             if(!page) return;
             targets = Array.from(page.querySelectorAll('.btn-main, .class-card, .save-slot, .btn-back'));
             targets = targets.filter(el => el.style.visibility !== 'hidden' && el.style.display !== 'none');
        }
        document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
        if(targets[this.selIdx]) targets[this.selIdx].classList.add('selected');
        else { this.selIdx = 0; if(targets[0]) targets[0].classList.add('selected'); }
    },






    updateSlots: function() {        for (let i = 1; i <= 3; i++) {
            let slotKey = 'rpg_save_slot_' + i;
            let loadBtn = document.getElementById('slot-btn-' + i);
            let delBtn = document.getElementById('del-btn-' + i); // Find the trash can
            let raw = localStorage.getItem(slotKey);

            if (raw) {
                // FILE EXISTS
                try {
                    let data = JSON.parse(raw);
                    let meta = data.meta || {};
                    let desc = `${(meta.class||'?').toUpperCase()} (Lv.${meta.lvl||1}) - Day ${meta.day||1}`;
                    
                    loadBtn.innerHTML = `<span style="color:#ffd700; font-weight:bold;">${desc}</span>
                                         <div style="font-size:16px; color:#aaa;">${meta.date || ''}</div>`;
                    loadBtn.style.border = "2px solid #ffd700";
                    loadBtn.style.opacity = "1.0";
                    
                    // Show Delete Button
                    delBtn.style.visibility = "visible";
                    
                } catch(e) {
                    loadBtn.innerHTML = `<span>[ SLOT ${i} - CORRUPTED ]</span>`;
                    delBtn.style.visibility = "visible";
                }
            } else {
                // FILE EMPTY
                loadBtn.innerHTML = `<span>[ SLOT ${i} - EMPTY ]</span>`;
                loadBtn.style.border = "2px dashed #555";
                loadBtn.style.opacity = "0.5";
                
                // Hide Delete Button
                delBtn.style.visibility = "hidden";
            }
        }
    },






    initEmbers: function() {
        const container = document.getElementById('ember-layer');
        if(!container) return;
        container.innerHTML = ''; // Clear previous

        // Create 80 Visible Particles
        for(let i=0; i<80; i++) {
            let s = document.createElement('div');
            s.className = 'ember';
            
            // Random Position
            s.style.left = Math.random() * 100 + '%';
            s.style.bottom = Math.random() * 60 + '%'; // Keep low to ground
            
            // Random Size (Depth)
            let size = 2 + Math.random() * 3;
            s.style.width = size + 'px';
            s.style.height = size + 'px';
            
            // Random Speed
            s.style.animationDuration = (3 + Math.random() * 4) + 's';
            s.style.animationDelay = (Math.random() * 5) + 's';
            
            container.appendChild(s);
        }
    }
};






// --- MENU HERO RENDERER ---
Menu.drawHero = function(id, cls) {
    const ctx = document.getElementById(id).getContext('2d');
    ctx.imageSmoothingEnabled = false;
    
    // 1. CLEAR THE NEW WIDER AREA
    ctx.clearRect(0, 0, 160, 140);
    
    ctx.save();
    // 2. POSITIONING FIX
    // X=80 (Center of 160)
    // Y=100 (Lower down so head fits)
    ctx.translate(80, 130); 
    
    // 3. SCALE
    ctx.scale(2.2, 2.2); 

    // Define Colors

    // Define Colors
    let cMain, cSec, cAcc, cDark, cBoot, cHair, cHigh;
    if(cls === 'warrior') { cMain='#eceff1'; cSec='#1565c0'; cAcc='#ffd700'; cDark='#455a64'; cBoot='#37474f'; cHair='#3e2723'; cHigh='#ffffff'; }
    else if(cls === 'mage') { cMain='#4527a0'; cSec='#7c4dff'; cAcc='#00e5ff'; cDark='#311b92'; cBoot='#1a1a1a'; cHair='#ffe082'; cHigh='#b388ff'; }
    else { cMain='#37474f'; cSec='#ff6d00'; cAcc='#ffeb3b'; cDark='#263238'; cBoot='#212121'; cHair='#5d4037'; cHigh='#ff9e80'; }

    // 1. LEGS (Standing pose)
    const drawBoot = (bx, by, w, h, color) => {
        ctx.fillStyle = color; ctx.fillRect(bx, by, w, h); 
        ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.fillRect(bx, by + h - 2, w, 2);
    };
    drawBoot(-7, -12, 5, 12, cBoot); // Left
    drawBoot(2, -12, 5, 12, cBoot);  // Right

    // 2. BODY
    let bodyY = -24;
    // Cape
    ctx.fillStyle = (cls==='mage') ? cDark : cSec; 
    ctx.fillRect(-10, bodyY+10, 20, 10);
    
    // Torso
    ctx.fillStyle = cMain;
    ctx.fillRect(-9, bodyY, 18, 14);
    ctx.fillStyle = cDark; ctx.fillRect(-9, bodyY+10, 18, 3); // Belt
    ctx.fillStyle = 'rgba(0,0,0,0.15)'; ctx.fillRect(-5, bodyY, 10, 2); // Neck

    // Chest Details
    if(cls==='warrior') { ctx.fillStyle = cSec; ctx.fillRect(-3, bodyY+2, 6, 8); ctx.fillRect(-6, bodyY+4, 12, 4); }
    if(cls==='mage') { ctx.fillStyle = cAcc; ctx.fillRect(-2, bodyY, 4, 14); }
    if(cls==='rogue') { ctx.fillStyle = '#5d4037'; ctx.beginPath(); ctx.moveTo(-9, bodyY); ctx.lineTo(-6, bodyY); ctx.lineTo(9, bodyY+14); ctx.lineTo(6, bodyY+14); ctx.fill(); }

    // 3. HEAD
    let headY = bodyY - 14;
    ctx.fillStyle = '#ffe0bd'; ctx.fillRect(-8, headY, 16, 16); // Skin
    
    // Hair
    ctx.fillStyle = cHair;
    if(cls==='warrior') ctx.fillRect(-8, headY, 16, 4);
    if(cls==='mage') { ctx.fillRect(-11, headY-2, 5, 20); ctx.fillRect(6, headY-2, 5, 20); }
    if(cls==='rogue') { ctx.fillRect(-9, headY, 18, 4); }

    // Hat/Helm
    if(cls === 'warrior') { 
        ctx.fillStyle = cMain; ctx.fillRect(-9, headY-5, 18, 10);
        ctx.fillStyle = cHigh; ctx.fillRect(-6, headY-4, 4, 3); // Shine
        ctx.fillStyle = cMain; ctx.fillRect(-10, headY-2, 2, 14); ctx.fillRect(8, headY-2, 2, 14);
        ctx.fillStyle = cSec; ctx.fillRect(-2, headY-8, 4, 16); // Crest
    } 
    else if(cls === 'mage') { 
        ctx.fillStyle = cMain; 
        ctx.beginPath(); ctx.moveTo(-14, headY); ctx.lineTo(14, headY); ctx.lineTo(0, headY-20); ctx.fill();
        ctx.fillStyle = cAcc; ctx.fillRect(-8, headY-2, 16, 2);
    } 
    else { // Rogue Hood
        ctx.fillStyle = cSec; 
        ctx.beginPath(); ctx.moveTo(-10, headY); ctx.lineTo(10, headY); ctx.lineTo(6, headY-5); ctx.lineTo(-8, headY-5); ctx.fill();
        ctx.strokeStyle = cAcc; ctx.lineWidth = 3; 
        ctx.beginPath(); ctx.moveTo(0, headY-3); ctx.quadraticCurveTo(-10, headY-8, -14, headY-2); ctx.stroke();
    }

    // Eyes
    ctx.fillStyle = (cls==='mage') ? cAcc : '#111';
    ctx.fillRect(-5, headY+6, 3, 3); ctx.fillRect(2, headY+6, 3, 3);

    // 4. ARMS (Idle)
    ctx.fillStyle = (cls==='warrior') ? cMain : cSec; 
    ctx.fillRect(-14, bodyY, 5, 5); ctx.fillRect(9, bodyY, 5, 5);
    ctx.fillStyle = '#ffe0bd'; 
    ctx.fillRect(-13, bodyY + 5, 4, 7); ctx.fillRect(9, bodyY + 5, 4, 7);

    ctx.restore();
};

window.addEventListener('load', () => {
    Menu.initEmbers(); 
    Menu.drawHero('preview-warrior', 'warrior');
    Menu.drawHero('preview-mage', 'mage');
    Menu.drawHero('preview-rogue', 'rogue');

    // 1. Try to play music immediately
    AudioSys.playBGM('home');

    // 2. If browser blocks it, wait for the FIRST CLICK to start it
    const startAudio = () => {
        // Wake up the Audio Engine
        if (AudioSys.ctx.state === 'suspended') AudioSys.ctx.resume();
        // Play the music if it's not playing
        if (AudioSys.bgm && AudioSys.bgm.paused) AudioSys.bgm.play();
    };

    // Add listener to the whole screen
    document.body.addEventListener('click', startAudio, { once: true });
    document.body.addEventListener('keydown', startAudio, { once: true });

    // 3. AUTO-SELECT "START NEW GAME" (Keyboard Support)
    // Small delay to ensure DOM is ready
    setTimeout(() => {
        if(typeof Menu !== 'undefined') Menu.updateSelection();
    }, 100);
});
const cvs = document.getElementById('cvs');
const ctx = cvs.getContext('2d');
const miniCtx = document.getElementById('minimap').getContext('2d');

// --- AUDIO ENGINE START ---
const AudioSys = {
    ctx: new (window.AudioContext || window.webkitAudioContext)(),
    bgm: null,
    currentBgmKey: null,
   srcs: {
        // --- BGM ---
        home: "audio/Home.mp3", 
        adventure: "audio/Adventure_Theme.mp3",      // Was "Adventure Theme.mp3"
        adventure_new: "audio/New_adventure.mp3",    // Was "New adventure.mp3"
        farm_day: "audio/Relaxing_Theme.mp3",        // Was "Relaxing Theme.mp3"
        farm_night: "audio/night_ambience.mp3",      // Was "night ambience.mp3"
        
        // --- SYSTEM / UI ---
        bag: "audio/bag_open.mp3",                   // Was "bag open.mp3"
        error: "audio/error.mp3",
        save: "audio/save.mp3",
        over: "audio/game_over.mp3",                 // Was "game over.mp3"
        
        // 1. KEEP ORIGINAL (For RPG items)
        equip: "audio/item_equip.mp3",               // Was "item equip.mp3"
        
        // 2. ADD NEW ONE (For Farm Tools)
        tool_swap: "audio/equip.mp3",   
        
        lvlup: "audio/lvlup.mp3",
        hover: "audio/Menu_Hover.mp3",               // Was "Menu Hover.mp3"
        buy: "audio/SelectBuy.mp3",
        class_hover: "audio/Class_Hover.mp3",        // Was "Class Hover.mp3"
        class_choose: "audio/Class_chosen.mp3",      // Was "Class chosen.mp3"
        esc: "audio/ESC.mp3", 
        reminder: "audio/reminder.mp3",
        npc: "audio/npc.mp3", 
        success: "audio/Success.mp3", 
        victory: "audio/Victory.mp3", 
        tele: "audio/teleport.mp3",
        pop: "audio/Pop_Sound_Effect.mp3",           // Was "Pop - Sound Effect.mp3"
        btn_click: "audio/button.mp3",
        item_found: "audio/item.mp3", 
        menu_scroll: "audio/menu_button.mp3",        // Was "menu button.mp3"
        menu_tab: "audio/menu_change.mp3",           // Was "menu change.mp3"
        gate: "audio/unlockGate.mp3",

        // --- FARMING ---
        break: "audio/Break.mp3",
        chop: "audio/Chop.mp3",
        hoe: "audio/Hoe_Dig.mp3",                    // Was "Hoe Dig.mp3"
        rock: "audio/Rock_Smash_Sound_Effect.mp3",   // Was "Rock Smash Sound Effect.mp3"
        sickle: "audio/sickle.mp3",
        rooster: "audio/rooster_crow.mp3",           // Was "rooster crow.mp3"
        water: "audio/Watering.mp3",
        well: "audio/well_water.mp3",                // Was "well water.mp3"
        plant: "audio/plant.mp3",
        sell: "audio/sell.mp3",
        put: "audio/put.mp3",
        put_animal: "audio/put_animal.mp3",          // Was "put animal.mp3"
        fishing: "audio/fishing.mp3",
        pet_anim: "audio/Pet.mp3",
        
        // --- MOVEMENT ---
        step: "audio/Footstep.mp3",
        horse: "audio/horse_gallop.mp3",             // Was "horse gallop.mp3"
        horse_walk: "audio/horse_walk.mp3",          // Was "horse walk.mp3"

        // --- COMBAT (GENERIC) ---
        bow: "audio/Bow_Shot.mp3",                   // Was "Bow Shot.mp3"
        explode: "audio/Explosion.mp3",
        magic: "audio/Magic_Cast.mp3",               // Was "Magic Cast.mp3"
        swing: "audio/Melee_Swing.mp3",              // Was "Melee Swing.mp3"
        thud: "audio/thud_sound_effect.mp3",         // Was "thud sound effect.mp3"
        hurt: "audio/Player_Hurt.mp3",               // Was "Player Hurt.mp3"

        // --- SKILL SPECIFIC ---
        grasp_cast: "audio/Abyssal_Cast.mp3",        // Was "Abyssal Cast.mp3"
        grasp_hit: "audio/Abyssal_Hit.mp3",          // Was "Abyssal Hit.mp3"
        starfall: "audio/Starfall.mp3",
        poison: "audio/Poison_Cloud.mp3",            // Was "Poison Cloud.mp3"
        trap: "audio/Trap.mp3",
        shoot: "audio/Shoot.mp3",
        quake: "audio/Quake.mp3",
        tornado: "audio/Tornado.mp3",
        wstomp: "audio/War_Stomp.mp3",               // Was "War Stomp.mp3"
        heal: "audio/Heal.mp3", 
        ice: "audio/Glacial_Spike.mp3",              // Was "Glacial Spike.mp3"
        fairy: "audio/Fairy_Bomb.mp3",               // Was "Fairy Bomb.mp3"
        rush: "audio/Rush.mp3",
        yaka_cast: "audio/Yaka_Cast.mp3",            // Was "Yaka Cast.mp3"
        yaka_hit: "audio/Yaka_Hit.mp3",              // Was "Yaka Hit.mp3"
        arrow_storm: "audio/ArrowStorm.mp3",
        bash: "audio/Bash.mp3",
        thunder: "audio/Thunder.mp3" 
    },
    play: function(key) {
        if(!this.srcs[key]) return;
        let a = new Audio(this.srcs[key]);
        a.volume = 0.4;
        a.play().catch(e=>{});
    },
    playBGM: function(key) {
        if(this.currentBgmKey === key) return;
        if(this.bgm) { this.bgm.pause(); this.bgm = null; }
        if(!this.srcs[key]) return;
        this.bgm = new Audio(this.srcs[key]);
        this.bgm.loop = true;
        this.bgm.volume = 0.3;
        this.bgm.play().catch(e=>{});
        this.currentBgmKey = key;
    }
};
// --- AUDIO ENGINE END ---


const TILE = 50; 
const MAP_S = 180; 
document.getElementById('minimap').width = MAP_S; document.getElementById('minimap').height = MAP_S;

const T = { WATER:0, GRASS:1, FOREST:2, SAND:3, RUINS:4, SWAMP:5, SNOW:6, LAVA:7, VOID:8, ROAD:9, BRIDGE:10, LOCK:11, BEDROCK:12, BLOCK:13 };
const C = { 
    WATER:'#050505', GRASS:'#2e7d32', FOREST:'#1b5e20', SAND:'#f9e79f', 
    RUINS:'#616161', SWAMP:'#3e2723', SNOW:'#b0bec5', 
    LAVA:'#3e2723', VOID:'#1a0b2e', ROAD:'#78909c', BRIDGE:'#5d4037', 
    LOCK:'#c0392b', BEDROCK:'#111', BLOCK:'#000'
};

const CLASSES = {
    // WARRIOR: Tanky (HP 500), Heavy (Speed 0.12)
    warrior: { hp:500, spd:0.12, color:'#2196f3', skills:['Slash','Bash','War Stomp','Rally','Quake', 'Tornado'] },
    // MAGE: Fragile (HP 280), Kiter (Speed 0.13)
    mage:    { hp:280, spd:0.13, color:'#9c27b0', skills:['Inferno','Glacial Spike','Thunderstorm','Heal','AbyssalGrasp', 'Starfall'] },
    // ROGUE: Fast (Speed 0.15), Evasive
    rogue:   { hp:350, spd:0.15, color:'#ffb300', skills:['Shoot','PoisonCloud','Trap','Rush','ArrowStorm', 'FairyBombs'] }
};

const SKILLS = {
    // --- WARRIOR ---
    'Slash':     { k:'Z', cd:400,  icon:'‚öîÔ∏è', dmg:30, range:3.5, vfx:'slash', scale:1.0 }, // Standard Hit
    'Bash':      { k:'X', cd:4000, icon:'üõ°Ô∏è', dmg:80, range:3, stun:2000, knock:4.0, vfx:'bash', scale:1.5 }, // Strong Single Hit
    'War Stomp': { k:'C', cd:5000, icon:'‚ò¢Ô∏è', dmg:120, range:5.0, knock:3.0, stomp:true, scale:1.2 }, // Reduced Range/Knock
    'Rally':     { k:'V', cd:12000, icon:'‚ù§Ô∏è', heal:200 },
    'Quake':     { k:'B', cd:15000, icon:'üåã', dmg:220, range:10, stun:3000, ult:true, quake:true, scale:2.0 },
   // WARRIOR N: TORNADO (Buffed: 15 -> 28)
    // Strong enough to wipe a wave of mobs, but won't instant-kill a boss.
    // WARRIOR N: TORNADO (Buffed: 15 -> 45 damage per tick)
    'Tornado': { k:'N', cd:6000, icon:'üåÄ', dmg:45, range:12, tornado:true, locked:true, count:5, scale:0.15 },

    // MAGE N: STARFALL (Buffed: 8 -> 25 damage per star)
    // With 100 stars, this deals massive total damage now.
    'Starfall': { k:'N', cd:10000, icon:'‚ú®', dmg:25, range:9, type:'stars', count:100, locked:true, scale:0.05 },

    // --- MAGE ---
    'Inferno':       { k:'Z', cd:1200, icon:'üî•', proj:true, dmg:25, spd:0.8, color:'#ff5722', burn:3000, count:5, spread:0.4, inferno:true, scale:0.25 }, // 5 hits
    'Glacial Spike': { k:'X', cd:6000, icon:'‚ùÑÔ∏è', dmg:100, range:8.0, freeze:2500, spike:true, scale:1.5 }, // CD > Freeze
    'Thunderstorm':  { k:'C', cd:7000, icon:'‚ö°', dmg:120, range:9, stun:800, storm:true, scale:1.5 }, // Short stun
    'Heal':          { k:'V', cd:12000, icon:'üíö', heal:150 },
    'AbyssalGrasp':  { k:'B', cd:7000, icon:'üñêÔ∏è', dmg:300, range:9, ult:true, grasp:true, scale:2.0 },
   // MAGE N: STARFALL (Buffed: 8 -> 25 damage per star)
    // With 100 stars, this deals massive total damage now.
    'Starfall': { k:'N', cd:10000, icon:'‚ú®', dmg:32, range:9, type:'stars', count:150, locked:true, scale:0.17 },

    // --- RANGER ---
    // Scale 0.06 keeps the damage balanced (15 hits x low dmg)
'Shoot':      { k:'Z', cd:500,  icon:'üèπ', dmg:12, range:10, arrow:true, scale:0.06 },
    'PoisonCloud': { k:'X', cd:6000, icon:'‚ò†Ô∏è', dmg:5, range:8, poison:200, type:'zone', scale:0.1 }, // Dmg is in the poison
    'Trap':        { k:'C', cd:10000, icon:'üï∏Ô∏è', dmg:50, range:6, type:'web', stun:3000, scale:1.0 }, // Strong stun, Long CD
    'Rush':        { k:'V', cd:10000, icon:'üëü', speed:true },
    'ArrowStorm':  { k:'B', cd:15000, icon:'üåßÔ∏è', dmg:40, range:16, count:30, ult:true, type:'arrowRain', scale:0.5 },
    'FairyBombs':  { k:'N', cd:5000, icon:'üßö', dmg:35, range:12, locked:true, type:'fairy', scale:0.3 }
};



const QUESTS = [
    { type:'talk', txt: "Talk to Elder Man (Village)", target: "Elder Man", id:0 },
    { type:'kill', txt: "Defeat Slime King (Grass)", target: "Slime King", lock:0 }, 
    { type:'collect', txt: "Gather 3 Herbs (Forest)", target: "Medic Herb", count:3, lock:1 },
    { type:'kill', txt: "Slay Scorpion King (Sand)", target: "Scorpion King", lock:2 },
    { type:'activate', txt: "Read 3 Slogans (Ruins)", target: "Tablet", count:3, lock:3 },
    // Make sure it says "Hydra"
{ type:'kill', txt: "Slay the Hydra (Swamp)", target: "Hydra", lock:4 }, 
    { type:'activate', txt: "Free 3 Frozen Friends (Snow)", target: "Frozen Friend", count:3, lock:5 },
    { type:'kill', txt: "Slay Red Dragon (Lava)", target: "Red Dragon", lock:6 }, 
    { type:'kill', txt: "Defeat Chaos Titan", target: "Chaos Titan" }
];

let S = {
    gameOver: false, // New flag
    run: false, map: [], cam: {x:0, y:0}, shake:0,
    p: { x:0, y:0, hp:100, maxHp:100, xp:0, lvl:1, cds:{}, buffs:{}, dir:2, killLog:[], actLog:{} },
    ents: [], parts: [], lighting: [], shockwaves:[], vfxs:[], qStep: 0, qProg:0, locks: [],
    wordData: [], 
    input: { keys:{} },
    world: "main",
    unlockedRegion9: false,
    farm: {
        day: 1, money: 5000, houseLevel: 1, fieldLevel: 1, 
        time: 360, water: 30,
        
        // These are the "Pockets" the farm needs:
        plots: {}, debris: {}, fences: {}, structures: {}, letterData: {},
        
        inventory: { 
            carrot_seeds: 5, wood: 0, stake: 0, fish: 0, 
            carrot: 0, potato: 0, corn: 0, tomato: 0,
            rose: 0, sunflower: 0, tulip: 0, lavender: 0,
            brick: 0
        },
        storage: { wood: 0, stake: 0, fish: 0 },
        tools: { hoe: 1, sickle: 1, axe: 1, hammer: 1, water: 1, rod: 1 },
        toolNames: ['Hand','Hoe','Hammer','Axe','Sickle','Water','Rod',''], 
        toolIcons: ['‚úã','‚õèÔ∏è','üî®','ü™ì','‚úÇÔ∏è','üöø','üé£',''],
        keyMap:    ['1','2','3','4','Q','W','E','R'],
        toolIndex: 0
    }
};




// --- SYSTEM MENU LOGIC ---
S.paused = false; 

function togglePauseMenu() {
    S.paused = !S.paused;
    const menu = document.getElementById('pause-menu');
    menu.style.display = S.paused ? 'flex' : 'none';
    
    if(S.paused) {
        AudioSys.play('bag');
        GameMenuNav.reset(); // Reset selection to top
    } else {
        AudioSys.play('btn_click');
    }
}

// --- SAVE SYSTEM LOGIC ---



function saveGame(slotId) {
    try {
        // 1. FILTER ENTITIES
        // We only save "Real" things.
        let persistentEnts = S.ents.filter(e => {
            // Keep these types:
            const keep = [
                'mob', 'npc', 'struct', 'item', 'obj', 'pet', 
                'chicken', 'cow', 'horse', 'farm_mob', 'struct_item',
                'env', // <--- FIX: Trees, Flowers, Cactus
                'obs'  // <--- FIX: Boulders, Stumps
            ];
            
            // Discard 'proj', 'zone', 'tornado', 'shadow_hand', etc.
            return keep.includes(e.type) && !e.dead; 
        });

        // 2. CONSTRUCT THE SNAPSHOT
        let payload = {
            // A. The Map (Crucial: Convert Uint8Array to normal Array for JSON)
            mapData: Array.from(S.map), 
            
            // B. The World State
            p: S.p,
            ents: persistentEnts,
            farm: S.farm,         // This includes inventory, plots, and 'generated' flag
            locks: S.locks,       // Remember which gates are open
            wordData: S.wordData, // The text blocks on the floor
            
            // C. The Story Flags
            qStep: S.qStep,
            qProg: S.qProg,
            unlockedRegion9: S.unlockedRegion9,
            bossDead: S.bossDead,
            world: S.world,       // Remember if we are in 'farm' or 'main'
            
            // D. Meta Data (For the "Load Game" menu later)
            meta: {
                date: new Date().toLocaleString(),
                class: S.p.class,
                lvl: S.p.lvl,
                day: S.farm.day
            }
        };

        // 3. WRITE TO BROWSER STORAGE
        localStorage.setItem(slotId, JSON.stringify(payload));

        // 4. FEEDBACK
        S.audio.play('save'); 
        popText(S.p.x, S.p.y, "GAME SAVED", "#0f0");
        
        // (Optional) Update the "Load Game" menu visuals immediately if we were on that screen
        // renderSaveSlots(); 

    } catch (err) {
        console.error("Save Failed:", err);
        popText(S.p.x, S.p.y, "SAVE ERROR", "#f00");
    }
}











// --- LOAD SYSTEM LOGIC ---

function loadGame(slotId) {
    try {
        // 1. SET ACTIVE SLOT (Important: Remember which button was clicked)
        S.curSlot = slotId;

        // 2. GET RAW DATA
        const raw = localStorage.getItem(slotId);

        // --- NEW LOGIC: IF EMPTY, START NEW GAME ---
        if (!raw) {
            console.log("Slot is empty. Starting new game on " + slotId);
            // Go to Class Selection
            Menu.goto('classes'); 
            return; // Stop loading, start creating
        }
        // -------------------------------------------

        
        const data = JSON.parse(raw);

        // 2. INIT ENGINE (Audio, Inputs - Shared Setup)
        // We use the function created in Step 1 to prepare the engine
        initSharedState();

        // 3. INJECT SAVED DATA (Overwriting default state)
        
        // A. REHYDRATE MAP (Fixes "Water/Void" bug)
        // We convert the saved array back into the format the game engine reads (Uint8Array)
        S.map = new Uint8Array(data.mapData);

        // B. RESTORE ENTITIES (Fixes "Regenerating Mobs/Bosses")
        // We load exactly who was alive. If Slime King isn't here, he stays dead.
        S.ents = data.ents;

        // C. RESTORE PLAYER & FARM
        S.p = data.p;
        S.farm = data.farm; // Includes inventory, day, money, AND the 'generated' flag
        
        // D. RESTORE FLAGS (Fixes "Closed Gates" and "Missing Bridge")
        S.locks = data.locks;
        S.wordData = data.wordData;
        S.qStep = data.qStep;
        S.qProg = data.qProg;
        S.unlockedRegion9 = data.unlockedRegion9;
        S.bossDead = data.bossDead;
        S.world = data.world; // Remember if we were in 'farm' or 'main'

        // 4. RESTORE RUNTIME LINKS (The "Glue")
        
        // A. Re-connect Farm System
        // We pass the LOADED state to the farm engine. 
        // Because S.farm.generated is true in the save, it WON'T spawn new trees!
        if(typeof Region9Farm !== 'undefined') Region9Farm.init(S);

        // B. Update UI & Hotkeys (Fixes "Broken Hotkeys")
        // This function checks S.world and turns on the correct interface
        updateUI(); 

        // C. Redraw Minimap (Fixes "Blank Map")
        drawStyledMinimap();

        // 5. START THE GAME LOOP (Bypassing genMap!)
        document.getElementById('main-menu').style.display = 'none';
        
        // Play correct music
        let bgm = (S.world === 'farm') ? 'farm_day' : (S.bossDead ? 'adventure_new' : 'adventure');
        S.audio.playBGM(bgm);

        S.run = true;
        loop();

        console.log("Save Loaded Successfully.");

    } catch (err) {
        console.error("Load Failed:", err);
        // REPLACED ALERT WITH CONSOLE LOG (So the game doesn't freeze)
        if(typeof AudioSys !== 'undefined') AudioSys.play('error');
        console.log("Failed to load save file. Data might be corrupted.");
    }
}








function triggerSaveUI() {
    // 1. Hide Pause Menu
    document.getElementById('pause-menu').style.display = 'none';
    
    // 2. Show Save Menu
    document.getElementById('save-menu').style.display = 'flex';
    GameMenuNav.reset(); // Reset selection to top
    
    // 3. Update Slot Text
    for(let i=1; i<=3; i++) {
        let raw = localStorage.getItem('rpg_save_slot_' + i);
        let txt = "Empty File";
        if(raw) {
            try {
                let d = JSON.parse(raw);
                txt = `${(d.meta.class||'?').toUpperCase()} Lv.${d.meta.lvl} (Day ${d.meta.day})`;
            } catch(e) { txt = "Corrupted"; }
        }
        document.getElementById('save-info-' + i).innerText = txt;
        
        // Highlight active slot
        let color = (S.curSlot === 'rpg_save_slot_' + i) ? '#ffd700' : '#888';
        document.getElementById('save-info-' + i).style.color = color;
    }
}

function finalSave(slotId) {
    saveGame(slotId);
    S.curSlot = slotId;
    document.getElementById('save-menu').style.display = 'none';
    S.paused = false; 
}







// --- NEW CONFIRMATION SYSTEM ---
// --- IN-GAME MENU NAVIGATION (Pause & Save) ---
const GameMenuNav = {
    selIdx: 0,
    
    // Call this when opening a menu to reset selection
    reset: function() {
        this.selIdx = 0;
        this.update();
    },







   handleInput: function(key, menuId) {
        const menu = document.getElementById(menuId);
        if(!menu) return;

        // Get all clickable buttons in this menu
        const btns = Array.from(menu.querySelectorAll('.m-btn, .quit-btn, .save-slot'));
        const visibleBtns = btns.filter(b => b.style.display !== 'none' && b.offsetParent !== null);
        
        if(visibleBtns.length === 0) return;

        // 1. CLICK ACTION
        if(key === ' ' || key === 'enter') {
            if(visibleBtns[this.selIdx]) visibleBtns[this.selIdx].click();
            return;
        }

        // 2. SPATIAL NAVIGATION (Grid Logic)
        const cur = visibleBtns[this.selIdx] || visibleBtns[0];
        const r1 = cur.getBoundingClientRect();
        const c1 = { x: r1.left + r1.width/2, y: r1.top + r1.height/2 };

        let best = null, minDist = Infinity;

        visibleBtns.forEach((t, i) => {
            if(i === this.selIdx) return;
            const r2 = t.getBoundingClientRect();
            const c2 = { x: r2.left + r2.width/2, y: r2.top + r2.height/2 };
            
            const dx = c2.x - c1.x; 
            const dy = c2.y - c1.y; 

            let isValid = false;
            let weightedDist = Infinity;

            // WEIGHTED LOGIC: Heavily penalize moving in the wrong axis
            if(key === 'arrowdown' && dy > 10) { 
                isValid = true;
                weightedDist = Math.abs(dy) + (Math.abs(dx) * 10); 
            }
            if(key === 'arrowup' && dy < -10) { 
                isValid = true;
                weightedDist = Math.abs(dy) + (Math.abs(dx) * 10);
            }
            if(key === 'arrowright' && dx > 10) { 
                isValid = true;
                weightedDist = Math.abs(dx) + (Math.abs(dy) * 10);
            }
            if(key === 'arrowleft' && dx < -10) { 
                isValid = true;
                weightedDist = Math.abs(dx) + (Math.abs(dy) * 10);
            }

            if(isValid && weightedDist < minDist) { 
                minDist = weightedDist; 
                best = i; 
            }
        });

        // 3. APPLY MOVEMENT
        if(best !== null) {
            this.selIdx = best;
            if(typeof AudioSys !== 'undefined') AudioSys.play('menu_scroll');
            this.update(visibleBtns);
        }
    },








    update: function(btns) {
        // Clear global selections inside menus
        document.querySelectorAll('.m-btn.selected, .quit-btn.selected, .save-slot.selected').forEach(el => el.classList.remove('selected'));
        
        if(!btns) {
            // Auto-detect if buttons aren't provided
            const openMenu = document.getElementById('pause-menu').style.display !== 'none' ? document.getElementById('pause-menu') :
                             document.getElementById('save-menu').style.display !== 'none' ? document.getElementById('save-menu') : null;
            if(!openMenu) return;
            btns = Array.from(openMenu.querySelectorAll('.m-btn, .quit-btn, .save-slot'));
            btns = btns.filter(b => b.style.display !== 'none' && b.offsetParent !== null);
        }

        if(btns[this.selIdx]) btns[this.selIdx].classList.add('selected');
    }
};

// --- NEW CONFIRMATION SYSTEM ---
const ConfirmBox = {


    targetSlot: null,
    targetTextId: null,
    selection: 1, // 0=Yes, 1=No (Default to No for safety)

    // Open the custom window
    open: function(slotId, textId) {
        this.targetSlot = slotId;
        this.targetTextId = textId;
        this.selection = 1; // Default to "No"
        
        document.getElementById('confirm-modal').style.display = 'flex';
        if(typeof AudioSys !== 'undefined') AudioSys.play('error'); // Alert sound
        this.updateVisuals();
    },

    // Handle the Yes/No decision
    resolve: function(result) {
        document.getElementById('confirm-modal').style.display = 'none';
        
        if(result) {
            // --- PERFORM DELETE ---
            // --- PERFORM DELETE ---
            localStorage.removeItem(this.targetSlot);
            // Changed from 'break' to 'btn_click' (Soft sound)
            if(typeof AudioSys !== 'undefined') AudioSys.play('btn_click'); 

            // Refresh UI based on where we are

            // Refresh UI based on where we are
            if (typeof Menu !== 'undefined' && document.getElementById('page-load').classList.contains('active')) {
                Menu.updateSlots();
            } else {
                let el = document.getElementById(this.targetTextId);
                if(el) { el.innerText = "Empty File"; el.style.color = "#888"; }
            }
        }
    },

    // Keyboard Input for the Modal
    handleInput: function(key) {
        if(key === 'arrowleft' || key === 'arrowright') {
            this.selection = (this.selection === 0) ? 1 : 0;
            if(typeof AudioSys !== 'undefined') AudioSys.play('menu_scroll');
            this.updateVisuals();
        }
        if(key === ' ' || key === 'enter') {
            this.resolve(this.selection === 0);
        }
        if(key === 'escape') {
            this.resolve(false);
        }
    },

    // Mouse Hover support
    hover: function(idx) {
        this.selection = idx;
        this.updateVisuals();
    },

    // Update Red/Grey colors
    updateVisuals: function() {
        const yes = document.getElementById('conf-yes');
        const no = document.getElementById('conf-no');
        
        yes.classList.remove('selected');
        no.classList.remove('selected');

        if(this.selection === 0) yes.classList.add('selected');
        else no.classList.add('selected');
    }
};

// --- NEW WRAPPER FUNCTION ---
function deleteSlot(slotId, textId) {
    // Instead of browser popup, open our custom ConfirmBox
    ConfirmBox.open(slotId, textId);
}








function closeSaveMenu() {
    document.getElementById('save-menu').style.display = 'none';
    document.getElementById('pause-menu').style.display = 'flex';
}











// --- INITIALIZE FARM SYSTEM ---
// The FarmSystem class is defined in farm.js
let farmSys = null;






try {
    farmSys = new FarmSystem(S);
} catch(e) { console.log("FarmSystem not loaded yet. Waiting for farm.js..."); }



window.onkeydown = e => {
    const k = e.key.toLowerCase();

    // --- 00. GLOBAL MODAL PRIORITY ---
    if(document.getElementById('confirm-modal').style.display === 'flex') {
        e.preventDefault();
        ConfirmBox.handleInput(k);
        return;
    }

    // --- 0. MAIN MENU NAVIGATION ---
    if(document.getElementById('main-menu').style.display !== 'none') {
        if(typeof Menu !== 'undefined') Menu.handleInput(e);
        return;
    }

    // --- A. WIN SCREEN ---
    if(document.getElementById('win-screen').style.display === 'flex') {
        if(k === ' ' || k === 'enter') document.getElementById('btn-win').click();
        return;
    }

    // --- B. DEATH SCREEN ---
    if(document.getElementById('death-screen').style.display === 'flex') {
        if(k === ' ' || k === 'enter') document.getElementById('btn-die').click();
        return;
    }

    // --- C. PAUSE MENU ---
    if(document.getElementById('pause-menu').style.display === 'flex') {
        if(k === 's' || k === 'escape') { togglePauseMenu(); return; }
        e.preventDefault(); // Stop walking while in menu
        GameMenuNav.handleInput(k, 'pause-menu');
        return;
    }

    // --- D. SAVE MENU ---
    if(document.getElementById('save-menu').style.display === 'flex') {
        if(k === 'escape') { closeSaveMenu(); return; }
        e.preventDefault();
        GameMenuNav.handleInput(k, 'save-menu');
        return;
    }

    // 1. [S] KEY (Global)
    if(e.key.toLowerCase() === 's') {
        togglePauseMenu();
        return;
    }
    // 2. PAUSE CHECK (Stop everything else if menu is open)
    if(S.paused) {
        if(e.key === 'Escape') togglePauseMenu();
        return;
    }

// --- PASTE THIS ---
    if (S.world === 'farm') {




        Region9Farm.handleInput(e);
        return; // Don't do RPG combat stuff
    }
    // ------------------

    S.input.keys[e.key.toLowerCase()] = true;
    
    if(e.code==='Space') {
        if (S.world === 'main') interact();
        // Delegate to Farm Module
        else if (S.world === 'farm' && farmSys) farmSys.handleInput(e);
    }

    if (S.world === 'main') {
        if(['z','x','c','v','b','n'].includes(e.key.toLowerCase())) cast(e.key.toLowerCase());
    }

    // Delegate Tool Selection / Menu hotkeys to Farm Module
    if (S.world === 'farm' && farmSys) {
        farmSys.handleInput(e);
    }
};
window.onkeyup = e => S.input.keys[e.key.toLowerCase()] = false;

// MANDATORY FIX: Stop moving if window loses focus
window.addEventListener('blur', () => { S.input.keys = {}; });

// 1. SHARED SETUP (Runs for New Game AND Load Game)
// 1. SHARED SETUP (Runs for New Game AND Load Game)
// 1. SHARED SETUP (Runs for New Game AND Load Game)
function initSharedState() {
    S.gameOver = false;
    S.paused = false;
    S.input.keys = {};
    
    // DEFAULT SLOT: Removed to prevent overwriting Slot 1 on New Game.
    // S.curSlot is now explicitly managed in startNewGame (null) or loadGame (set).

    // Link Audio System
    S.audio = AudioSys;




    // Initialize Farm System if needed
    if(!farmSys && typeof FarmSystem !== 'undefined') farmSys = new FarmSystem(S);
}

// 2. START NEW GAME (Runs ONLY when clicking "Start New Game")
// 2. START NEW GAME (Runs ONLY when clicking "Start New Game")
// 2. START NEW GAME (Runs ONLY when clicking "Start New Game")
function startNewGame(cls) {
    // A. Visuals & Audio
    AudioSys.play('class_choose');
    
    // B. Run Shared Setup
    initSharedState();

    // C. Reset Player & World (The "Wipe")
    S.curSlot = null; // <--- IMPORTANT: Unbound Save State (Prevents accidental overwrite)
    S.p.class = cls;
    S.p.xp = 0; S.p.lvl = 1; S.p.killLog = []; S.p.actLog = {};
    S.p.cds = {}; S.p.buffs = {};
    
     S.unlockedRegion9 = false; 
    S.bossDead = false;
    S.epilogueSeen = false; // <--- ADD THIS LINE HERE
    S.farm.generated = false;

    // Apply Class Stats
    Object.assign(S.p, CLASSES[cls]);
    S.p.maxHp = CLASSES[cls].hp; S.p.hp = S.p.maxHp;

    // D. GENERATE WORLD (This is what we SKIP when loading!)
    S.audio.playBGM('adventure');
    genMap(); 
    
    // E. Start Loop
    updateUI(); 
    
    // (Testing code removed: Bridge is now hidden by default)

    document.getElementById('main-menu').style.display='none';
    showChat("Noah", "Hey! Welcome. Talk to Elder Man!", true);
    S.run = true; 
    loop();
}



function unlockRegion9() {
    if (S.unlockedRegion9) return;
    S.unlockedRegion9 = true;

    // 1. Ëµ∑ÈªûÔºö‰øùÊåÅË∑ü Region 7‚Üí8 Âêå‰∏ÄÊ¢ùÊ∞¥Âπ≥Á∑öÔºà‰∏≠ÂøÉ y=125Ôºâ
    const startX = 85;
    const startYTop = 124;   // Ë∑ØÁöÑ„ÄåÊúÄ‰∏äÈù¢ÈÇ£Ê†º„ÄçÔºå‰∏âÊ†ºÈ´ò ‚áí ‰∏≠ÂøÉÂú® 125

    // 2. ÁµÇÈªûÔºöË¶ÅÊé•Âà∞ Region 9 ÁâÜÈôÑËøëÔºå‰ΩÜÂÖ•Âè£‰∏≠ÂøÉË¶ÅÂú®„ÄåÈ†ÇÁâÜ‰∏ã 15 Ê†º„Äç
    //    Region 9 È†ÇÁâÜÂú® y = 120 ‚áí 120 + 15 = 135
    const endX      = 120;
    const endYTop   = 134;   // ‰∏âÊ†ºÈ´òÔºö134,135,136 ‚áí ‰∏≠ÂøÉ 135

    const steps = endX - startX;          // 35
    const dyTop  = endYTop - startYTop;   // 134 - 124 = 10

    // 3. Áï´‰∏ÄÊ¢ù 3 Ê†ºÂéöÁöÑÊ©ãÔºåÂæû (85,124~126) ÊñúËµ∞Âà∞ (120,134~136)
    for (let i = 0; i <= steps; i++) {
        const x = startX + i;

        // Á∑©ÊÖ¢Âêë‰∏ãÔºö‰æù x Á∑öÊÄßË£úÈñì yÔºàÊúÄ‰∏äÈù¢ÈÇ£Ê†ºÔºâ
        const yTop = startYTop + Math.floor(dyTop * i / steps);

        for (let w = 0; w < 5; w++) {
            const y = yTop + w;                       // ‰∏âÊ†ºÈ´ò
            if (y < 0 || y >= MAP_S) continue;

            const idx = y * MAP_S + x;
        S.map[idx] = T.BRIDGE;
    }
}

// REFRESH THE FAKE MAP
    drawStyledMinimap();






    showChat("SYSTEM", "The Chaos Titan falls... A bridge to a new land appears!");
    popText(S.p.x, S.p.y, "REGION 9 UNLOCKED", "#2ecc71");

    // (Minimap reveal removed)
}


function updateUI() {
    // --- 1. FARM MODE ---
    // Only show Farm UI if we are actually inside the gate (x > 118)
    if(S.world === 'farm' && S.p.x > 118) {
        
        // A. CLEAR STUCK STYLES
        let bar = document.getElementById('skill-bar');
        if(bar) {
            bar.style.display = ''; 
            bar.style.gridTemplateColumns = ''; 
            bar.style.gridTemplateRows = '';
            bar.style.top = ''; 
            bar.style.left = '';
        }

        // B. VISIBILITY: HIDE RPG UI, SHOW FARM UI
        
        // 1. Hide the RPG Top HUD (HP, EXP, Level, RPG Minimap)
        let rpgHud = document.getElementById('hud-top');
        if(rpgHud) rpgHud.style.display = 'none';

        // 2. Hide Quest Box
        let quest = document.getElementById('quest-panel');
        if(quest) quest.style.display = 'none';

        // 3. Show Farm Day/Money Stats (REMOVED: Now drawn on Canvas)
        // (Old code for 'farm-stats' was deleted here to prevent crash)

        // C. Enable Farm CSS & Layers
        let fs = document.getElementById('farm-styles');
        if(fs) fs.disabled = false;

               
        // Show Farm Hints (Space/Hand)
        ['space-hint', 'screen-hint'].forEach(id => {
            let el = document.getElementById(id);
            if(el) el.style.display = 'flex';
        });

        // D. Update Content
        if(typeof Region9Farm !== 'undefined' && Region9Farm.updateFarmUI) {
            Region9Farm.updateFarmUI();
        } 
        else if(farmSys) {
            farmSys.updateFarmUI();
        }
        return;
    }

    // --- 2. MAIN WORLD MODE ---
    
    // A. VISIBILITY: SHOW RPG UI
    
    // 1. Show RPG Top HUD (HP, EXP, Level)
    let rpgHud = document.getElementById('hud-top');
    if(rpgHud) rpgHud.style.display = 'flex'; 

    // 2. Show Quest Box
   // 2. Show Quest Box & Reset Title
    let quest = document.getElementById('quest-panel');
    if(quest) {
        quest.style.display = 'block';
        // FORCE THE TITLE BACK TO RPG MODE
        if(quest.children[0]) quest.children[0].innerText = "CURRENT MISSION"; 
        quest.children[1].style.color = "#eee"; // Reset color to white
    }

    // 3. Hide Farm UI
    // [CRASH FIX]: We deleted the specific line that tried to hide 'farm-stats'
    
    
    // Hide Farm Hints
    ['space-hint', 'screen-hint'].forEach(id => {
        let el = document.getElementById(id);
        if(el) el.style.display = 'none';
    });

    // Disable Farm CSS
    let fs = document.getElementById('farm-styles');
    if(fs) fs.disabled = true;

    // --- 3. REBUILD SKILL BAR (RPG Style) ---
    let barEl = document.getElementById('skill-bar'); 
    barEl.innerHTML='';
    
    // Force Horizontal Layout
    barEl.style.display = 'flex'; 
    barEl.style.gridTemplateColumns = 'none'; 
    barEl.style.gridTemplateRows = 'none';

    CLASSES[S.p.class].skills.forEach(s => {
        let d=SKILLS[s];
        let border = d.ult ? 'border-color:#f0f;' : '';
        let isLocked = d.locked && S.qStep <= 4; 
        let lockClass = isLocked ? 'locked' : '';
        barEl.innerHTML += `<div class="slot ${lockClass}" style="${border}">
            <span class="key-hint">${d.k}</span>
            <div class="icon">${d.icon}</div>
            <div class="cd" id="cd-${s}"></div>
        </div>`;
    });
}

function addNPC(name, x, y, txt, gender, qId) { 
    S.ents.push({
        type:'npc', name, txt, x, y, gender, qId, h:1.5, 
        moveTimer: Math.random()*120, isWalking: false, moveDir: 0
    }); 
}

function genMap() {
    S.map = new Uint8Array(MAP_S * MAP_S).fill(T.WATER);
    S.ents = []; S.locks = []; S.p.killLog = []; S.p.actLog = {};
    S.wordData = []; 
    S.qStep = 0; S.qProg = 0;

    let zones = [
        { x:25, y:25, t:T.GRASS, r:20 }, { x:75, y:25, t:T.FOREST, r:18 },
        { x:125, y:25, t:T.SAND, r:18 }, { x:125, y:75, t:T.RUINS, r:18 },
        { x:75, y:75, t:T.SWAMP, r:18 }, { x:25, y:75, t:T.SNOW, r:18 },
        { x:25, y:125, t:T.LAVA, r:18 }, { x:75, y:125, t:T.VOID, r:18 }
    ];

    zones.forEach(z => {
        for(let y=z.y-z.r; y<=z.y+z.r; y++) for(let x=z.x-z.r; x<=z.x+z.r; x++) {
            if(x<0||y<0||x>=MAP_S||y>=MAP_S) continue;
            let d = Math.hypot(x-z.x, y-z.y);
            if(d < z.r) {
                S.map[y*MAP_S+x] = z.t;
                if(d > z.r - 2) S.map[y*MAP_S+x] = T.BEDROCK; 
            }
        }
    });

    for(let i=-8; i<=8; i++) {
        S.map[25*MAP_S + (25+i)] = T.ROAD; 
        S.map[(25+i)*MAP_S + 25] = T.ROAD; 
    }
    
    

    addBlockWords(18, 33, "THE TUCK SHOP", "gold"); 
    addBlockWords(45, 27, "STUDIO CLASSROOM", "red"); 
    addBlockWords(92, 27, "LET'S TALK IN ENGLISH", "blue");
    addBlockWords(88, 73, "HEAVENLY MELODY", "purple");
    addBlockWords(42, 77, "A FRIEND FOR LIFE", "green");
    addBlockWords(40, 122, "STUDIO CLASSROOM", "gold");

    zones.forEach(z => { if(z.t !== T.GRASS) addEnt('struct', 'Healing Crystal', z.x-5, z.y+5); });
    addEnt('struct', 'TuckShop', 18, 28); 
    addEnt('struct', 'Fountain', 24, 24); 
    addEnt('struct', 'House', 16, 18); addEnt('struct', 'Church', 32, 18);
    addEnt('struct', 'House', 32, 28);
    
    for(let i=0; i<zones.length-1; i++) connect(zones[i], zones[i+1], i);

    // 1. Draw the New Stylized Map
    drawStyledMinimap();

    // 2. Spawn Mobs & Nature (Logic Only, No Drawing)
    for(let y=0; y<MAP_S; y++) for(let x=0; x<MAP_S; x++) {
        let t = S.map[y*MAP_S+x];
        
        // Skip map drawing here, just do spawns
        if([T.WATER, T.ROAD, T.BRIDGE, T.LOCK, T.BEDROCK, T.BLOCK].includes(t)) continue;
        if(Math.abs(x - 25) < 3 && Math.abs(y - 35) < 3) continue;
        // Skip Farm Area for spawns
        if(x > 115 && y > 115) continue;

        if(solid(x, y, null)) continue; 
        
        if(Math.random() < 0.1) addEnt('env', getEnv(t), x, y);
        
        if(Math.random() < 0.025) { 
            let distFromSpawn = Math.hypot(x - 25, y - 32); 
            if(distFromSpawn > 8) { 
                let mobType = getMob(t); 
                if(mobType) addMob(mobType, x, y);
            }
        }
    }

    addObj("Tablet", 120, 70, "Let's Talk in English"); 
    addObj("Tablet", 130, 80, "Studio Classroom"); 
    addObj("Tablet", 125, 75, "Heavenly Melody");

    addMob("Slime King", 25, 35, true); 
    addMob("Scorpion King", 125, 25, true);
    addMob("Hydra", 75, 75, true); 
    addMob("Red Dragon", 25, 125, true);
    addMob("Chaos Titan", 75, 125, true);

    for(let i=0; i<6; i++) addItem("Medic Herb", 70+(Math.random()*10), 20+(Math.random()*10));

    addObj("Frozen Friend", 20, 70, "You saved a friend!"); 
    addObj("Frozen Friend", 30, 80, "Brrr... thanks!"); 
    addObj("Frozen Friend", 25, 75, "Friend for life!");

    addNPC("Elder Man", 24, 21, "Ah, a new hero. Our world is full of messages...", 'M', 0);
    addNPC("Simon", 20, 32, "Suce ma bite, I have the best restaurant in Margaret River.", 'M');
    addNPC("David", 28, 20, "Now I‚Äôm the only David at ORTV.", 'M', -1);
    addNPC("Grace", 28, 26, "‚ÄúHow abundant are the good things that you have stored up.‚Äù ‚Äî Psalm 31:19 (NIV)", 'F');
    addNPC("Fu Jing", 30, 20, "Busy, busy‚Äîbut let‚Äôs hang out sometime.", 'M'); 
    addNPC("Steve", 44, 25, "Hi, mate. I'm the best Chef in Port Douglas.", 'M');
    addNPC("Pam", 46, 25, "‚ÄúBelieve in the Lord Jesus, and you will be saved‚Äîyou and your household.‚Äù ‚Äî Acts 16:31 (NIV)", 'F');
    addNPC("Nicolas", 50, 25, "Bonjour, mon ami ! Quel monde magnifique pour une aventure !", 'M');
    addNPC("Sukie", 38, 33, "‚ÄúEven though I walk through the darkest valley, I will fear no evil, for you are with me.‚Äù ‚Äî Psalm 23:4 (NIV)", 'F', 0);
    addNPC("Jack", 40, 28, "‚ÄúTrust in the Lord with all your heart‚Ä¶ and he will make your paths straight.‚Äù ‚Äî Proverbs 3:5‚Äì6 (NIV)", 'M');
    addNPC("John", 42, 28, "I'm Jack's brother.", 'M');
    addNPC("Daphne", 40, 30, "Piano is a beautiful art. Remember to eat something‚Äîdon‚Äôt go hungry.", 'F', -1);
    addNPC("Tomo Chiu", 72, 28, "I love the feeling of riding a scooter while traveling.", 'M');
    addNPC("Shummi", 78, 22, "‚ÄúSurely your goodness and love will follow me all the days of my life.‚Äù ‚Äî Psalm 23:6 (NIV)", 'F', -1);
    addNPC("Sharon", 115, 25, "‚ÄúHe leads me beside quiet waters.‚Äù ‚Äî Psalm 23:2 (NIV)", 'F');
    addNPC("Avon", 120, 30, "‚ÄúGod is our refuge and strength, an ever-present help in trouble.‚Äù ‚Äî Psalm 46:1 (NIV)", 'F', -1);
    addNPC("Fang", 125, 60, "I love classical music and detective novels.", 'M');
    addNPC("Angus", 125, 72, "Enjoy your life while you‚Äôre young.", 'M');
    addNPC("Bohan", 75, 70, "I wish I could fly like a bird.", 'M');
    addNPC("Pauline", 85, 75, "Josh, look! This is so fun‚Äîjust like Costa Rica.", 'F', -1);
    addNPC("Josh", 87, 75, "Lovely, Pauline! I‚Äôll take some photos for you.", 'M', -1);
    addNPC("A Gan", 35, 75, "I'm good at peeling oranges.", 'F');
    addNPC("Jussi", 28, 78, "Moi moi, this is nothing. Finland is warm.", 'M');
    addNPC("Mary", 25, 115, "Never regret‚ÄîGod has a plan for me, for you, for everyone.", 'F');
    addNPC("Mark", 28, 115, "Have you seen my adorable son, Levi?", 'M', -1);
    addNPC("Jingle", 22, 115, "Welcome to Singapore!", 'F');
    addNPC("Corni", 46, 125, "„Åì„Çì„Å´„Å°„ÅØ (konnichiwa)", 'M');
    addNPC("Bian Bain", 48, 125, "Do you know how to find Orion? Look for three bright stars in a line.", 'M');
    
    S.p.x = 25; S.p.y = 32;

// LOOK FOR THIS PART AT THE END OF genMap function:
    if (typeof Region9Farm !== 'undefined') {
        Region9Farm.init(S); // Send main game data to farm
    }
}





function connect(z1, z2, lockId) {
    let x = Math.floor(z1.x), y = Math.floor(z1.y);
    let tx = Math.floor(z2.x), ty = Math.floor(z2.y);
    let path = [];
    let steps = 0;
    while((x !== tx || y !== ty) && steps < 500) {
        if(x < tx) x++; else if(x > tx) x--;
        else if(y < ty) y++; else if(y > ty) y--;
        path.push({x,y});
        steps++;
    }
    let mid = path[Math.floor(path.length/2)];

    path.forEach(p => {
        for(let i=-1; i<=1; i++) for(let j=-1; j<=1; j++) {
            let idx = (p.y+j)*MAP_S+(p.x+i);
            S.map[idx] = T.BRIDGE;
        }
    });

    if(mid) {
        let isVert = Math.abs(path[0].y - path[path.length-1].y) > Math.abs(path[0].x - path[path.length-1].x);
        for(let i=-1; i<=1; i++) {
            let lx = mid.x + (isVert ? i : 0);
            let ly = mid.y + (isVert ? 0 : i);
            S.map[ly*MAP_S+lx] = T.LOCK;
            S.locks.push({x:lx, y:ly, id:lockId});
        }
    }
}

function getEnv(t) {
    let r = Math.random();
    if(t===T.GRASS) return r<.5 ? 'tree_g' : 'flower'; 
    if(t===T.FOREST) return r<.6 ? 'tree_f' : 'stump';
    if(t===T.RUINS) return r<.5 ? 'rubble' : 'column';
    if(t===T.SAND) return r<.5 ? 'cactus' : 'rock';
    if(t===T.SWAMP) return 'dead_tree';
    if(t===T.SNOW) return 'ice_crystal';
    if(t===T.VOID) return 'void_shard';
    return 'rock';
}

function getMob(t) {
    let r = Math.random();
    if(t===T.GRASS) return r<.5 ? 'Slime' : 'Goblin'; 
    if(t===T.FOREST) return r<.5 ? 'Boar' : 'Ent';
    if(t===T.SAND) return r<.5 ? 'Scorpion' : 'Mummy'; 
    if(t===T.RUINS) return r<.5 ? 'Skeleton' : 'Bat';
    if(t===T.SWAMP) return r<.5 ? 'Basilisk' : 'Mosquito'; 
    if(t===T.SNOW) return r<.5 ? 'Yeti' : 'Ice Spirit';
    if(t===T.LAVA) return r<.5 ? 'Magma' : 'Fire Imp'; 
    if(t===T.VOID) return r<.5 ? 'Stone Golem' : 'Cinder Wolf';
    return null;
}

function addEnt(type, kind, x, y) { 
    let w=1, h=1; 
    if(kind==='Fountain'){w=3;h=3;} 
    if(kind==='House'){w=4;h=4;}
    if(kind==='FarmHouse'){w=6;h=5;}
    if(kind==='TuckShop'){w=5;h=4;}
    if(kind==='Church'){w=5;h=6;}
    if(kind==='Healing Crystal'){w=2;h=2;}
    if(['tree_g','tree_f','column','cactus','dead_tree','ice_crystal','void_shard'].includes(kind)) h=1.5;
    S.ents.push({type, kind, x, y, w, h}); 
}
function addMob(name, x, y, boss=false) {
    let hp = 250, dmg = 15; 
    let w=1, h=1;
    if(boss) {
        dmg = 40; w=2; h=2;
        if(name==="Slime King") hp=1500; 
        else if(name==="Chaos Titan") { hp=20000; dmg=70; w=4; h=4; } 
        else hp=4000;
    } else {
        if(name==='Goblin') { hp=280; dmg=18; }
        if(name==='Ent') { hp=350; dmg=25; }
        if(name==='Mosquito') { hp=120; dmg=20; }
        if(['Magma','Fire Imp','Stone Golem','Cinder Wolf','Yeti','Ice Spirit'].includes(name)) { hp=650; dmg=35; }
    }
    S.ents.push({type:'mob', name, x, y, w, h, hp, maxHp:hp, dmg, boss, aggro:0, status:{}});
}

function addBlockWords(x, y, txt, theme) {
    for(let i=0; i<txt.length; i++) {
        let idx = y*MAP_S + (x+i);
        if(txt[i] !== ' ') {
            S.map[idx] = T.BLOCK; 
            S.wordData[idx] = { char:txt[i], theme }; 
        }
    }
}

function addItem(name, x, y) { S.ents.push({type:'item', name, x, y}); }
function addObj(name, x, y, msg) { 
    let size = (name==='Tablet' || name==='Frozen Friend') ? 2 : 1;
    S.ents.push({type:'obj', name, x, y, msg, active:false, w:size, h:size}); 
}

function loop() { if(S.run) { try{update(); draw();}catch(e){ console.error(e); } requestAnimationFrame(loop); } }





function update() {
    if(S.paused) return; // STOP GAME IF PAUSED
    const now = Date.now();
    const p = S.p;




    // --- 1. WORLD SWITCHING LOGIC ---

    // Trigger Farm Mode earlier (at x=108)
    let inFarmArea = (p.x > 108 && p.y > 118 && S.unlockedRegion9);

    if (inFarmArea) {
        // === ENTERING FARM ===
        if(S.world !== 'farm') {
            S.world = 'farm';
            
            if(typeof Region9Farm !== 'undefined') Region9Farm.init(S);

            let fs = document.getElementById('farm-styles');
            if(fs) fs.disabled = false; 

           updateUI();
            showChat("SYSTEM", "Entering Farm Mode");
            S.audio.play('tele');
            S.audio.playBGM('farm_day');
        }
   } else {
            // === RETURNING TO MAIN WORLD ===
            if(S.world === 'farm') {
                S.world = 'main';

                let fs = document.getElementById('farm-styles');
                if(fs) fs.disabled = true; 
                
                // [FIX] STOP RESETTING THE WORLD
                // We removed genMap(), so dead mobs stay dead and the map stays persistent.

                // 1. SAVE Y POSITION (To prevent jumping)
                let exitY = S.p.y;

                // 2. FIX POSITION
                p.x = 107;      // Place outside the trigger
                p.y = exitY;    // Keep vertical position



// --- REDRAW STYLIZED MAP ---
                drawStyledMinimap();
                // ---------------------------

                updateUI();
                showChat("SYSTEM", "Leaving Farm...");
                S.audio.play('tele');
                
                // Play NEW song if boss is dead, otherwise play OLD song
                S.audio.playBGM(S.bossDead ? 'adventure_new' : 'adventure');
            }
        }
        




    // --- 2. DELEGATE TO FARM ---
    if (S.world === 'farm') {
        
        // [NEW] DYNAMIC UI SWITCH (FIXED)
        // Check if we just crossed the gate line (118)
        // We now check 'farm-ui-layer' because 'farm-stats' was deleted
        let uiLayer = document.getElementById('farm-ui-layer');
        let isFarmUI = (uiLayer && uiLayer.style.display === 'block');
        let shouldBeFarmUI = (S.p.x > 118);

        // If the current UI doesn't match where we are standing, update it!
        if (isFarmUI !== shouldBeFarmUI) {
            updateUI();
        }

        if (farmSys) farmSys.update();
        else if (typeof Region9Farm !== 'undefined') Region9Farm.update();
        
        let timeIcon = document.getElementById('time-icon');
        if(timeIcon) timeIcon.innerText = (S.farm.time > 360 && S.farm.time < 1140) ? '‚òÄÔ∏è' : 'üåô';
        
        return; 
    }

    // --- 3. RPG MAIN WORLD LOGIC ---

    if(now%15 === 0) {
        let healer = S.ents.find(e => {
            if(e.kind !== 'Fountain' && e.kind !== 'Healing Crystal') return false;
            let cx = e.x + e.w/2; let cy = e.y + e.h/2;
            return Math.hypot(cx - (p.x+0.5), cy - (p.y+0.5)) < 4.0; 
        });

        if(healer) {
            if(p.hp < p.maxHp) {
                p.hp = Math.min(p.maxHp, p.hp + 15);
                if(now%15===0) part(p.x, p.y, 'pink', 1, 10, 'heal_txt');
            }
        }
    }

    let dx=0, dy=0;
    if(S.input.keys['arrowup']) dy=-1; if(S.input.keys['arrowdown']) dy=1;
    if(S.input.keys['arrowleft']) dx=-1; if(S.input.keys['arrowright']) dx=1;
    
    if(dx||dy) {
        let len = Math.hypot(dx,dy);
        let spd = p.buffs.speed > now ? p.spd*1.5 : p.spd; 
        dx=(dx/len)*spd; dy=(dy/len)*spd;
        let tx = p.x + dx; let ty = p.y + dy;
        
        if(!solid(tx+0.5, p.y+0.5)) p.x = tx;
        if(!solid(p.x+0.5, ty+0.5)) p.y = ty;
        
        p.x = Math.max(0, Math.min(MAP_S-1, p.x));
        p.y = Math.max(0, Math.min(MAP_S-1, p.y));

        if(dy<0) p.dir=0; if(dx>0) p.dir=1; if(dy>0) p.dir=2; if(dx<0) p.dir=3;



// AUDIO: Walking / Horse
        if(now % 25 === 0) S.audio.play(S.p.isRiding ? 'horse' : 'step');
    }



    

    if(S.shake > 0) S.shake *= 0.8; if(S.shake < 0.5) S.shake = 0;
    if(isNaN(S.shake)) S.shake = 0;

    S.cam.x += (p.x*TILE - cvs.width/2 - S.cam.x) * 0.1;
    S.cam.y += (p.y*TILE - cvs.height/2 - S.cam.y) * 0.1;

    S.ents.forEach(e => {
        if(e.dead) return;










// --- YONDU ARROW LOGIC START ---
        if(e.type === 'yaka_controller') {
            let target = e.plan[e.nextIdx];
            
            // If target dead/missing, skip to next
            if(!target || target.dead) {
                e.nextIdx++;
                if(e.nextIdx >= e.plan.length) {
                    e.dead = true;
                    // Leave visual trail
                    S.vfxs.push({type:'yaka_trail', trail:e.trail, life:100, maxLife:100});
                }
                return;
            }

            // Move towards Target
            let dx = target.x - e.x;
            let dy = target.y - e.y;
            let dist = Math.hypot(dx, dy);

            if(dist < e.speed) {
                // HIT!
                e.x = target.x; 
                e.y = target.y;
                e.trail.push({x: e.x, y: e.y});
                
                S.audio.play('yaka_hit'); // <--- PLAY IMPACT SOUND
                
                // Deal Damage
                
                // Deal Damage
                hit(target, e.dmg, { scale: e.scale, color:'#ff1744' });
                part(e.x, e.y, '#ff1744', 5, 2); 
                S.shake = 2;

                // Next Target
                e.nextIdx++;
                if(e.nextIdx >= e.plan.length) {
                    e.dead = true;
                   S.vfxs.push({type:'yaka_trail', trail:e.trail, life:100, maxLife:100});
                }
            } else {
                // FLY
                e.x += (dx/dist) * e.speed;
                e.y += (dy/dist) * e.speed;
                // Add smooth trail points
                if(Date.now() % 3 === 0) e.trail.push({x:e.x, y:e.y});
            }
        }
        // --- YONDU ARROW LOGIC END ---






















// ==========================================
        // PASTE THIS NEW BLOCK HERE
        // ==========================================
       // --- 1. VOID AURA LOGIC (The Dark Pool) ---
        if(e.type === 'void_aura') {
            e.x = S.p.x; e.y = S.p.y; // Follow Player
            // Die if no hands are active
            if(!S.ents.some(ent => ent.type === 'shadow_hand' && !ent.dead)) e.dead = true;
        }

        // --- 2. SHADOW HAND LOGIC (The Attack) ---
        if(e.type === 'shadow_hand') {
            if(!e.target || e.target.dead) { e.dead = true; return; }

            // State 0: Reaching
            if(e.state === 0) {
                let dx = e.target.x - e.x, dy = e.target.y - e.y;
                let dist = Math.hypot(dx, dy);
                if(dist > 0.5) {
                    e.x += (dx/dist) * e.speed; e.y += (dy/dist) * e.speed;
                } else {
                    e.state = 1; e.life = 40; S.shake = 2; // Grab!
                    S.audio.play('grasp_hit'); // <--- PLAY IMPACT SOUND HERE (Syncs perfectly)
                }
            }
            // State 1: Grabbing
            else if(e.state === 1) {
                e.life--;
                e.x = e.target.x; e.y = e.target.y; // Stick to enemy
                e.target.status.stun = Date.now() + 100; // Stun

                // EXPLOSION (Void Nuke)
                if(e.life <= 0) {
                    hit(e.target, e.dmg, {knock: 2.0, color:'#d500f9'});
                    S.shake = 25; // Massive Shake
                    
                    // Spawn Visual Explosion
                    S.vfxs.push({
                        type: 'void_nuke', x: e.target.x, y: e.target.y, 
                        life: 30, maxLife: 30, rot: Math.random()*6.28 
                    });
                    
                    // Spawn Debris
                    for(let k=0; k<12; k++) {
                        let ang=Math.random()*6.28, spd=0.5+Math.random()*0.5;
                        S.parts.push({
                            x:e.x, y:e.y, vx:Math.cos(ang)*spd, vy:Math.sin(ang)*spd,
                            c:Math.random()>.5?'#fff':'#d500f9', life:20, s:3+Math.random()*4, type:'void_shard'
                        });
                    }
                    e.dead = true;
                }
            }
        }
        // ==========================================
        // END OF PASTE
        // ==========================================











        if(e.type === 'npc') {
            e.moveTimer--;
            if(e.moveTimer <= 0) {
                if(Math.random() < 0.4) {
                    e.isWalking = true;
                    e.moveDir = Math.floor(Math.random() * 4); 
                    e.moveTimer = 30 + Math.random() * 50;
                } else {
                    e.isWalking = false;
                    e.moveTimer = 60 + Math.random() * 100;
                }
            }
            if(e.isWalking) {
                let mx = 0, my = 0;
                let s = 0.02; 
                if(e.moveDir === 0) my = -s;
                if(e.moveDir === 1) mx = s;
                if(e.moveDir === 2) my = s;
                if(e.moveDir === 3) mx = -s;
                
                // --- FIX: SMART DIRECTIONAL COLLISION ---
                // 1. Moving UP (Dir 0): Check the Shoulders (0.3) so head doesn't clip walls.
                // 2. Moving DOWN (Dir 2): Check the Feet (0.9) so they stand ON the tile.
                // 3. Side: Check the Center (0.5).
                let offY = 0.5;
                if (e.moveDir === 0) offY = 0.3; 
                if (e.moveDir === 2) offY = 0.9;

                // Check collisions using the calculated offsets
                if(!solid(e.x + mx + 0.5, e.y + offY, e)) e.x += mx;
                if(!solid(e.x + 0.5, e.y + my + offY, e)) e.y += my;
            }
        }

        if(e.type==='mob') {
            if(e.status.freeze > now && Math.random()<0.1) part(e.x, e.y, '#00e5ff', 1); 
            if(e.status.stun > now) return;
            if(e.status.poison > 0) {
                e.status.poison--;
                if(now%20===0) hit(e, 5, {color:'#8e44ad'});
            }
            if(e.status.burn > now && now%30===0) hit(e, 5, {color:'#e74c3c'});

            let speedMod = 1;
            if(e.status.slow > now) speedMod = 0.3; 
            if(e.status.freeze > now) speedMod = 0;

            let d = Math.hypot(p.x-e.x, p.y-e.y);
            
            // --- [STRESS FIX 1] REDUCED VISION ---
            // Old: Boss=14, Mob=9
            // New: Boss=9 (Screen edge), Mob=5 (Safe distance)
            let vision = e.boss ? 9 : 5; 
            
            if(d < vision || e.aggro > now) {
                if(d < vision) {
                    // --- [STRESS FIX 2] REDUCED CHASE TIME ---
                    // Bosses chase for 4s, Normal mobs give up after 2.5s
                    e.aggro = now + (e.boss ? 4000 : 2500);
                }

                let s = (e.boss ? 0.055 : 0.04) * speedMod;
                let mx = (p.x-e.x)/d * s; 
                let my = (p.y-e.y)/d * s;
                if(speedMod > 0) {
                    if(!solid(e.x+mx, e.y, e)) e.x+=mx;
                    if(!solid(e.x, e.y+my, e)) e.y+=my;
                }
                if(d < (e.boss?2:1) && (!e.hitCd || e.hitCd < now) && speedMod > 0) {
                    p.hp -= e.dmg;
S.audio.play('hurt');
popText(p.x, p.y, `-${e.dmg}`, "#e74c3c", true);








                    popText(p.x, p.y, `-${e.dmg}`, "#e74c3c", true);
                    S.shake = 8;
                    e.hitCd = now + 1200;
                    
                    // --- NEW LOGIC ---
                    if(p.hp <= 0 && !S.gameOver) { 
                        triggerGameOver(e.name); 
                    }
                    // -----------------
                }




            }
        }
        
        if(e.type==='zone') {
             e.life--; 
             for(let i=0; i<3; i++) {
                part(e.x+(Math.random()*e.w), e.y+(Math.random()*e.h), e.color, 1, 6, 'cloud');
             }
             if(e.life<=0) e.dead=true;
             S.ents.forEach(m => {
                 if(m.type==='mob' && !m.dead) {
                     if(m.x < e.x + e.w && m.x + (m.w||1) > e.x &&
                        m.y < e.y + e.h && m.y + (m.h||1) > e.y) {
                         m.status.poison = e.poison;
                         if(now % 200 < 20) hit(m, 5, {color:'#8e44ad'});
                     }
                 }
             });
        }
        
       if(e.type==='tornado') {
             // 1. GROW & MOVE
             if(!e.maxScale) e.maxScale = 2.0;
             if(e.scale < e.maxScale) e.scale += 0.04; 

             e.life--; 
             e.angle += 0.3; 
             e.x += e.vx; e.y += e.vy;
             
             // 2. RELIABLE COLLISION (Check Every Frame)
             S.ents.forEach(m => {
                if(m.type !== 'mob' || m.dead) return;
                
                // COOLDOWN CHECK: Has this mob been hit by a tornado recently?
                // This prevents hitting 60 times a second.
                if(m.tornadoTimer && m.tornadoTimer > Date.now()) return;

                let cx = m.x + (m.w||1)/2;
                let cy = m.y + (m.h||1)/2;
                let dist = Math.hypot(cx - e.x, cy - e.y);

                // HIT BOX: Increased size + Account for Mob Size
                if(dist < 2.5 + (m.w||1)/2) {
                     // HIT!
                     hit(m, e.dmg, { knock: 0 }); 
                     
                     // Set Cooldown (Hit roughly 5 times per second)
                     m.tornadoTimer = Date.now() + 200; 

                     // Vacuum Pull
                     let dx = e.x - m.x;
                     let dy = e.y - m.y;
                     let pullStr = 0.05;
                     if(!solid(m.x + dx*pullStr, m.y + dy*pullStr, m)) {
                         m.x += dx*pullStr;
                         m.y += dy*pullStr;
                     }
                }
             });
             
             if(e.life<=0) e.dead=true;
        }

        if(e.type==='web') {
             e.life--; 
             if(e.life<=0) e.dead=true;
             S.ents.forEach(m => {
                 let cx = m.x + (m.w||1)/2, cy = m.y + (m.h||1)/2;
                 if(m.type==='mob' && !m.dead && Math.hypot(cx-e.x, cy-e.y)<3.5) {
                     m.status.slow = now + 100; 
                 }
             });
        }

        if(e.type==='proj') {
            e.x += e.vx; e.y += e.vy; e.life--;
            if(e.icon==='üèπ') part(e.x, e.y, '#fff', 1, 2); 
            if(e.icon==='üßö') part(e.x, e.y, '#ff00ff', 1, 3);
            
            if(solid(e.x, e.y) || (e.icon==='üß™' && e.life<=1)) {
                e.dead = true;
                // Meteor Logic
                if(e.effect.icon==='‚òÑÔ∏è') { 
                    e.exploded=true; S.shake=15; 
                    S.ents.forEach(m => { if(m.type==='mob' && Math.hypot(e.x-m.x, e.y-m.y)<5) hit(m, e.dmg, e.effect); });
                }
                // Poison Flask Logic: Shatter -> Create Zone
                if(e.icon==='üß™') {
                    // Glass Shards
                    part(e.x, e.y, '#ccc', 8, 2); 
                    // Green Gas Puffs
                    part(e.x, e.y, '#8e44ad', 10, 4, 'cloud');
                    // Create the actual Zone
                    S.ents.push({
                        type:'zone', x:e.x-3.5, y:e.y-3.5, w:7, h:7, 
                        life:250, color:'#8e44ad', poison:e.effect.poison
                    });
                }
            }
            if(!e.dead) {
                if(e.effect.type === 'arrowRain' && e.life<=0) {
                     e.dead = true; S.shake = 5; part(e.x, e.y, '#f1c40f', 8, 3);
                     S.ents.forEach(m => { if(m.type==='mob' && !m.dead && Math.hypot(e.x-m.x, e.y-m.y)<3) hit(m, e.dmg, e.effect); });
                } 
                else if(e.effect.type === 'shower' && e.life<=0) {
                     e.dead = true; S.shake = 10; part(e.x, e.y, '#ff5722', 20, 5);
                     S.ents.forEach(m => { if(m.type==='mob' && !m.dead && Math.hypot(e.x-m.x, e.y-m.y)<4) hit(m, e.dmg, e.effect); });
                } 
                else {
                    S.ents.forEach(m => {
                        let cx = m.x + (m.w||1)/2, cy = m.y + (m.h||1)/2;
                        let hitDist = (e.effect.icon==='‚òÑÔ∏è'?2:1.5);
                        
                        if(m.type==='mob' && !m.dead && Math.hypot(e.x-cx, e.y-cy)< hitDist + (m.w||1)/2) {
                            hit(m, e.dmg, e.effect); e.dead=true;
                            part(e.x, e.y, e.color, 8, 3);
                        }
                    });
                }
            }
        }
        
        if(e.type==='vfx_proj') {
            e.x += e.vx; e.y += e.vy; e.life--; e.scale += 0.03; 
            if(solid(e.x, e.y)) e.dead = true; 
            S.ents.forEach(m => {
                let cx = m.x + (m.w||1)/2, cy = m.y + (m.h||1)/2;
                if(m.type==='mob' && !m.dead && Math.hypot(e.x-cx, e.y-cy) < (e.scale*0.8)) {
                     hit(m, e.dmg, {knock:1.0});
                }
            });
            if(e.life<=0) e.dead=true;
        }
    });

    S.ents = S.ents.filter(e => !e.dead);

    document.getElementById('hp-bar').style.width = (Math.max(0, p.hp)/p.maxHp*100)+'%';
    let xpReq = p.lvl*100;
    document.getElementById('xp-bar').style.width = (Math.min(xpReq, p.xp)/xpReq*100)+'%';
    document.getElementById('lvl-val').innerText = p.lvl;
    
    // --- QUEST BOX LOGIC (FINAL) ---
    let q = QUESTS[S.qStep];
    let qBox = document.getElementById('quest-txt');

    if(q) {
        // 1. Normal Mission
        let prog = (q.type==='collect'||q.type==='activate') ? ` (${S.qProg}/${q.count})` : '';
        qBox.innerText = q.txt + prog;
        
        if(q.type === 'kill' && S.p.killLog.includes(q.target)) nextQuest();
    } 
    // 2. Boss Dead + Haven't talked to Noah/Doris yet -> SHOW INSTRUCTIONS
    else if (S.bossDead && !S.epilogueSeen) {
        qBox.innerHTML = `
            <!-- UPDATED: White color, 22px size. Kept original structure. -->
            <div style='color:#fff; font-size:22px; border-bottom:1px solid #444; margin-bottom:5px;'>East ‚ûî Farm</div>
            
            <div style='display:flex; align-items:center; justify-content:center; gap:5px;'>
                <div style='font-size:65px; color:#00e676; line-height:1.0;'>‚Ü©</div>
                <div style='text-align:left; display:flex; flex-direction:column;'>
                    <span style='color:#00e676; font-size:22px; font-weight:bold; line-height:0.9;'>RETURN<br>TO</span>
                    <span style='color:#ff1744; font-size:26px; font-weight:bold; line-height:0.9; margin-top:2px; text-shadow:2px 2px 0 #000;'>STARTING<br>VILLAGE</span>
                </div>
            </div>
            <div style='margin-top:8px; padding-top:4px; border-top:1px dashed #555; color:#ffd700; font-size:24px; font-weight:bold; text-shadow:1px 1px 0 #000;'>
                üéÅ SURPRISE **
            </div>
        `;
    }
    // 3. Epilogue Seen -> CLEAR BOX
    else {
        qBox.innerText = "World Cleansed!";
        qBox.style.color = "#eee"; // Reset color
    }




// --- UPDATE MINIMAP PLAYER DOT ---
let miniDot = document.getElementById('mini-player');
if (miniDot) {
    // Map is 180x180, CSS is 180x180. Ratio is 1:1.
    miniDot.style.left = S.p.x + 'px';
    miniDot.style.top = S.p.y + 'px';
    
    // Hide dot if we are in a menu or dead
    miniDot.style.display = (S.p.hp <= 0) ? 'none' : 'block';
}





    if(S.world==='main') {
        CLASSES[p.class].skills.forEach(s => {
            let el=document.getElementById('cd-'+s);
            if(el) el.style.height = (Math.max(0, (p.cds[s]||0)-now)/SKILLS[s].cd*100) + '%';
        });
    }

// --- GLOBAL DEATH CHECK (SAFETY NET) ---
    // This catches you if the monster hit missed the check
    if(S.p.hp <= 0 && !S.gameOver) {
        triggerGameOver("Fatal Injury");
    }


}





function xIn(e, x, y) { return x >= e.x && x < e.x+e.w && y >= e.y && y < e.y+e.h; }

function solid(x, y, excludeEnt=null) {
    let b = 0.35; 
    let corners = [
        {x:x-b, y:y-b}, {x:x+b, y:y-b},
        {x:x-b, y:y+b}, {x:x+b, y:y+b}
    ];
    
    if(S.world === 'farm') {
        let k = `${Math.floor(x)},${Math.floor(y)}`;
        if(S.farm.fences[k]) return true;
        if(['stone','stump','boulder'].includes(S.farm.debris[k])) return true;
    }

    for(let c of corners) {
        let mx = Math.floor(c.x);
        let my = Math.floor(c.y);
        if(mx >= 0 && mx < MAP_S && my >= 0 && my < MAP_S) {
            if(S.map[my*MAP_S + mx] === T.BLOCK) return true;
        }
    }

    if(x<0||y<0||x>=MAP_S||y>=MAP_S) return true;
    let t = S.map[Math.floor(y)*MAP_S+Math.floor(x)];

    if(t===T.WATER || t===T.BEDROCK || t===T.LOCK) return true;
    
    for(let e of S.ents) {
        if(e.dead) continue;
        if(e === excludeEnt) continue; 
        
        if(e.type==='struct') {
            // FIX: Allow walking through Fountain AND Crystals
            if (e.kind === 'Healing Crystal' || e.kind === 'Fountain') continue;

            if(x >= e.x && x < e.x+e.w && y >= e.y && y < e.y+e.h) return true;
        }
        else if(e.type==='obj' && e.name==='Tablet') {
            if(x >= e.x && x < e.x+e.w && y >= e.y && y < e.y+e.h) return true;
        }
        else if(e.type==='env') {
            if(e.kind==='Fence') { if(Math.abs(e.x-x)<0.5 && Math.abs(e.y-y)<0.5) return true; }
            else if(['flower','mushroom','pebble'].includes(e.kind)) continue;
            else if(Math.round(e.x) === Math.floor(x) && Math.round(e.y) === Math.floor(y)) return true;
        }
        else if(e.type==='npc') {
             // FIX: Offset collision to match drawing (Right 0.5, Down 0.7)
             if(Math.hypot((e.x + 0.5)-x, (e.y + 0.7)-y) < 0.5) return true;
        }
        else if(e.type==='farm_mob') {
             if(Math.hypot(e.x-x, e.y-y) < 0.5) return true;
        }
    }
    return false;
}

function hit(m, dmg, eff={}) {
    // --- NEW SCALING LOGIC ---
    // Default scaling is 1.0 if not defined. 
    // Multi-hit skills (Starfall/Web) will use their low scale (0.05 / 0.06).
    let scaleFactor = eff.scale !== undefined ? eff.scale : 1.0;
    
    // Calculate Level Bonus: (Level-1) * 20 * ScaleFactor
    // Example: Lvl 10 Web Arrow = 9 * 20 * 0.06 = +10 damage per bounce.
    // Example: Lvl 10 Slash     = 9 * 20 * 1.0  = +180 damage.
    let levelBonus = Math.max(0, (S.p.lvl-1) * 20 * scaleFactor);
    
    let totalDmg = dmg + levelBonus;
    // -------------------------

    m.hp -= totalDmg;
    m.aggro = Date.now() + 6000;
    popText(m.x, m.y, Math.floor(totalDmg), eff.color||"#fff");
    
    if(m.hp <= 0) {
        kill(m);
        return;
    }
    
    if(eff.heal) {
        S.p.hp = Math.min(S.p.maxHp, S.p.hp + eff.heal);
        popText(S.p.x, S.p.y-1, "+"+eff.heal, "#0f0");
    }

    if(eff.vfx === 'slash') S.vfxs.push({x:m.x, y:m.y, type:'slash', life:10, ang:Math.random()*6});
    if(eff.vfx === 'bash') S.shockwaves.push({x:m.x, y:m.y, r:0, maxR:2.5, a:1, c:'#e74c3c'});
    
    if(eff.burn) m.status.burn = Date.now()+3000;
    if(eff.poison) { m.status.poison = 50; part(m.x, m.y, '#8e44ad', 10, 3, 'cloud'); }
    if(eff.stun) m.status.stun = Date.now()+eff.stun;
    if(eff.freeze) m.status.freeze = Date.now()+eff.freeze; // Use the specific freeze time
    
    let k = eff.knock || 0.5;
    if(m.boss && m.hp > 1000) k = 0; 
    // Vacuum/Pull Logic for Warrior Tornado (Optional, but you said you preferred Push)
    // if(eff.tornado) k = -0.5; 

    if(k !== 0) {
        let ang = Math.atan2(m.y-S.p.y, m.x-S.p.x);
        let tx = m.x + Math.cos(ang)*k, ty = m.y + Math.sin(ang)*k;
        if(!solid(tx, ty, m)) { m.x=tx; m.y=ty; }
    }
}


function cast(k) {
    const p = S.p, now = Date.now();
    let sName = CLASSES[p.class].skills.find(n => SKILLS[n].k.toLowerCase()===k);
    if(!sName) return;
    
    let s = SKILLS[sName];
    if(s.locked && S.qStep <= 4) { 
        showChat("SYSTEM", "Skill Locked! Complete Ruins Task to unlock.");
        return;
    }

// FIX: Removed 'error' sound here so it doesn't beep when spamming keys
    if((p.cds[sName]||0) > now) return;
    
    p.cds[sName] = now + s.cd;

    // AUDIO: Specific Skill Mapping
    const ic = s.icon;

    // --- WARRIOR ---
    if (ic === '‚öîÔ∏è') S.audio.play('swing');       // Slash
    else if (ic === 'üõ°Ô∏è') S.audio.play('bash');   // Bash (Specific File)
    else if (ic === '‚ò¢Ô∏è') S.audio.play('wstomp'); // War Stomp
    else if (ic === '‚ù§Ô∏è') S.audio.play('heal');   // Rally
    else if (ic === 'üåã') S.audio.play('quake');  // Quake
    else if (ic === 'üåÄ') S.audio.play('tornado');// Tornado

    // --- MAGE ---
    else if (ic === 'üî•') S.audio.play('explode'); // Inferno (Magma)
    else if (ic === '‚ùÑÔ∏è') S.audio.play('ice');     // Glacial Spike
    else if (ic === '‚ö°') S.audio.play('thunder'); // Thunderstorm
    else if (ic === 'üíö') S.audio.play('heal');    // Heal
     else if (ic === '‚ú®') S.audio.play('starfall');// Starfall

    // --- RANGER ---
    else if (ic === 'üèπ') S.audio.play('yaka_cast'); // Shoot (Yaka Arrow Cast)
    else if (ic === '‚ò†Ô∏è') S.audio.play('poison');  // Poison Cloud
    else if (ic === 'üï∏Ô∏è') S.audio.play('trap');    // Trap
    else if (ic === 'üëü') S.audio.play('rush');    // Rush
   else if (ic === 'üåßÔ∏è') S.audio.play('arrow_storm');   // Arrow Storm (Generic Bow sound fits rain)
    else if (ic === 'üßö') S.audio.play('fairy');   // Fairy Bomb

    else S.audio.play('magic'); // Fallback



    
    // ===============================================
    // WARRIOR SKILL LOGIC
    // ===============================================
    
    // 1. Z SKILL: SLASH (Triple Energy Cleave)
    // Replaces the old simple line slash
    // ===============================================
    // WARRIOR SKILL LOGIC
    // ===============================================
    
    // 1. Z SKILL: SLASH (Massive Combo)
  // ===============================================
    // WARRIOR SKILL LOGIC
    // ===============================================
    
    // ===============================================
    // WARRIOR SKILL LOGIC
    // ===============================================
    
    // 1. Z SKILL: SLASH (Combo: Small -> Small -> MASSIVE)
    if(p.class === 'warrior' && s.icon === '‚öîÔ∏è') {
        [0, 100, 200].forEach((delay, i) => {
            setTimeout(() => {
                let swingSide = (i % 2 === 0) ? 1 : -1; 
                let isFinisher = (i === 2);

                S.vfxs.push({
                    type: 'sword_sweep',
                    x: p.x, y: p.y, dir: p.dir, side: swingSide,
                    life: 15, maxLife: 15,
                    
                    // --- THE MIX: Small Combo vs Big Finish ---
                    // Hit 1 & 2: White, Scale 1.5 (Fast/Sharp)
                    // Hit 3: Cyan, Scale 4.0 (Screen Filling)
                    color: isFinisher ? '#00e5ff' : '#ffffff', 
                    scale: isFinisher ? 4.0 : 1.5,
                    width: isFinisher ? 4 : 2 // Thicker line for finisher
                });
            }, delay);
        });
    }

  // 2. X SKILL: BASH (Shield + Red Aura)
    if(s.icon === 'üõ°Ô∏è') {
        // A. The Golden Shield (Physical Form)
        S.vfxs.push({
            type: 'shield_slam',
            x: p.x, y: p.y, dir: p.dir,
            
            // --- UPDATED: FASTER DURATION ---
            life: 35,      // Reduced from 60 to 35
            maxLife: 35
        });

        // B. The "Red Part" (Angry Energy Aura)
        S.vfxs.push({
            type: 'shield_aura', 
            x: p.x, y: p.y, dir: p.dir,
            
            // --- UPDATED: MATCHING DURATION ---
            life: 35,      // Reduced from 60 to 35
            maxLife: 35
        });
        
        // Ground particles
        for(let i=0; i<8; i++) {
             let ang = (p.dir * 1.57) + (Math.random()-0.5);
             let dist = 1.5 + Math.random();
             part(p.x + Math.cos(ang)*dist, p.y + Math.sin(ang)*dist, '#e74c3c', 1, 4, 'cloud');
        }
    }

  




// ===============================================
    // NEW SKILL: ABYSSAL GRASP (Mage B) - FIX HERE
    // ===============================================
    // ===============================================
    // NEW SKILL: ABYSSAL GRASP (Mage B)
   // ===============================================
    // NEW SKILL: ABYSSAL GRASP (Mage B)
    // ===============================================
    if(s.grasp) {
        S.audio.play('grasp_cast'); // <--- PLAY CAST SOUND HERE
        S.shake = 5;

        // --- 1. VISUAL: POOL RIPPLE ---
        // while the slow hands travel.
        S.vfxs.push({
            type: 'void_ripple', 
            x: p.x,
            y: p.y,
            life: 300,           
            maxLife: 300
        });

        // --- 2. LOGIC: VOID AURA ---
        if(!S.ents.some(e => e.type === 'void_aura')) {
            S.ents.push({ type: 'void_aura', x: p.x, y: p.y, h: 0 });
        }
        
        // --- 3. LOGIC: SPAWN SLOW HANDS ---
        let targets = S.ents.filter(e => e.type==='mob' && !e.dead && Math.hypot(e.x-p.x, e.y-p.y) < s.range);
        
        targets.forEach((m, i) => {
            setTimeout(() => {
                S.ents.push({
                    type: 'shadow_hand',
                    x: p.x,     
                    y: p.y,
                    target: m,  
                    
                    // LIFE: Increased to 400 so it doesn't disappear mid-air
                    life: 400,  
                    state: 0,   
                    dmg: s.dmg,

                    // SPEED: Reduced from 0.3 to ~0.08
                    // This makes it crawl very slowly!
                    speed: 0.08 + (Math.random()*0.02) 
                });
            }, i * 50); 
        });
        return; 
    }
    // ===============================================

    // --- OTHER SKILL LOGIC ---







  
    
    if(s.vfx === 'boom') {
         S.vfxs.push({type:'void_burst', x:p.x, y:p.y, life:50});
         for(let i=0; i<20; i++) {
             let ang = Math.random()*6.28;
             let dist = 10 + Math.random()*5;
             S.parts.push({
                 x: p.x + Math.cos(ang)*dist, y: p.y + Math.sin(ang)*dist,
                 vx: -Math.cos(ang)*0.4, vy: -Math.sin(ang)*0.4,
                 c: '#4a148c', life: 25, s: 3, type: 'norm'
             });
         }
         setTimeout(() => {
             S.ents.forEach(m => {
                 if(m.type==='mob' && !m.dead) {
                     let mx = m.x + (m.w||1)/2, my = m.y + (m.h||1)/2;
                     if(Math.hypot(mx-p.x, my-p.y) < 7 + (m.w||1)/2) hit(m, s.dmg, {knock:4.0, color:'#d500f9'});
                 }
             });
         }, 200);
    }

    if(s.tornado) {
         S.shake = 10;
         
         // 1. Determine Player Facing Angle
         let baseAng = 0;
         if(p.dir === 0) baseAng = -1.57; // Up
         if(p.dir === 1) baseAng = 0;     // Right
         if(p.dir === 2) baseAng = 1.57;  // Down
         if(p.dir === 3) baseAng = 3.14;  // Left

         // 2. Capture Start Position (So they spawn from where you CAST, not where you run)
         // 2. Capture Start Position (OFFSET FORWARD so it hits enemies instantly)
         // 0:Up, 1:Right, 2:Down, 3:Left
         let forward = 1.5; 
         let startX = p.x + (p.dir===1 ? forward : p.dir===3 ? -forward : 0);
         let startY = p.y + (p.dir===2 ? forward : p.dir===0 ? -forward : 0);
         
         let count = 5; // 5 Tornadoes for a clean sector

         for(let i=0; i<count; i++) {
             // STAGGER: Spawn them 120ms apart
             setTimeout(() => {
                 // 3. Calculate Cone Angle (Spread them out)
                 // This maps i (0 to 4) to an offset between -0.5 and +0.5 radians (~60 degrees)
                 let spread = 1.0; 
                 let offset = -spread/2 + (i / (count-1)) * spread; 
                 let finalAng = baseAng + offset;

                 // Debris Gen (Same as before)
                 let debris = [];
                 for(let d=0; d<8; d++) {
                     debris.push({
                         angle: Math.random() * 6.28,
                         dist: 20 + Math.random() * 20, 
                         speed: 0.15 + Math.random() * 0.1,
                         size: 3 + Math.random() * 4,
                         yOff: Math.random() * 60 
                     });
                 }

                 S.ents.push({
                    type: 'tornado', 
                    x: startX, // Spawn from original cast point
                    y: startY,
                    // Move OUTWARD in the cone direction
                    vx: Math.cos(finalAng) * 0.12, 
                    vy: Math.sin(finalAng) * 0.12, 
                    life: 140, 
                    maxLife: 140,
                    angle: Math.random()*6.28,
                    scale: 0.2, // Start Small
                    maxScale: 2.5, // Grow HUGE
                    dmg: s.dmg,
                    debris: debris
                 });
                 
                 // Little screen shake on each spawn for weight
                 S.shake = 5; 

             }, i * 120); // The Stagger Delay
         }
         return;
    }


if(s.stomp) {
        // 1. Shockwave Ring (Thick & Fast)
        S.shockwaves.push({
            x: p.x, y: p.y, 
            r: 0.5,      
            maxR: 9.0,   // Matches range
            a: 1.0,      
            c: '#fff',   // White hot
            w: 8         // Thick line
        });

        // 2. Flying Debris (Rock Chunks)
        for(let i=0; i<15; i++) {
             let ang = Math.random() * 6.28;
             part(p.x, p.y, '#5d4037', 1, 5 + Math.random()*5, 'rock'); 
             let lastPart = S.parts[S.parts.length-1];
             let spd = 2 + Math.random() * 3;
             lastPart.vx = Math.cos(ang) * spd;
             lastPart.vy = Math.sin(ang) * spd;
        }

        // 3. The Explosion Cloud (Nuclear Style)
        let puffs = [];
        for(let i=0; i<40; i++) { 
            let angle = Math.random() * 6.28;
            let dist = Math.random() * 20; // Start near center
            let speed = 5 + Math.random() * 8; // Blast outwards FAST
            
            puffs.push({
                x: Math.cos(angle) * dist, 
                y: Math.sin(angle) * dist * 0.7, 
                vx: Math.cos(angle) * speed, 
                vy: Math.sin(angle) * speed * 0.7, 
                r: 20 + Math.random() * 30, // Big clouds
                rot: Math.random() * 6.28,
                id: i 
            });
        }

        S.vfxs.push({
            type: 'explosion_cloud', 
            x: p.x, 
            y: p.y, 
            life: 40,        
            maxLife: 40, 
            puffs: puffs
        });

        // 4. Hit Logic (Wide Area + Flash)
        S.ents.forEach(m => {
            let mx = m.x + (m.w||1)/2, my = m.y + (m.h||1)/2;
            if(m.type==='mob' && !m.dead && Math.hypot(mx-p.x, my-p.y) < s.range) {
                part(m.x, m.y, '#fff', 10, 5); // Flash on hit
                hit(m, s.dmg, { knock: s.knock });
            }
        });
        return;
    }

    if(s.quake) {
        // 1. Generate Main Fissures (Screen Wide)
        let cracks = [];
        // Increase from 8 to 12 main cracks
        for(let i=0; i<12; i++) {
            let angle = (i/12) * 6.28; 
            let path = [{x:0, y:0}]; 
            
            let dist = 0;
            let cx = 0, cy = 0;
            // FIX: Multiply by 45 to convert Tile Range to Pixels
            // Range 12 * 45 = 540px radius (Huge)
            let maxDist = s.range * 45; 
            
            while(dist < maxDist) {
                // Longer segments for jagged look
                let seg = 10 + Math.random() * 10;
                dist += seg;
                
                // Add "Jitter" to angle
                let jag = angle + (Math.random() - 0.5) * 0.8; 
                
                cx += Math.cos(jag) * seg;
                cy += Math.sin(jag) * seg * 0.7; // Flatten Y
                path.push({x:cx, y:cy});

                // Chance to add a "Branch" crack
                if(Math.random() < 0.3) {
                     cracks.push([
                         {x:cx, y:cy},
                         {x:cx + Math.cos(jag+0.5)*30, y:cy + Math.sin(jag+0.5)*30}
                     ]);
                }
            }
            cracks.push(path);
        }

        S.vfxs.push({
            type: 'tectonic_rupture', 
            x: p.x, 
            y: p.y, 
            life: 80,         // 1.3 Seconds
            maxLife: 80,
            cracks: cracks
        });

        // 3. Magma Eruption Particles
        for(let i=0; i<40; i++) {
            let ang = Math.random() * 6.28;
            let d = Math.random() * 20;
            part(p.x + Math.cos(ang)*d, p.y + Math.sin(ang)*d, '#ff5722', 1, 4, 'rock');
            S.parts[S.parts.length-1].vy = -3 - Math.random()*3; // Fly High UP
        }

        // 4. Hit Logic
        S.ents.forEach(m => {
            let mx = m.x + (m.w||1)/2, my = m.y + (m.h||1)/2;
            if(m.type==='mob' && !m.dead && Math.hypot(mx-p.x, my-p.y) < s.range) {
                hit(m, s.dmg, s);
            }
        });
        return; 
    }






if(s.spike) {
        // 1. Determine Player Facing Angle
        let faceAng = 0;
        if(p.dir===0) faceAng = -Math.PI/2; 
        else if(p.dir===1) faceAng = 0;     
        else if(p.dir===2) faceAng = Math.PI/2; 
        else faceAng = Math.PI;             

        let coneWidth = 0.7; // ~40 degrees wide

        // 2. Spawn Visuals: "The Elsa Wave"
        // We divide the range into 6 concentric rows (waves)
        let rows = 6;
        
        for(let r=1; r<=rows; r++) {
            // A. Calculate Distance for this row
            let distRatio = r / rows; // 0.16 -> 1.0
            let currentDist = distRatio * s.range;
            
            // B. Calculate Timing (Further = Later)
            let waveDelay = (r-1) * 60; // 0ms, 60ms, 120ms... (The Ripple)

            // C. Calculate Size (Further = Bigger)
            // Near: 0.7x, Far: 2.5x
            let size = 0.7 + (distRatio * 1.8);

            // D. How many spikes in this row? (More space = More spikes)
            let spikeCount = 2 + Math.ceil(r * 1.2); 

            for(let i=0; i<spikeCount; i++) {
                setTimeout(() => {
                    // Spread spikes evenly across the cone arc
                    // Map 'i' to a value between -0.5 and 0.5
                    let arcPos = (spikeCount === 1) ? 0 : (i / (spikeCount-1)) - 0.5;
                    
                    // Add slight random jitter so it looks organic, not robotic
                    let angle = faceAng + (arcPos * coneWidth * 2) + (Math.random()*0.15 - 0.075);
                    
                    S.vfxs.push({
                        type: 'glacial_spike',
                        x: p.x + Math.cos(angle) * currentDist,
                        y: p.y + Math.sin(angle) * currentDist,
                        life: 80,       
                        maxLife: 80,
                        scale: size     
                    });
                    
                    // Add cold mist at the base
                    part(p.x + Math.cos(angle)*currentDist, p.y + Math.sin(angle)*currentDist, '#e0f7fa', 2, 3 + size*2, 'cloud');

                }, waveDelay + Math.random()*20); // Add small random delay to soften the row
            }
        }

        // 3. Hit Logic (Instant Hit Check)
        // We hit everything in the cone immediately so you don't miss moving targets
        S.ents.forEach(m => {
            if(m.type !== 'mob' || m.dead) return;
            
            let dx = (m.x + m.w/2) - p.x;
            let dy = (m.y + m.h/2) - p.y;
            let dist = Math.hypot(dx, dy);
            let mobAng = Math.atan2(dy, dx);
            
            let diff = mobAng - faceAng;
            while(diff < -Math.PI) diff += Math.PI*2;
            while(diff > Math.PI) diff -= Math.PI*2;

            // Hit Cone check
            if(dist < s.range && Math.abs(diff) < coneWidth + 0.2) { 
                m.status.freeze = Date.now() + s.freeze;
                hit(m, s.dmg, { knock: 4.0 }); // High knockback (Push them away with the ice)
                
                // Add shatter effect on mob
                part(m.x, m.y, '#00e5ff', 10, 4);
                popText(m.x, m.y, "FROZEN", "#00e5ff", true, true);
            }
        });
        return;
    }





// --- 1. LOGIC FOR INFERNO (Magma Boulders) ---
   // --- 1. LOGIC FOR INFERNO (Phoenix Flame) ---
    // --- 1. LOGIC FOR INFERNO (Phoenix Flame) ---
    // --- 1. LOGIC FOR INFERNO (Chaotic Phoenix Fire) ---
    if(s.inferno) {
        // Random Count: 5 to 7
        let cnt = Math.floor(Math.random() * 3) + 5; 
        
        for(let i=0; i<cnt; i++) {
            // Get base facing angle
            let baseAng = 0;
            if(p.dir===0) baseAng = -1.57; // Up
            if(p.dir===1) baseAng = 0;     // Right
            if(p.dir===2) baseAng = 1.57;  // Down
            if(p.dir===3) baseAng = 3.14;  // Left
            
            // CHAOS 1: Random Angle (Wide Cone +/- 50 degrees)
            // No fixed pattern. Pure random spread.
            let randomOffset = (Math.random() - 0.5) * 1.8; 
            let finalAng = baseAng + randomOffset;
            
            // CHAOS 2: Random Speed
            // Varies between 0.15x and 0.35x of base speed.
            // This creates depth as they separate over time.
            let speedVar = (0.15 + Math.random() * 0.20) * s.spd;

            // CHAOS 3: Random Spawn Position
            // Don't spawn from a single pixel. Burst from the whole body.
            let offX = (Math.random() - 0.5) * 1.0;
            let offY = (Math.random() - 0.5) * 1.0;

            S.ents.push({
                type:'proj', 
                x: p.x + offX, 
                y: p.y - 0.5 + offY, 
                vx: Math.cos(finalAng) * speedVar, 
                vy: Math.sin(finalAng) * speedVar, 
                dmg: s.dmg, 
                color: s.color, 
                effect: s, 
                life: 240, // Long life
                
                vfxType: 'phoenix_fire', 
                seed: Math.random() * 10,
                birth: Date.now()
            });
        }
        return;
    }



    // --- 2. LOGIC FOR THUNDERSTORM (Lightning Strikes) ---
  // --- 2. LOGIC FOR THUNDERSTORM (UPGRADED) ---
    if(s.storm) { 
        S.shake = 25; // MASSIVE SHAKE
        
        // 1. Find Targets
        let targets = S.ents.filter(e => e.type==='mob' && !e.dead && Math.hypot(e.x-p.x, e.y-p.y) < s.range);
        
        // 2. Determine number of strikes (Max 8)
        let strikeCount = targets.length > 0 ? targets.length : 5;
        if(strikeCount > 8) strikeCount = 8; 

        for(let i=0; i<strikeCount; i++) {
            let target = targets[i];
            let tx = target ? target.x : p.x + (Math.random()-0.5)*12;
            let ty = target ? target.y : p.y + (Math.random()-0.5)*12;
            
            // Stagger the strikes
            setTimeout(() => {
                // VISUAL: Generate a Heavy Bolt
                lightning(tx, ty - 20, tx, ty, true); // True = Heavy Bolt
                
                // VISUAL: Giant Ground Flash
                part(tx, ty, '#e0f7fa', 15, 8, 'cloud');
                
                // VISUAL: Impact Shockwave (The "Wow" Factor ring)
                S.shockwaves.push({
                    x:tx, y:ty, 
                    r:0.5, maxR:5.0, // Big ring
                    a:1.0, c:'#00ffff', w:10 // Cyan, Thick line
                });

                // DAMAGE
                if(target) {
                    hit(target, s.dmg, { stun: s.stun, knock: 1.0 });
                    part(target.x, target.y, '#ffd700', 10, 4); // Sparks
                }
            }, i * 60); // Faster stagger for chaos
        }
        return;
    }




    if(s.type === 'fairy') {
        S.shake = 10;
        for(let k=0; k<5; k++) {
            setTimeout(() => {
                S.ents.forEach(m => {
                    let mx = m.x + (m.w||1)/2, my = m.y + (m.h||1)/2;
                    let dist = Math.hypot(mx-p.x, my-p.y);
                    if(m.type==='mob' && !m.dead && dist < s.range + (m.w||1)) {
                        hit(m, s.dmg, {color:'#ff00ff'});
                    }
                });
            }, k * 100); 
        }

        for(let i=0; i<50; i++) {
            let colors = ['#ff00ff', '#00ffff', '#ffff00', '#00ff00', '#ff69b4', '#8a2be2'];
            let c = colors[Math.floor(Math.random()*colors.length)];
            let ang = Math.random() * 6.28;
            let spd = 0.2 + Math.random() * 0.4;
            part(p.x, p.y, c, 1, 5 + Math.random()*15, 'cloud');
            let justAdded = S.parts[S.parts.length-1];
            justAdded.vx = Math.cos(ang) * spd; justAdded.vy = Math.sin(ang) * spd;
            
            if(i % 3 === 0) {
                setTimeout(() => {
                    let icons = ['ü¶ã', 'üåà', '‚ú®', 'ü¶Ñ'];
                    let ic = icons[Math.floor(Math.random()*icons.length)];
                    part(p.x, p.y, c, 1, 20 + Math.random()*20, 'icon_' + ic);
                    let justIcon = S.parts[S.parts.length-1];
                    justIcon.vx = Math.cos(ang) * spd * 1.2; justIcon.vy = Math.sin(ang) * spd * 1.2;
                }, i * 20);
            }
        }
        return;
    }

    if(s.type === 'shower' || s.type === 'arrowRain') {
        let color = s.type==='arrowRain' ? '#fff' : '#ff5722';
        for(let i=0; i<s.count; i++) {
            setTimeout(() => {
                let angle = Math.random() * 6.28;
                let dist = 2 + Math.random() * 8; 
                let tx = p.x + Math.cos(angle)*dist;
                let ty = p.y + Math.sin(angle)*dist;
                let offset = s.type==='arrowRain' ? 12 : 15;
                let spd = s.type==='arrowRain' ? 1.5 : 0.8;
                let size = 0.5 + Math.random() * 1.0; 
                S.ents.push({
                    type:'proj', x:tx, y:ty-offset, vx:0, vy:spd, 
                    dmg:s.dmg, color:color, effect:s, life:15, icon: s.type==='arrowRain' ? 'üèπ' : '',
                    scale: size
                });
            }, i*(s.type==='arrowRain'?10:50)); 
        }
        return;
    }

    if(s.type === 'stars') {
         S.shake = 5;
         for(let i=0; i<s.count; i++) {
            setTimeout(()=>{
                let angle = Math.random() * 6.28;
                let dist = Math.random() * 12; 
                let target = S.ents.find(e => e.type==='mob' && !e.dead && Math.hypot(e.x-p.x, e.y-p.y) < 10 && Math.random() < 0.3);
                let sx = p.x + Math.cos(angle)*dist;
                let sy = p.y + Math.sin(angle)*dist;
                if(target) { sx = target.x; sy = target.y; }
                S.ents.push({type:'proj', x:sx, y:sy-10, vx:0, vy:1.0, dmg:s.dmg, color:'#ffd700', effect:{...s, icon:'‚ú®'}, life:15, star:true});
            }, i*20); 
         }
         return;
    }

    if(s.icon==='‚ö°') { 
        S.shake = 10;
        S.ents.forEach(e => { if(e.type==='mob' && Math.hypot(e.x-p.x, e.y-p.y)<s.range) hit(e, s.dmg, s); });
        for(let i=0; i<8; i++) {
             let angle = (i/8)*6.28;
             let tx = p.x + Math.cos(angle)*s.range;
             let ty = p.y + Math.sin(angle)*s.range;
             lightning(p.x, p.y, tx, ty);
        }
        return;
    }
    // RANGER X: POISON FLASK (Lobbed Projectile)
    // RANGER X: NINJA SMOKE (Visual Update)
    if(s.icon==='‚ò†Ô∏è') { 
        // 1. Visual: Instant Smoke Puffs around player
        S.shake = 5;
        for(let i=0; i<20; i++) {
            part(p.x, p.y, i%2==0?'#8e44ad':'#555', 1, 6+Math.random()*4, 'cloud');
        }

        // 2. Logic: Create the poison zone instantly at feet
        S.ents.push({
            type:'zone', 
            x:p.x-4, y:p.y-4, w:8, h:8, // Large 8x8 area
            life:200, 
            color:'#8e44ad', 
            poison:s.poison
        });
        return;
    }




    if(s.icon==='üï∏Ô∏è') {
        S.ents.push({type:'web', x:p.x, y:p.y, life:120}); 
        return;
    }
    if(s.icon==='üåã') { 
        S.shake = 25; part(p.x, p.y, '#5d4037', 50, 6); 
        S.ents.forEach(e => { if(e.type==='mob' && Math.hypot(e.x-p.x, e.y-p.y)<s.range) hit(e, s.dmg, s); });
        return; 
    }
    if(s.icon==='‚òÑÔ∏è') { 
        let tx = p.x + (p.dir===1?5:p.dir===3?-5:0), ty = p.y + (p.dir===2?5:p.dir===0?-5:0);
        S.ents.push({type:'proj', x:tx, y:ty-10, vx:0, vy:0.5, dmg:s.dmg, color:'#ff5722', effect:s, life:25}); 
        return; 
    }
    // RANGER Z: YAKA ARROW (Chain Attack)
    // RANGER Z: CHAOS WEB ARROW
   if(s.icon==='üèπ') { 
        // 1. Calculate the Flight Plan
        let flightPlan = [];
        let curr = {x:p.x, y:p.y};
        let hitIds = []; 

        for(let i=0; i<15; i++) { // 15 Bounces
            // Find closest enemy we haven't hit yet
            let targets = S.ents.filter(e => 
                e.type==='mob' && !e.dead && !hitIds.includes(e) && 
                Math.hypot(e.x-curr.x, e.y-curr.y) < 10.0
            );
            
            // Sort by distance
            // CHAOS MODE: Randomize targets to create a criss-cross web
            targets.sort(() => Math.random() - 0.5);
            
            if(targets.length > 0) {
                let t = targets[0];
                flightPlan.push(t); 
                hitIds.push(t);
                curr = t; 
            } else {
                break; 
            }
        }

        // 2. Spawn the Arrow Controller
        if(flightPlan.length > 0) {
            S.ents.push({
                type: 'yaka_controller',
                x: p.x, 
                y: p.y,
                plan: flightPlan,     
                nextIdx: 0,           
                speed: 0.8, // Flight Speed
                trail: [{x:p.x, y:p.y}], 
                dmg: s.dmg,
                scale: s.scale
            });
        } else {
            // Fallback: Shoot straight if no enemies
            let vx=0, vy=0;
            if(p.dir===0) vy=-0.8; else if(p.dir===1) vx=0.8; else if(p.dir===2) vy=0.8; else vx=-0.8;
            S.ents.push({type:'proj', x:p.x, y:p.y, vx, vy, dmg:s.dmg, color:'#fff', effect:s, life:30, icon:'üèπ'});
        }
        return;
    }







    if(s.heal) { p.hp=Math.min(p.maxHp, p.hp+s.heal); part(p.x, p.y, '#0f0', 30, 4); return; }
    if(s.speed) { p.buffs.speed=now+4000; part(p.x, p.y, '#ff0', 30, 4); return; }

    if(s.proj) {
        let cnt = s.count || 1; 
        for(let i=0; i<cnt; i++) {
            let angOffset = (i - (cnt-1)/2) * (s.spread || 0);
            let vx=0, vy=0;
            if(p.dir===0) { vx=angOffset; vy=-s.spd; }
            if(p.dir===1) { vx=s.spd; vy=angOffset; }
            if(p.dir===2) { vx=angOffset; vy=s.spd; }
            if(p.dir===3) { vx=-s.spd; vy=angOffset; }
            S.ents.push({type:'proj', x:p.x, y:p.y, vx, vy, dmg:s.dmg, color:s.color, effect:s, life:60});
        }
    } else {
        let ang = p.dir===0?-1.57:p.dir===1?0:p.dir===2?1.57:3.14;
        S.vfxs.push({type:'slash', x:p.x+Math.cos(ang), y:p.y+Math.sin(ang), life:10, ang});
        S.ents.forEach(e => {
            if(e.type==='mob' && !e.dead && Math.hypot(e.x-p.x, e.y-p.y) < s.range) {
                let midX = (p.x+e.x)/2, midY = (p.y+e.y)/2;
                if(!solid(midX, midY)) hit(e, s.dmg, s);
            }
        });
    }
}

function kill(m) {
    if(m.dead) return; 
    m.dead = true;
    S.p.xp += m.boss?800:50;
    S.p.killLog.push(m.name);
    
    // --- INSIDE kill(m) ---

    // Replace the Chaos Titan block with this clean version:
    if(m.name === "Chaos Titan") {
       // 1. Basic Unlocks
       unlockRegion9();      
       S.bossDead = true;    
       drawStyledMinimap();  
       S.audio.playBGM('adventure_new'); 

       // 2. SPAWN NOAH (The Artist)
       addNPC("Noah", 32, 24, "My dear friend, I am blessed to have met you. Thank you for being part of my story. I‚Äôm not sure when our paths will cross again, but I am so thankful to have had you in my life.", 'M');
       S.ents[S.ents.length-1].moveTimer = Infinity; 

       // 3. SPAWN DORIS (The Teacher)
       addNPC("Doris", 36, 24, "When you travel, you need to have your passport ready. Just the same, one day when you leave this world, you need to have your passport to heaven ready.", 'F');
       S.ents[S.ents.length-1].moveTimer = Infinity; 

       // 4. SYSTEM MESSAGE
       showChat("SYSTEM", "The path is open. Follow the signs on the floor.");
   }




   // --- STOP REPLACING HERE ---

    if(S.p.xp >= S.p.lvl*100) { 
        S.p.xp=0; S.p.lvl++; S.p.maxHp+=50; S.p.hp=S.p.maxHp; 
        S.audio.play('lvlup'); 
        popText(S.p.x, S.p.y, "LEVEL UP!", "#ffd700"); 
    }
    let q = QUESTS[S.qStep];
    if(q && q.type==='kill' && q.target===m.name) nextQuest();
}







function interact() {
    // 1. Find targets (NPCs, Items, Objects)
    let targets = S.ents.filter(e => (e.type==='npc'||e.type==='item'||e.type==='obj') && Math.hypot(e.x-S.p.x, e.y-S.p.y)<2.5);
    
    // 2. Sort by distance (closest first)
    targets.sort((a,b) => Math.hypot(a.x-S.p.x, a.y-S.p.y) - Math.hypot(b.x-S.p.x, b.y-S.p.y));
    
    // 3. Pick the closest one
    let t = targets[0];

    if(t) {

        // ============================================
        // A. NPC INTERACTION
        // ============================================
        if(t.type==='npc') {
            S.audio.play('npc'); 
            showChat(t.name, t.txt);
            
            let q = QUESTS[S.qStep];
            
            // 1. Normal Quest Progress
            if(q && q.type==='talk' && q.target===t.name) {
                nextQuest();
            }

            // 2. Epilogue Logic
            if(S.bossDead && (t.name === "Noah" || t.name === "Doris")) {
                 S.epilogueSeen = true; 
                 
                 // JUST THE HEART (No text)
                 popText(S.p.x, S.p.y, "‚ù§Ô∏è", "#ff69b4");
                 
                 // Sound removed (It will use the standard 'npc' sound played above)
            }
        }

        // ============================================
        // B. ITEM INTERACTION (Herbs, etc.) <--- THIS WAS MISSING
        // ============================================
        if(t.type==='item') {
            // Play Sound
            S.audio.play('item_found'); 
            
            // Remove Item & Show Text
            t.dead = true; 
            popText(S.p.x, S.p.y, "+ "+t.name, "#0ff");
            
            // Check Quest Progress
            let q = QUESTS[S.qStep];
            if(q && q.type==='collect' && q.target===t.name) {
                S.qProg++;
                if(S.qProg >= q.count) nextQuest();
            }
        }

        // ============================================
        // C. OBJECT INTERACTION (Tablets, Portals)
        // ============================================
        if(t.type==='obj') {
             // 1. Portal Logic
             if(t.name === 'PortalHome') {
                 S.p.x = 25; S.p.y = 35; // Teleport to Village
                 S.audio.play('tele');
                 showChat("SYSTEM", "Warping to Village...");
                 return;
             }

             // 2. Tablet / Statue Logic
             if(!t.active) {
                S.audio.play('item_found');
                t.active = true;
                if(t.msg) showChat("SYSTEM", t.msg);
                
                popText(S.p.x, S.p.y, "DONE", "#f0f");
                part(t.x, t.y, '#fff', 20);
                
                let q = QUESTS[S.qStep];
                if(q && q.type==='activate' && q.target===t.name) {
                    S.qProg++;
                    if(S.qProg >= q.count) nextQuest();
                }
            }
        }
    }
}












function nextQuest() {
    popText(S.p.x, S.p.y, "OBJECTIVE COMPLETE", "#0f0");
    S.qStep++; S.qProg=0;
    
    if(S.qStep > 4) updateUI(); 

    let prevQ = QUESTS[S.qStep-1];
    if(prevQ && prevQ.lock !== undefined) unlockGate(prevQ.lock);
    
    // ONLY PLAY SOUND IF THE WHOLE GAME IS WON
    if(S.qStep >= QUESTS.length) {
        S.audio.play('victory'); 
        document.getElementById('win-screen').style.display='flex';
    } else {
        // SILENT for normal steps
        // The interaction sound handled in interact() is enough
        
        let nq = QUESTS[S.qStep];
        if(nq.type==='kill' && S.p.killLog.includes(nq.target)) nextQuest();
    }
}
function unlockGate(id) {
    let removed = false;
    for(let i=0; i<S.map.length; i++) {
        let lock = S.locks.find(l => l.x === i%MAP_S && l.y === Math.floor(i/MAP_S) && l.id === id);
        if(lock) {
            S.map[i] = T.BRIDGE; 
            part(lock.x, lock.y, '#0ff', 10, 3);
            removed = true;
        }
    }
    if(removed) { 
        showChat("SYSTEM", "A path opens..."); 
        S.shake = 5; 
        S.audio.play('gate'); // <--- Logic added here
    }
}

let eggClicks = 0;
function eggTitle() {
    eggClicks++;
    if(eggClicks===5) showChat("Noah", "Stop clicking the title and play the game!");
}




//////////////////
 function draw() {
    // 1. Delegate to Farm
    if (S.world === 'farm') {
        Region9Farm.draw();
        return; 
    }

    // 2. RESET GRAPHICS (Fixes "Weird Art" on return)
    ctx.shadowBlur = 0;
    ctx.shadowColor = 'transparent';
    ctx.globalAlpha = 1.0;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';
    ctx.lineWidth = 1;
    ctx.font = "10px sans-serif"; // Reset font size

    // =======================================

    if(isNaN(S.cam.x)) S.cam.x = 0; 
    ctx.fillStyle='#000'; ctx.fillRect(0,0,cvs.width,cvs.height);



    
    let sx = (Math.random()-0.5)*(S.shake||0), sy = (Math.random()-0.5)*(S.shake||0);
    let cx = Math.floor(S.cam.x/TILE), cy = Math.floor(S.cam.y/TILE);
    let ex = cx + (cvs.width/TILE)+2, ey = cy + (cvs.height/TILE)+2;

    for(let y=cy; y<ey; y++) for(let x=cx; x<ex; x++) {
        if(x<0||y<0||x>=MAP_S||y>=MAP_S) continue;
        let t = S.map[y*MAP_S+x];
        let px = Math.floor(x*TILE-S.cam.x+sx), py = Math.floor(y*TILE-S.cam.y+sy);
        
        ctx.fillStyle = Object.values(C)[t];
        if(t===T.LOCK) ctx.fillStyle = `rgba(200,0,0,${0.7+Math.sin(Date.now()/200)*0.3})`;
        ctx.fillRect(px, py, TILE, TILE);
        
        // --- FARM DRAW DELEGATION (Plots, Fences, Debris) ---
        if(S.world === 'farm' && farmSys) {
             farmSys.draw(ctx, S.cam.x, S.cam.y);
        }
        
        if(t===T.BLOCK && S.wordData[y*MAP_S+x]) {
             let e = S.wordData[y*MAP_S+x];
             let cTop='#eee', cSide='#bbb', cTxt='#111';
             if(e.theme === 'blue') { cTop='#2980b9'; cSide='#1a5276'; cTxt='#fff'; }
             if(e.theme === 'red') { cTop='#c0392b'; cSide='#922b21'; cTxt='#fff'; }
             if(e.theme === 'gold') { cTop='#f1c40f'; cSide='#b7950b'; cTxt='#000'; }
             if(e.theme === 'purple') { cTop='#8e44ad'; cSide='#6c3483'; cTxt='#fff'; }
             if(e.theme === 'green') { cTop='#27ae60'; cSide='#1e8449'; cTxt='#fff'; }
             
             ctx.fillStyle = cTop; 
             ctx.fillRect(px, py, 50, 50); 
             ctx.strokeStyle = cSide; ctx.lineWidth = 4;
             ctx.strokeRect(px+2, py+2, 46, 46);

             ctx.font = 'bold 30px monospace'; 
             ctx.fillStyle = cTxt; ctx.textAlign='center'; 
             ctx.fillText(e.char, px+25, py+35);
             ctx.textAlign='left';
        }
        
        if(t===T.ROAD) { 
            ctx.fillStyle='#607d8b'; ctx.fillRect(px, py, TILE, TILE); 
        }

        ctx.fillStyle='rgba(0,0,0,0.1)';
        if(t===T.GRASS && (x+y)%3==0) ctx.fillRect(px+10, py+10, 6, 6);
        if(t===T.SAND && (x*y)%5==0) ctx.fillRect(px+20, py+30, 4, 4);
        if(t===T.RUINS) { ctx.strokeStyle='#555'; ctx.strokeRect(px+2, py+2, 46, 46); }
        if(t===T.BEDROCK) ctx.fillRect(px, py, TILE, TILE);
    }
    



// ===============================================
    // START: FLOOR TEXT (BOSS ARENA SIGNS)
    // ===============================================
    // ===============================================
    // START: FLOOR TEXT (BIG, GLOWING, FADING)
    // ===============================================
    if(S.bossDead && S.world === 'main') {
        ctx.save();
        ctx.textAlign = "center";
        
        // Helper to draw text that fades when you pass it
        const paintFloorText = (txt, subTxt, tx, ty, color, fadeThreshold, fadeDir) => {
            // --- 1. FADE LOGIC ---
            // fadeDir: 1 = Fade when walking Right (East)
            // fadeDir: -1 = Fade when walking Left (West)
            let alpha = 1.0;
            
            // If fading Right (Farm Path): Fade out as we step onto the bridge (x > 80)
            if (fadeDir === 1 && S.p.x > fadeThreshold) {
                alpha = Math.max(0, 1 - (S.p.x - fadeThreshold) / 4);
            }
            // If fading Left (Return Path): Fade out as we walk away (x < 68)
            else if (fadeDir === -1 && S.p.x < fadeThreshold) {
                alpha = Math.max(0, 1 - (fadeThreshold - S.p.x) / 4);
            }

            if (alpha <= 0.05) return; // Don't draw if invisible
            ctx.globalAlpha = alpha;

            // Coords
            let px = Math.floor(tx * TILE - S.cam.x + sx) + (TILE/2);
            let py = Math.floor(ty * TILE - S.cam.y + sy);

            // --- 2. GLOW EFFECT ---
            // Pulsing glow size
            let glowSize = 15 + Math.sin(Date.now() / 200) * 5; 

            // DRAW MAIN TITLE (Big)
            ctx.font = "bold 60px 'VT323', monospace"; 
            ctx.shadowColor = color; 
            ctx.shadowBlur = glowSize;
            ctx.fillStyle = color;
            ctx.fillText(txt, px, py);

            // DRAW SUBTITLE (Smaller, White)
            ctx.font = "bold 30px 'VT323', monospace";
            ctx.shadowColor = "#fff"; 
            ctx.shadowBlur = 10;
            ctx.fillStyle = "#fff";
            ctx.fillText(subTxt, px, py + 35);
        };

        // 1. Text pointing West (Left) -> Back to Village
        // Fades out if you walk Left past x=68
        paintFloorText("‚¨Ö RETURN", "TO VILLAGE", 65, 125, "#ff5252", 68, -1);

        // 2. Text pointing East (Right) -> To Farm
        // Fades out if you walk Right past x=80 (Onto the bridge)
        paintFloorText("REGION 9 ‚û°", "THE FARM", 85, 125, "#ffd700", 80, 1);

        ctx.restore();
    }
    // ===============================================
    // ===============================================
    // END: FLOOR TEXT
    // ===============================================







// --- START OF TECTONIC RUPTURE (FLOOR LAYER) ---
// --- START OF TECTONIC RUPTURE (FLOOR LAYER) ---
    S.vfxs.forEach(v => {
        
        // ============================================
        // 1. NEW: DARK VOID RIPPLE (Under Player)
        // ============================================
      // ============================================
        // 1. ADVANCED VOID FLUID (Floor Layer)
        // ============================================
        if(v.type === 'void_ripple') {
            let x = Math.floor(v.x*TILE - S.cam.x + sx);
            let y = Math.floor(v.y*TILE - S.cam.y + sy);
            
            // Manual life decrement for floor layer
            v.life--; 
            if(v.life <= 0) v.dead = true;

            let cx = x + 25; 
            let cy = y + 42; 
            let prog = 1 - (v.life / v.maxLife); // 0.0 -> 1.0

            ctx.save();
            ctx.translate(cx, cy);
            ctx.scale(1.0, 0.6); // Flatten perspective

            // --- ANIMATION VARS ---
            // Fade: Fast in, Stay, Slow out
            let alpha = 1.0;
            if(prog < 0.1) alpha = prog / 0.1; 
            else if(prog > 0.8) alpha = 1 - ((prog - 0.8) / 0.2);
            
            ctx.globalAlpha = alpha * 0.95;

            // Time variable for wobbly movement
            let time = Date.now() / 120; 

            // --- A. THE BLACK POOL (Organic Shape) ---
            // It grows to max size then slowly shrinks
            let growCurve = Math.sin(Math.pow(prog, 0.6) * Math.PI); 
            let baseR = 10 + (growCurve * 55); 

            ctx.fillStyle = '#000'; // Void Black
            ctx.shadowBlur = 25; 
            ctx.shadowColor = '#4a148c'; // Deep Purple Glow

            ctx.beginPath();
            for(let a=0; a<=Math.PI*2; a+=0.1) {
                // FLUID MATH: Combine 2 sine waves for "blob" effect
                let distortion = Math.sin(a * 3 + time) * 4 + 
                                 Math.cos(a * 7 - time*1.5) * 3;
                
                let r = baseR + distortion;
                if(r < 0) r = 0;

                let px = Math.cos(a) * r;
                let py = Math.sin(a) * r;
                if(a===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();

            // --- B. THE SURFACE RIPPLES (Light Reflection) ---
            ctx.shadowBlur = 0;
            ctx.lineWidth = 2;
            
            // Generate 3 organic rings
            for(let i=0; i<3; i++) {
                // Rings loop continuously while the pool is alive
                let ringPhase = (prog * 3 + (i * 0.35)) % 1; 
                let ringR = ringPhase * baseR; // Expand outward
                let ringAlpha = (1 - ringPhase) * alpha; // Fade as they expand

                ctx.strokeStyle = `rgba(224, 86, 253, ${ringAlpha})`; // Neon Violet

                ctx.beginPath();
                for(let a=0; a<=Math.PI*2; a+=0.1) {
                    // Different distortion speed per ring for "churning" look
                    let wave = Math.sin(a * 5 + time + (i*2)) * (3 + i) + 
                               Math.cos(a * 10 - time*2) * 2;
                    
                    let r = ringR + wave;
                    if(r < 0) r = 0; 
                    // Don't draw outside the pool (clipping logic simplified)
                    if(r > baseR + 2) r = baseR + 2; 

                    let px = Math.cos(a) * r;
                    let py = Math.sin(a) * r;
                    if(a===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.stroke();
            }

            ctx.restore();
            ctx.globalAlpha = 1.0;
            ctx.shadowBlur = 0;
            return; // Done drawing this VFX
        }
        // ============================================


        // Only draw the cracks here... (Existing Tectonic logic follows)
        if(v.type !== 'tectonic_rupture') return;

        let x = Math.floor(v.x*TILE - S.cam.x + sx), y = Math.floor(v.y*TILE - S.cam.y + sy);
        
        // We decrement life here because we are handling this specific VFX early
        v.life--; 
        if(v.life <= 0) v.dead = true;

        let prog = 1 - (v.life / v.maxLife);
        let cx = x + 25; 
        let cy = y + 40; // Center at feet

        // Color Logic: White -> Lava Red -> Dark Rock
        let color, glow, width;
        if(prog < 0.2) {
             color = '#ffffff'; glow = '#ffffff'; width = 8; 
        } else if(prog < 0.7) {
             color = '#d50000'; glow = '#ff3d00'; width = 6; 
        } else {
             color = '#3e2723'; glow = null; width = 4; 
        }

        ctx.save();
        ctx.translate(cx, cy);

        v.cracks.forEach(path => {
            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            
            // Expand the crack outward over time
            let visibleLen = Math.floor(path.length * (prog * 5)); 
            if(visibleLen > path.length) visibleLen = path.length;

            for(let i=1; i<visibleLen; i++) {
                ctx.lineTo(path[i].x, path[i].y);
            }
            
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            // 1. Outer Glow (Lava lighting)
            if(glow) {
                ctx.shadowBlur = 15;
                ctx.shadowColor = glow;
                ctx.strokeStyle = glow;
                ctx.lineWidth = width + 4;
                ctx.globalAlpha = 0.6;
                ctx.stroke();
                ctx.globalAlpha = 1.0;
            }

            // 2. Main Crack Body
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.shadowBlur = 0;
            ctx.stroke();

            // 3. Inner Heat Streak (Bright Yellow Center)
            if(prog > 0.1 && prog < 0.6) {
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        });
        ctx.restore();
    });
    // --- END OF TECTONIC RUPTURE ---







    S.ents.forEach(e => {
        if(e.kind === 'Fountain' || e.kind === 'Healing Crystal') {
            let px = Math.floor(e.x*TILE - S.cam.x + sx);
            let py = Math.floor(e.y*TILE - S.cam.y + sy);
            let w = e.w * TILE, h = e.h * TILE;
            
            ctx.fillStyle = `rgba(0, 255, 0, 0.2)`; 
            ctx.beginPath(); 
            ctx.arc(px+w/2, py+h/2, 200, 0, 6.28); 
            ctx.fill();
            
            ctx.shadowBlur = 20; ctx.shadowColor='#0f0';
            ctx.strokeStyle = `rgba(0, 255, 0, 0.8)`; ctx.lineWidth=3; ctx.stroke();
            ctx.shadowBlur = 0;
        }
        
        if(e.type === 'tornado') {
             let px = Math.floor(e.x*TILE - S.cam.x + sx);
             let py = Math.floor(e.y*TILE - S.cam.y + sy);
             
             // Smooth fade out
             let alpha = e.life < 20 ? e.life / 20 : 1.0;

             ctx.save();
             ctx.translate(px+25, py+40); 
             ctx.scale(e.scale, e.scale); // Uses the updated large scale
             ctx.globalAlpha = alpha;

             let time = Date.now() / 40; 

             // --- LAYER 1: THE CORE (Gradient Funnel) ---
             // No more stacked rings. One solid shape.
             let grd = ctx.createLinearGradient(-15, -80, 15, 0);
             grd.addColorStop(0, "rgba(200, 230, 255, 0.1)"); // Top (Transparent)
             grd.addColorStop(0.5, "rgba(180, 210, 230, 0.6)"); // Mid (Thick)
             grd.addColorStop(1, "rgba(100, 130, 150, 0.2)"); // Bottom (Dusty)

             ctx.fillStyle = grd;
             ctx.beginPath();
             ctx.moveTo(-25, -90); // Top Left (Wide)
             ctx.quadraticCurveTo(0, -40, -5, 0); // Curve to bottom
             ctx.lineTo(5, 0);
             ctx.quadraticCurveTo(0, -40, 25, -90); // Top Right (Wide)
             ctx.closePath();
             ctx.fill();

             // --- LAYER 2: THE WIND STREAKS (Fast Spinning Lines) ---
             // Draw curved lines wrapping around the funnel
             ctx.lineWidth = 3;
             ctx.lineCap = 'round';
             
             for(let i=0; i<6; i++) {
                 // Calculate a "height" for this streak
                 let h = (time * 2 + i * 20) % 90; // Moves UP the tornado
                 let yPos = -h;
                 
                 // Width depends on height (Wider at top)
                 let w = 8 + (h * 0.3);
                 
                 // Sine wave for X to simulate 3D rotation
                 let rot = time * 0.5 + i;
                 let xOff = Math.sin(rot) * w;
                 let zDepth = Math.cos(rot); // Is it in front or behind?

                 // Only draw if "in front" (simple 3D effect) or transparent
                 ctx.strokeStyle = `rgba(255, 255, 255, ${0.4 + zDepth*0.3})`; // Brighter when in front
                 
                 ctx.beginPath();
                 ctx.moveTo(xOff - 5, yPos); 
                 ctx.quadraticCurveTo(xOff, yPos - 2, xOff + 5, yPos);
                 ctx.stroke();
             }

             // --- LAYER 3: DEBRIS (Rocks & Dust) ---
             if(e.debris) {
                 e.debris.forEach(d => {
                     let dAng = d.angle + time * d.speed;
                     
                     // 3D Orbit Logic
                     let rx = Math.cos(dAng) * d.dist;
                     let ry = Math.sin(dAng) * (d.dist * 0.3) - d.yOff; // Elliptical & Vertical spread
                     
                     // Z-Index Sorting (Simple):
                     // If moving "back" (sin > 0), draw dark. If "front", draw light.
                     let isFront = Math.sin(dAng) > 0;
                     
                     ctx.fillStyle = isFront ? '#795548' : '#3e2723';
                     
                     ctx.beginPath();
                     ctx.arc(rx, ry, d.size, 0, 6.28);
                     ctx.fill();
                 });
             }
             
             // --- LAYER 4: GROUND DUST ---
             ctx.fillStyle = 'rgba(100, 100, 100, 0.3)';
             ctx.beginPath();
             ctx.ellipse(0, 0, 20 + Math.sin(time)*5, 8, 0, 0, 6.28);
             ctx.fill();

             ctx.restore();
             ctx.globalAlpha = 1.0;
        }





        if(e.type === 'web') {
             let px = Math.floor(e.x*TILE - S.cam.x + sx);
             let py = Math.floor(e.y*TILE - S.cam.y + sy);
             ctx.strokeStyle='#eee'; ctx.lineWidth=2;
             ctx.globalAlpha = e.life/80;
             ctx.beginPath(); 
             for(let i=0; i<8; i++) {
                 let ang = i/8 * 6.28;
                 ctx.moveTo(px+25,py+25); ctx.lineTo(px+25+Math.cos(ang)*80, py+25+Math.sin(ang)*80);
             }
             ctx.stroke();
             ctx.beginPath(); ctx.arc(px+25,py+25, 40, 0, 6.28); ctx.stroke();
             ctx.beginPath(); ctx.arc(px+25,py+25, 70, 0, 6.28); ctx.stroke();
             ctx.globalAlpha=1;
        }

        if(e.type==='vfx_proj') {
            let px = Math.floor(e.x*TILE - S.cam.x + sx);
            let py = Math.floor(e.y*TILE - S.cam.y + sy);
            let alpha = e.life / e.maxLife;
            ctx.strokeStyle = `rgba(224, 255, 255, ${alpha})`; 
            ctx.shadowColor = '#00e5ff'; ctx.shadowBlur = 15 * alpha; ctx.lineWidth = 3;
            ctx.save();
            ctx.translate(px+25, py+25);
            ctx.rotate((Date.now() / 100) + e.id); 
            ctx.beginPath();
            let points = 50; 
            for(let j=0; j<points; j++) {
                let prog = j / points; 
                let angle = prog * (Math.PI * 2 * 3);
                let r = (prog * 25) * e.scale; 
                let rx = Math.cos(angle) * r;
                let ry = Math.sin(angle) * r;
                if(j===0) ctx.moveTo(rx, ry); else ctx.lineTo(rx, ry);
            }
            ctx.stroke();
            ctx.restore();
            ctx.shadowBlur = 0;
        }
    });

    S.parts.forEach((p,i) => {
        p.x+=p.vx; p.y+=p.vy;
        p.life--;
        let px = p.x*TILE-S.cam.x+sx, py = p.y*TILE-S.cam.y+sy;
        
        













if(p.type.includes('icon_')) {
             let icon = p.type.split('_')[1];
             let scale = p.s/10;
             ctx.font = (20*scale)+"px sans-serif";
             ctx.fillText(icon, px, py);
        } 
        else if(p.type === 'heal_txt') {
             ctx.font = "bold 30px monospace";
             ctx.strokeStyle = "white"; ctx.lineWidth=3;
             ctx.strokeText("+", px, py);
             ctx.fillStyle = "#ff69b4"; 
             ctx.fillText("+", px, py);
        }
        else {
            ctx.fillStyle=p.c; 
            if(p.type==='cloud') ctx.globalAlpha = p.life/50;
            














if(p.type==='bubble') {
                ctx.strokeStyle=p.c; ctx.lineWidth=2; ctx.globalAlpha=p.life/20;
                ctx.beginPath(); ctx.arc(px+p.s/2, py+p.s/2, p.s, 0, 6.28); ctx.stroke(); 
            } else {
                ctx.beginPath(); ctx.arc(px+p.s/2, py+p.s/2, p.s, 0, 6.28); ctx.fill(); 
            }
        }
        ctx.globalAlpha = 1;
        if(p.life<=0) p.dead = true;
    });
    S.parts = S.parts.filter(p => !p.dead);
    // MANDATORY FIX: Cap particles to prevent crash
    if(S.parts.length > 500) S.parts.splice(0, 50);

    let list = [...S.ents];
    if(S.p.class) list.push({type:'p', x:S.p.x, y:S.p.y, h:1});









    
    list = list.filter(e => !e.dead && e.type!=='zone' && e.type!=='web' && e.type!=='vfx_proj' && e.type!=='tile_block');
    
    list.sort((a,b) => (a.y + (a.h||1)) - (b.y + (b.h||1)));

    list.forEach(e => {
        try {
            let x = Math.floor(e.x*TILE - S.cam.x + sx), y = Math.floor(e.y*TILE - S.cam.y + sy);
            if(x<-300 || x>cvs.width+200 || y<-300 || y>cvs.height+200) return;

            if(e.type==='env') drawEnv(x,y,e.kind); 
            else if(e.type==='struct') drawStruct(x,y,e);
            else if(e.type==='p') drawHero(x,y);
            else if(e.type==='mob') drawMob(x,y,e);



else if(e.type === 'shadow_hand') {
            // 1. Calculate Screen Positions
            let shakeX = (typeof sx !== 'undefined') ? sx : 0;
            let shakeY = (typeof sy !== 'undefined') ? sy : 0;
            
            let handScreenX = Math.floor(e.x * TILE - S.cam.x + shakeX);
            let handScreenY = Math.floor(e.y * TILE - S.cam.y + shakeY);
            
            let playerScreenX = Math.floor(S.p.x * TILE - S.cam.x + shakeX);
            let playerScreenY = Math.floor(S.p.y * TILE - S.cam.y + shakeY);

            // Anchor points
            let startX = playerScreenX + 25;
            let startY = playerScreenY + 40; 
            let endX = handScreenX + 25;
            let endY = handScreenY + 25;

            // 2. DRAW THE ARM (Tentacle connecting Player to Hand)
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            
            let midX = (startX + endX) / 2;
            let midY = (startY + endY) / 2;
            // Subtle wiggle for the arm
            let armWiggle = Math.sin(Date.now() / 200) * 15;
            
            ctx.quadraticCurveTo(midX + armWiggle, midY - armWiggle, endX, endY);
            
            ctx.lineCap = 'round';
            ctx.shadowBlur = 10; ctx.shadowColor = '#d500f9';
            ctx.strokeStyle = '#000'; 
            ctx.lineWidth = 5; 
            ctx.stroke();

            // 3. DRAW THE HUMAN-LIKE HAND
            ctx.shadowBlur = 0;
            ctx.save();
            ctx.translate(endX, endY);
            
            // Calculate angle so hand points away from player (towards target)
            // We rotate +90deg (PI/2) because we draw the hand pointing UP (-Y)
            let angle = Math.atan2(endY - startY, endX - startX);
            ctx.rotate(angle + Math.PI/2);

            let scale = e.state === 1 ? 0.9 : 1.2; 
            ctx.scale(scale, scale);

            // Common Style
            ctx.fillStyle = '#000';       
            ctx.strokeStyle = '#4a148c';  // Dark Purple Outline
            ctx.lineWidth = 1;

            // --- DRAW PALM ---
            ctx.beginPath();
            // A rounded rectangle shape for the palm
            ctx.moveTo(-8, 0); 
            ctx.lineTo(-10, -15); // Left side
            ctx.quadraticCurveTo(0, -18, 10, -15); // Top of palm (knuckles)
            ctx.lineTo(8, 0); // Right side
            ctx.quadraticCurveTo(0, 5, -8, 0); // Wrist
            ctx.fill();
            ctx.stroke();

            // --- DRAW FINGERS ---
            // Finger Config: [OffsetX, OffsetY, Length, Width]
            let fingers = [
                { x: -12, y: -8, l: 10, w: 3.5, thumb: true }, // Thumb
                { x: -7,  y: -15, l: 18, w: 3.0 }, // Index
                { x: -2,  y: -16, l: 20, w: 3.0 }, // Middle
                { x: 3,   y: -15, l: 17, w: 2.8 }, // Ring
                { x: 8,   y: -13, l: 12, w: 2.5 }  // Pinky
            ];

            fingers.forEach((f, i) => {
                ctx.beginPath();
                
                // Animate wiggle (only if not grabbing)
                let wiggle = (e.state === 0) ? Math.sin((Date.now()/100) + i) * 2 : 0;
                
                // Base of finger
                let bx = f.x;
                let by = f.y;
                
                if(f.thumb) {
                    // Draw Thumb (Angled out)
                    if(e.state === 0) { // Open
                        ctx.moveTo(bx, by);
                        ctx.quadraticCurveTo(bx - 8, by - 5, bx - 10 + wiggle, by - f.l);
                        ctx.lineTo(bx - 3, by - f.l + 3);
                    } else { // Clenched
                        ctx.moveTo(bx, by);
                        ctx.quadraticCurveTo(bx - 5, by - 2, bx, by - 5);
                    }
                } else {
                    // Draw Fingers
                    if(e.state === 0) {
                        // === REACHING (Straightish) ===
                        ctx.moveTo(bx, by);
                        // Curve slightly inward for a "grasping" look
                        let tipX = bx + (wiggle * 0.5); 
                        let tipY = by - f.l;
                        
                        ctx.quadraticCurveTo(bx - 2, by - (f.l/2), tipX, tipY); // Left edge
                        ctx.lineTo(tipX + f.w, tipY + 2); // Tip
                        ctx.quadraticCurveTo(bx + f.w + 1, by - (f.l/2), bx + f.w, by + 2); // Right edge
                    } else {
                        // === GRABBING (Curled/Fist) ===
                        // Draw them short and curled inward
                        ctx.moveTo(bx, by);
                        ctx.quadraticCurveTo(bx - 2, by - 5, bx + 1, by + 2); 
                        // Draw a "knuckle" bump to show fist
                        ctx.arc(bx + 2, by - 2, 3, 0, Math.PI*2);
                    }
                }
                ctx.fill();
                ctx.stroke();
            });

            ctx.restore();
        }






            else if(e.type==='npc') drawNPC(x,y,e);



            else if(e.type==='farm_mob') drawFarmMob(x,y,e);
            else if(e.type==='item') { 
                 let b = Math.sin(Date.now()/300)*5;
                 ctx.shadowColor='#fff'; ctx.shadowBlur=10; ctx.font="30px s"; 
                 ctx.fillText(e.name.includes('Herb')?'üåø':'üìú', x+10, y+35+b); 
                 ctx.shadowBlur=0;
            }
            else if(e.type==='obj') {
                ctx.fillStyle = e.active ? '#0ff' : '#666';
                if(e.name==='Tablet') {
                     let baseC = e.active ? '#f1c40f' : '#555';
                     let innerC = e.active ? '#f39c12' : '#333';
                     ctx.fillStyle=baseC; ctx.fillRect(x, y, 100, 100); 
                     ctx.fillStyle=innerC; ctx.fillRect(x+10, y+10, 80, 80);
                     ctx.fillStyle= e.active ? '#fff' : '#ffd700'; 
                     ctx.fillRect(x+20, y+20, 60, 5); ctx.fillRect(x+20, y+40, 60, 5);
                     ctx.fillRect(x+20, y+60, 60, 5);
                } else if (e.name==='Frozen Friend') {
                    ctx.fillStyle = e.active ? 'rgba(0,0,0,0)' : 'rgba(173, 216, 230, 0.6)';
                    if(!e.active) {
                        ctx.fillRect(x, y, 90, 90); 
                        ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.strokeRect(x,y,90,90);
                        ctx.fillStyle='#000'; ctx.globalAlpha=0.5;
                        ctx.beginPath(); ctx.arc(x+45, y+35, 15, 0, 6.28); ctx.fill();
                        ctx.fillRect(x+30, y+50, 30, 30);
                        ctx.globalAlpha=1.0;
                        ctx.fillStyle='#fff'; ctx.fillRect(x+10, y+10, 5, 5); ctx.fillRect(x+70, y+80, 5, 5);
                    }
                }
            }
            // --- PASTE THIS NEW PROJECTILE BLOCK ---
           else if(e.type==='proj') { 
                




                // 1. PHOENIX FIRE (Skill Z)
                if(e.vfxType === 'phoenix_fire') {
                    let angle = Math.atan2(e.vy, e.vx);
                    let time = (Date.now() - e.birth) / 50; 

                    if(Math.random() < 0.4) {
                         part(e.x - e.vx*2, e.y - e.vy*2, Math.random()>.5?'#ff5722':'#ffff00', 1, 3+Math.random()*4, 'cloud');
                    }

                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(angle); 
                    
                    // Huge Scale
                    ctx.scale(2.5, 2.5); 

                    // Draw Helix Tail
                    ctx.lineCap = 'round';
                    for(let k=0; k<2; k++) {
                        let phase = k === 0 ? 0 : Math.PI; 
                        let tailLen = 45;
                        
                        ctx.beginPath();
                        for(let i=0; i<tailLen; i+=2) {
                            let progress = i / tailLen; 
                            let thickness = (1 - progress) * 6;
                            let wave = Math.sin(i * 0.2 - time + phase) * (5 + (i*0.2)); 
                            
                            let px = -i; 
                            let py = wave; 

                            if(i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                            
                            let c = progress < 0.2 ? '#fff' : (progress < 0.5 ? '#ffeb3b' : '#ff5722');
                            ctx.strokeStyle = c;
                            ctx.lineWidth = thickness;
                            ctx.stroke();
                            ctx.beginPath(); ctx.moveTo(px, py); 
                        }
                        ctx.stroke();
                    }

                    // Draw Core
                    ctx.shadowColor = '#ff3d00'; ctx.shadowBlur = 20;
                    ctx.fillStyle = '#fff';
                    ctx.beginPath(); ctx.ellipse(5, 0, 8, 5, 0, 0, 6.28); ctx.fill();

                    ctx.fillStyle = 'rgba(255, 152, 0, 0.6)';
                    ctx.beginPath(); ctx.arc(0, 0, 12, 0, 6.28); ctx.fill();

                    ctx.shadowBlur = 0;
                    ctx.restore();
                } 
                
                // 2. STANDARD PROJECTILES (Stars, Arrows, etc.)
                else {
                    ctx.shadowColor = e.color; ctx.shadowBlur = 15;
                    ctx.fillStyle = e.color; 
                    let sc = e.scale || 1.0;
                    
                    // --- ARROWS ---
                    if(e.icon==='üèπ') {
                        let ang = Math.atan2(e.vy, e.vx);
                        ctx.save(); ctx.translate(x+25, y+25); ctx.rotate(ang); ctx.scale(sc, sc);
                        ctx.beginPath(); ctx.moveTo(-10,0); ctx.lineTo(10,0); ctx.lineTo(5,-5); ctx.moveTo(10,0); ctx.lineTo(5,5);
                        ctx.lineWidth=3; ctx.strokeStyle='#fff'; ctx.stroke(); ctx.restore();
                    } 
                    // --- FALLING STARS (Mage Skill N) ---
                    else if(e.star) {
                        ctx.save();
                        ctx.translate(x, y);
                        // Add a slow spin to the star
                        ctx.rotate(Date.now() / 200); 
                        
                        // We use the helper function, but we need to account for the translation
                        // Since we translated to (x,y), we draw at (0,0)
                        drawStar(ctx, 0, 0, 5, 20 * sc, 10 * sc);
                        
                        ctx.restore();
                    } 
                    // --- POISON FLASK ---
                    else if(e.icon === 'üß™') {
                        ctx.save();
                        ctx.translate(x, y);
                        ctx.rotate(Date.now()/150); // Spin animation
                        ctx.font = "24px sans-serif";
                        ctx.shadowBlur=0; 
                        ctx.fillText('üß™', -12, 8);
                        ctx.restore();
                    }
                    // --- DEFAULT ORBS ---
                    else {
                        ctx.beginPath(); ctx.arc(x, y, e.effect.icon==='‚òÑÔ∏è'?20:8, 0, 6.28); ctx.fill(); 
                    }
                    ctx.shadowBlur=0;
                }
            }
            // ---------------------------------------






// --- PASTE THIS HERE ---
            else if(e.type === 'yaka_controller') {
               let px = Math.floor(e.x*TILE - S.cam.x + sx);
               let py = Math.floor(e.y*TILE - S.cam.y + sy);
               
               // 1. Draw Trail (The Web)
               if(e.trail.length > 1) {
                   ctx.beginPath();
                   let t0 = e.trail[0];
                   ctx.moveTo(Math.floor(t0.x*TILE-S.cam.x+sx)+25, Math.floor(t0.y*TILE-S.cam.y+sy)+25);
                   for(let i=1; i<e.trail.length; i++) {
                       let t = e.trail[i];
                       ctx.lineTo(Math.floor(t.x*TILE-S.cam.x+sx)+25, Math.floor(t.y*TILE-S.cam.y+sy)+25);
                   }
                   ctx.lineTo(px+25, py+25); // Connect to current position
                   
                   ctx.lineCap = 'round';
                   ctx.lineJoin = 'round';
                   
                   // 1. OUTER GLOW (The Aura) - Massive Blur
                   ctx.shadowColor = '#ff0000'; 
                   ctx.shadowBlur = 25; // Big glow
                   ctx.strokeStyle = 'rgba(255, 0, 0, 0.4)'; 
                   ctx.lineWidth = 12; // Very thick faint outer line
                   ctx.stroke();

                   // 2. INNER GLOW (The Energy)
                   ctx.shadowColor = '#ff1744'; 
                   ctx.shadowBlur = 10;
                   ctx.strokeStyle = '#ff1744'; 
                   ctx.lineWidth = 6; // Thick solid red line
                   ctx.stroke();
                   
                   // 3. CORE (The Hot Center)
                   ctx.shadowBlur = 0;
                   ctx.strokeStyle = '#fff'; 
                   ctx.lineWidth = 2; // Bright white core
                   ctx.stroke();
               }

               // 2. Draw Arrow Head (The Needle)
               ctx.save();
               ctx.translate(px+25, py+25);
               let target = e.plan[e.nextIdx];
               if(target) ctx.rotate(Math.atan2(target.y - e.y, target.x - e.x));
               
               ctx.fillStyle = '#fff';
               ctx.shadowColor = '#f00'; ctx.shadowBlur = 10;
               ctx.beginPath();
               ctx.moveTo(10, 0); ctx.lineTo(-8, -4); ctx.lineTo(-4, 0); ctx.lineTo(-8, 4); 
               ctx.fill();
               ctx.restore();
               ctx.shadowBlur = 0;
            }




        } catch(err) { }
    });

    






S.vfxs.forEach((v, i) => {
        // --- ADD THIS LINE ---
        if(v.type === 'tectonic_rupture') return; // SKIP! We already drew it on the floor.
        // ---------------------

        let x = Math.floor(v.x*TILE - S.cam.x + sx), y = Math.floor(v.y*TILE - S.cam.y + sy);
        v.life--;
        
        ctx.shadowBlur=15; ctx.shadowColor='#fff';
        // ... rest of the existing code ...









// ============================================
        // WARRIOR VFX: SWORD SWEEP (Z Skill)
        // ============================================
        // ============================================
        // WARRIOR VFX: SWORD SWEEP (Z Skill)
        // ============================================
      // ============================================
        // WARRIOR VFX: SWORD SWEEP (Z Skill)
        // ============================================
      // ============================================
        // WARRIOR VFX: SWORD SWEEP (Z Skill)
        // ============================================
        if(v.type === 'sword_sweep') {
             let x = Math.floor(v.x*TILE - S.cam.x + sx);
             let y = Math.floor(v.y*TILE - S.cam.y + sy);
             let prog = 1 - (v.life / v.maxLife);
             
             let baseAng = (v.dir === 0 ? -1.57 : v.dir === 1 ? 0 : v.dir === 2 ? 1.57 : 3.14);
             let swingArc = 1.5; 
             let currentRot = baseAng + ( (prog - 0.5) * swingArc * v.side );

             ctx.save();
             ctx.translate(x+25, y+25);
             ctx.scale(v.scale, v.scale); 
             ctx.rotate(currentRot);

             ctx.beginPath();
             ctx.arc(0, 0, 45, -0.5, 0.5, false);
             ctx.arc(0, 0, 25, 0.5, -0.5, true);
             ctx.closePath();

             ctx.fillStyle = v.color;
             ctx.globalAlpha = 0.8 * (1 - prog);
             ctx.fill();
             
             ctx.strokeStyle = v.color;
             // Use custom width if defined, else default to 2
             ctx.lineWidth = v.width || 2; 
             ctx.shadowColor = v.color;
             ctx.shadowBlur = 15;
             ctx.stroke();

             ctx.restore();
             ctx.globalAlpha = 1.0;
             ctx.shadowBlur = 0;
        }

        // ============================================
        // NEW: SHIELD AURA (The "Red Part")
        // ============================================
        if(v.type === 'shield_aura') {
             let x = Math.floor(v.x*TILE - S.cam.x + sx);
             let y = Math.floor(v.y*TILE - S.cam.y + sy);
             let prog = 1 - (v.life / v.maxLife);
             
             // Move with the shield
             let dist = prog * 60; 
             let dx=0, dy=0;
             if(v.dir===0) dy = -dist;
             if(v.dir===1) dx = dist;
             if(v.dir===2) dy = dist;
             if(v.dir===3) dx = -dist;

             ctx.save();
             ctx.translate(x+25+dx, y+25+dy);
             
             // Rotate to face direction
             let rot = 0;
             if(v.dir===1) rot = 1.57; if(v.dir===2) rot = 3.14; if(v.dir===3) rot = -1.57;
             ctx.rotate(rot);

             // Scale grows slightly
             let scale = 1.0 + (prog * 0.5); 
             ctx.scale(scale, scale);

             // FADE: Stay visible until end
             let alpha = prog > 0.8 ? (1 - ((prog-0.8)/0.2)) : 0.6;
             ctx.globalAlpha = alpha;

             // --- DRAW RED SHOCKWAVE CONE ---
             ctx.fillStyle = 'rgba(231, 76, 60, 0.4)'; // Red
             ctx.shadowColor = '#c0392b'; ctx.shadowBlur = 20;
             
             ctx.beginPath();
             // Draw a cone shape behind the shield
             ctx.moveTo(0, 0); 
             ctx.lineTo(-35, 40); // Wide bottom left
             ctx.quadraticCurveTo(0, 50, 35, 40); // Curved bottom
             ctx.lineTo(0, 0);
             ctx.fill();
             
             // Add "Rage" spikes
             ctx.strokeStyle = '#e74c3c';
             ctx.lineWidth = 3;
             ctx.beginPath();
             ctx.moveTo(0, 0); ctx.lineTo(-20 + Math.random()*10, 35);
             ctx.moveTo(0, 0); ctx.lineTo(20 - Math.random()*10, 35);
             ctx.stroke();

             ctx.restore();
             ctx.globalAlpha = 1.0;
             ctx.shadowBlur = 0;
        }

        // ============================================
        // WARRIOR VFX: SHIELD SLAM (The Shield Itself)
        // ============================================
        if(v.type === 'shield_slam') {
             let x = Math.floor(v.x*TILE - S.cam.x + sx);
             let y = Math.floor(v.y*TILE - S.cam.y + sy);
             let prog = 1 - (v.life / v.maxLife);
             let dist = prog * 60; 
             let dx=0, dy=0;
             if(v.dir===0) dy = -dist; if(v.dir===1) dx = dist; if(v.dir===2) dy = dist; if(v.dir===3) dx = -dist;

             ctx.save();
             ctx.translate(x+25+dx, y+25+dy);
             let rot = 0;
             if(v.dir===1) rot = 1.57; if(v.dir===2) rot = 3.14; if(v.dir===3) rot = -1.57;
             ctx.rotate(rot);
             let scale = 1.2 + (prog * 0.3); 
             ctx.scale(scale, scale);
             
             let alpha = prog > 0.8 ? (1 - ((prog-0.8)/0.2)) : 1.0;
             ctx.globalAlpha = alpha;
             ctx.shadowColor = '#ffd700'; ctx.shadowBlur = 25;
             ctx.fillStyle = 'rgba(255, 215, 0, 0.65)'; 
             ctx.strokeStyle = '#fff'; ctx.lineWidth = 4;

             ctx.beginPath();
             ctx.moveTo(0, -35); ctx.lineTo(28, -20); ctx.lineTo(22, 15);  
             ctx.lineTo(0, 40); ctx.lineTo(-22, 15); ctx.lineTo(-28, -20);
             ctx.closePath();
             ctx.fill(); ctx.stroke();

             ctx.beginPath();
             ctx.moveTo(0, -28); ctx.lineTo(0, 30);
             ctx.moveTo(-18, -5); ctx.lineTo(18, -5);
             ctx.lineWidth = 3; ctx.strokeStyle = '#fff'; ctx.stroke();
             
             ctx.restore();
             ctx.globalAlpha = 1.0;
             ctx.shadowBlur = 0;
        }












if(v.type === 'glacial_spike') {
            let cx = x + 25;
            let cy = y + 40;

            let prog = 1 - (v.life / v.maxLife);
            let growth = prog < 0.2 ? (prog / 0.2) : 1.0; 
            let alpha = prog > 0.8 ? (1 - (prog-0.8)/0.2) : 1.0;

            ctx.save();
            ctx.translate(cx, cy);
            ctx.scale(v.scale * growth, v.scale * growth); 
            ctx.globalAlpha = alpha;

            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.beginPath(); ctx.ellipse(0, 0, 15, 6, 0, 0, 6.28); ctx.fill();

            // ELSA COLORS (Brighter Cyan/White)
            let cDark = '#00bcd4';   // Cyan Dark
            let cMid = '#4dd0e1';    // Cyan Mid
            let cLight = '#e0f7fa';  // Ice White
            
            // Spike Body
            ctx.beginPath();
            ctx.fillStyle = cDark; ctx.moveTo(-10, 0); ctx.lineTo(0, -50); ctx.lineTo(10, 0); ctx.fill();
            ctx.fillStyle = cMid;  ctx.moveTo(0, 0);   ctx.lineTo(0, -50); ctx.lineTo(10, 0); ctx.fill();
            ctx.fillStyle = cLight; ctx.moveTo(-5, -10); ctx.lineTo(0, -50); ctx.lineTo(0, -10); ctx.fill();

            // Side Spikes
            ctx.fillStyle = cMid;
            ctx.beginPath(); ctx.moveTo(-12, 0); ctx.lineTo(-18, -15); ctx.lineTo(-6, 0); ctx.fill();
            ctx.beginPath(); ctx.moveTo(8, 0);   ctx.lineTo(14, -20);  ctx.lineTo(4, 0);  ctx.fill();

            // Magical Glow (Optimized: No ShadowBlur)
            // 1. Draw a faint blue circle behind to fake the glow
            ctx.fillStyle = 'rgba(0, 229, 255, 0.4)'; 
            ctx.beginPath(); ctx.arc(0, -40, 8, 0, 6.28); ctx.fill();
            
            // 2. Draw the white core
            ctx.fillStyle = '#fff';
            ctx.fillRect(-2, -45, 4, 10);

            ctx.restore();
            ctx.globalAlpha = 1.0;
        }











if(v.type === 'explosion_cloud') {
            let cx = x + 25;
            let cy = y + 40;

            v.puffs.forEach(p => {
                // Physics: Move & Slow Down
                p.x += p.vx; 
                p.y += p.vy;
                p.vx *= 0.85; // Air resistance
                p.vy *= 0.85;

                let prog = 1 - (v.life / v.maxLife);
                let alpha = 1.0;
                
                // COLOR: White -> Yellow -> Orange -> Red -> Black
                let color;
                if(prog < 0.15) {
                    color = '#ffffff'; // FLASH
                } else if(prog < 0.30) {
                    color = '#fff176'; // YELLOW
                } else if(prog < 0.50) {
                    color = '#ff9800'; // ORANGE
                } else if(prog < 0.70) {
                    color = '#bf360c'; // BURNT RED
                } else {
                    color = '#212121'; // SMOKE
                    alpha = v.life / (v.maxLife * 0.3); 
                }

                ctx.save();
                ctx.translate(cx + p.x, cy + p.y - (prog * 60)); // Mushroom cloud rise
                
                // Grow: 0.5x to 4.0x size
                let scale = 0.5 + (prog * 3.5); 
                ctx.scale(scale, scale);
                ctx.rotate(p.rot); 

                ctx.globalAlpha = alpha;
                ctx.fillStyle = color;
                
                // Draw Cluster (Lumpy Shape)
                ctx.beginPath();
                ctx.arc(0, 0, p.r, 0, 6.28);
                ctx.arc(p.r*0.6, p.r*0.4, p.r*0.7, 0, 6.28);
                ctx.arc(-p.r*0.5, p.r*0.5, p.r*0.6, 0, 6.28);
                ctx.arc(0, -p.r*0.6, p.r*0.8, 0, 6.28);
                ctx.fill();

                // Inner Glow (Hot Core)
                if(prog < 0.4) {
                    ctx.shadowColor = color;
                    ctx.shadowBlur = 15;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }

                ctx.restore();
            });
            ctx.globalAlpha = 1.0;
        }









if(v.type === 'tectonic_rupture') {
            let cx = x + 25; // Player Center
            let cy = y + 40; 

            let prog = 1 - (v.life / v.maxLife);
            
            // --- COLOR CYCLE ---
            // 0% - 20%: Blinding White (Opening)
            // 20% - 60%: Glowing Orange/Red (Lava)
            // 60% - 100%: Dark Brown/Black (Cooling Rock)
            let color, glow, width;
            
            if(prog < 0.2) {
                color = '#ffffff'; glow = '#fff'; width = 8;
            } else if(prog < 0.6) {
                color = '#ff3d00'; glow = '#ffab91'; width = 6;
            } else {
                color = '#3e2723'; glow = null; width = 4;
            }

            ctx.save();
            ctx.translate(cx, cy);
            
            // Draw all 8 Cracks
            v.cracks.forEach(path => {
                ctx.beginPath();
                ctx.moveTo(path[0].x, path[0].y);
                
                // Draw line points based on progress (Cracks expand outward)
                let visibleLength = Math.floor(path.length * (prog * 3)); // Expand fast
                if(visibleLength > path.length) visibleLength = path.length;

                for(let i=1; i<visibleLength; i++) {
                    ctx.lineTo(path[i].x, path[i].y);
                }

                // Style
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                // 1. Outer Glow (Magma Light)
                if(glow) {
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = glow;
                }
                
                // 2. The Crack Stroke
                ctx.strokeStyle = color;
                ctx.lineWidth = width;
                ctx.stroke();

                // 3. Inner Core (White hot center for Lava phase)
                if(prog > 0.2 && prog < 0.6) {
                    ctx.shadowBlur = 0;
                    ctx.strokeStyle = '#ffeb3b'; // Yellow center
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            });
            
            ctx.restore();
            ctx.shadowBlur = 0; // Reset
        }











        ctx.shadowBlur=15; ctx.shadowColor='#fff';
        if(v.type==='slash') {
            ctx.strokeStyle='#fff'; ctx.lineWidth=6; 
            ctx.beginPath(); ctx.arc(x+25, y+25, 40, v.ang-0.5, v.ang+0.5); ctx.stroke();
        }
                
        // --- NEW: VOID NUKE (Destructive Visual) ---
        if(v.type === 'void_nuke') {
             ctx.save();
             ctx.translate(x+25, y+25); // Center on enemy
             
             let prog = 1 - (v.life / v.maxLife); // 0.0 to 1.0
             let explodeSize = 1 + (prog * 4.0);  // Expands fast!
             
             ctx.scale(explodeSize, explodeSize);
             ctx.rotate(v.rot + (prog * 2)); // Spin it!

             // Layer 1: The Initial White Flash (Disruptive)
             if(prog < 0.2) {
                 ctx.globalAlpha = 1 - (prog * 5);
                 ctx.fillStyle = '#fff';
                 ctx.beginPath(); ctx.arc(0,0, 20, 0, 6.28); ctx.fill();
                 ctx.globalAlpha = 1.0;
             }

             // Layer 2: The Black Void Star (The Tear)
             ctx.fillStyle = '#000';
             ctx.beginPath();
             for(let i=0; i<8; i++) { // Draw a jagged 8-point star
                 let angle = (i/8)*6.28;
                 let r = (i%2===0) ? 15 : 5; // Spike vs Core
                 ctx.lineTo(Math.cos(angle)*r, Math.sin(angle)*r);
             }
             ctx.fill();

             // Layer 3: Neon Purple Outline (The Energy)
             ctx.strokeStyle = '#d500f9';
             ctx.lineWidth = 2;
             ctx.shadowColor = '#d500f9'; ctx.shadowBlur = 20;
             ctx.stroke();

             // Layer 4: Chaos Lightning
             if(v.life % 2 === 0) {
                 ctx.strokeStyle = '#fff';
                 ctx.lineWidth = 1;
                 ctx.beginPath();
                 ctx.moveTo(0,0);
                 ctx.lineTo((Math.random()-0.5)*40, (Math.random()-0.5)*40);
                 ctx.stroke();
             }

             ctx.restore();
             ctx.shadowBlur = 0;
        }



        if(v.type==='quake') {
            ctx.strokeStyle='#8d6e63'; ctx.lineWidth=4; ctx.beginPath(); ctx.moveTo(x,y+25); ctx.lineTo(x+50,y+25); ctx.stroke();
        }
        
        // DRAW YAKA ARROW (The Glowing Thread)
       // DRAW YAKA ARROW (The Glowing Web)
        if(v.type === 'yaka_trail') {
             let px = Math.floor(v.x*TILE - S.cam.x + sx); // Not used but keeps syntax safe
             
             // Fade out logic
             let alpha = v.life / v.maxLife;
             
             ctx.beginPath();
             if(v.trail.length > 0) {
                 let t0 = v.trail[0];
                 ctx.moveTo(Math.floor(t0.x*TILE-S.cam.x+sx)+25, Math.floor(t0.y*TILE-S.cam.y+sy)+25);
                 for(let i=1; i<v.trail.length; i++) {
                     let t = v.trail[i];
                     ctx.lineTo(Math.floor(t.x*TILE-S.cam.x+sx)+25, Math.floor(t.y*TILE-S.cam.y+sy)+25);
                 }
             }

             ctx.lineCap = 'round'; ctx.lineJoin = 'round';

             // Draw the lingering web
             ctx.globalAlpha = alpha;
             
             // Thick Glow
             ctx.shadowColor = '#ff0000'; ctx.shadowBlur = 20;
             ctx.strokeStyle = '#d50000'; ctx.lineWidth = 8; 
             ctx.stroke();
             
             // Core
             ctx.shadowBlur = 0;
             ctx.strokeStyle = '#ff8a80'; ctx.lineWidth = 2;
             ctx.stroke();

             ctx.globalAlpha = 1.0;
        }





        ctx.shadowBlur=0;




        // 3. MARK DEAD
        if(v.life<=0) v.dead = true;
    });

    // 4. CLEANUP (Double Check this line is here!)
    S.vfxs = S.vfxs.filter(v => !v.dead);
    // ------------------------------------------




    // --- PASTE THIS NEW BLOCK ---
    // --- LIGHTNING DRAWING ---
    S.lighting.forEach((l, idx) => {
        l.life--; 
        let progress = l.life / l.maxLife; // 1.0 to 0.0
        
        ctx.lineCap = 'round'; 
        ctx.lineJoin = 'round';

        if(l.type === 'heavy_storm') {
            // FADE OUT LOGIC: Flash bright at start, fade slowly
            let alpha = progress; 
            
            // 1. MASSIVE OUTER GLOW (The Atmosphere)
            ctx.shadowColor = '#00e5ff'; 
            ctx.shadowBlur = 40 * alpha; // Huge blur
            ctx.strokeStyle = `rgba(0, 229, 255, ${alpha * 0.5})`;
            ctx.lineWidth = 18; // Very Thick
            ctx.beginPath(); 
            l.segs.forEach((s,i) => { if(i==0) ctx.moveTo(s.x,s.y); else ctx.lineTo(s.x,s.y); }); 
            ctx.stroke();

            // 2. INNER CORE (The Electricity)
            ctx.shadowBlur = 10;
            ctx.strokeStyle = `rgba(224, 255, 255, ${alpha})`;
            ctx.lineWidth = 6;
            ctx.beginPath(); 
            l.segs.forEach((s,i) => { if(i==0) ctx.moveTo(s.x,s.y); else ctx.lineTo(s.x,s.y); }); 
            ctx.stroke();

            // 3. PURE WHITE CENTER (The Hot Plasma)
            ctx.shadowBlur = 0;
            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.lineWidth = 3;
            ctx.stroke();

            // 4. DRAW BRANCHES (Thinner, erratic)
            ctx.strokeStyle = `rgba(0, 229, 255, ${alpha * 0.6})`;
            ctx.lineWidth = 2;
            l.branches.forEach(branch => {
                ctx.beginPath();
                branch.forEach((s,i) => { if(i==0) ctx.moveTo(s.x,s.y); else ctx.lineTo(s.x,s.y); });
                ctx.stroke();
            });

        } else {
            // Old fallback style
            ctx.strokeStyle=`rgba(150,220,255,${l.life/10})`; 
            ctx.lineWidth=3; ctx.shadowBlur=10; ctx.shadowColor='#fff';
            ctx.beginPath(); 
            l.segs.forEach((s,i) => { if(i==0) ctx.moveTo(s.x,s.y); else ctx.lineTo(s.x,s.y); }); 
            ctx.stroke();
        }

        if(l.life<=0) l.dead = true;
    });
    S.lighting = S.lighting.filter(l => !l.dead);
    ctx.shadowBlur=0;
    // ----------------------------






    S.shockwaves.forEach((w, i) => {
        w.r += 0.3; w.a -= 0.05; ctx.strokeStyle=`rgba(255,100,0,${w.a})`; ctx.lineWidth=5; ctx.shadowColor=w.c||'#fff'; ctx.shadowBlur=10;
        ctx.beginPath(); ctx.arc(w.x*TILE-S.cam.x+sx, w.y*TILE-S.cam.y+sy, w.r*TILE, 0, 6.28); ctx.stroke(); ctx.shadowBlur=0;
        if(w.a<=0) w.dead = true;
    });
    S.shockwaves = S.shockwaves.filter(w => !w.dead);
}

function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
    let rot = Math.PI / 2 * 3;
    let x = cx, y = cy;
    let step = Math.PI / spikes;
    ctx.beginPath(); ctx.moveTo(cx, cy - outerRadius);
    for (let i = 0; i < spikes; i++) {
        x = cx + Math.cos(rot) * outerRadius; y = cy + Math.sin(rot) * outerRadius; ctx.lineTo(x, y); rot += step;
        x = cx + Math.cos(rot) * innerRadius; y = cy + Math.sin(rot) * innerRadius; ctx.lineTo(x, y); rot += step;
    }
    ctx.lineTo(cx, cy - outerRadius);
    ctx.closePath(); ctx.fill();
}






function drawHero(x, y) {
    let dir = S.p.dir; // 0:Up, 1:Right, 2:Down, 3:Left
    let cls = S.p.class || 'warrior';
    
    // Animation Vars
    let isMoving = (S.input.keys['arrowup']||S.input.keys['arrowdown']||S.input.keys['arrowleft']||S.input.keys['arrowright']);
    let tick = Date.now() / 150;
    let bob = Math.sin(tick) * 1.5;
    let walk = isMoving ? Math.sin(tick * 3) : 0;
    
    // Setup Context
    ctx.save();
    
    // 1. POSITION & SCALE (1.3x)
    ctx.translate(x + 25, y + 42); 
    ctx.scale(1.3, 1.3); 
    
    // MIRROR FOR LEFT VIEW
    if (dir === 3) ctx.scale(-1, 1); 

    // --- COLOR PALETTES ---
    let cSkin='#ffe0bd', cEye='#111';
    let cMain, cSec, cAcc, cDark, cBoot, cHair, cHigh;

    if(cls === 'warrior') { 
        cMain='#eceff1'; cSec='#1565c0'; cAcc='#ffd700'; cDark='#455a64'; cBoot='#37474f';
        cHair='#3e2723'; cHigh='#ffffff'; // Metallic Highlight
    } else if(cls === 'mage') { 
        cMain='#4527a0'; cSec='#7c4dff'; cAcc='#00e5ff'; cDark='#311b92'; cBoot='#1a1a1a';
        cHair='#ffe082'; cHigh='#b388ff'; // Magic Sheen
    } else { 
        // RANGER
        cMain='#37474f'; cSec='#ff6d00'; cAcc='#ffeb3b'; cDark='#263238'; cBoot='#212121';
        cHair='#5d4037'; cHigh='#ff9e80'; // Cloth Texture
    }

    // --- RIDING LIFT ---
    let lift = S.p.isRiding ? 12 : 0;
    ctx.translate(0, -lift);

    // --- DROP SHADOW ---
    if(!S.p.isRiding) {
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(0, 0, 10, 4, 0, 0, 6.28); ctx.fill();
    }

    // ============================
    // 1. DRAW LEGS (Boots with Soles)
    // ============================
    const drawBoot = (bx, by, w, h, color) => {
        ctx.fillStyle = color; ctx.fillRect(bx, by, w, h); // Boot Body
        ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.fillRect(bx, by + h - 2, w, 2); // Sole/Shadow
    };

    if(dir === 0 || dir === 2) { 
        drawBoot(-7, -12 + (walk*2), 5, 12, cBoot);
        drawBoot(2, -12 - (walk*2), 5, 12, cBoot);
    } else { 
        drawBoot(-4 + (walk*4), -12, 6, 12, cDark); // Back Leg (Shadowed)
        drawBoot(-4 - (walk*4), -13, 6, 12, cBoot); // Front Leg
    }

    // ============================
    // 2. DRAW BODY
    // ============================
    let bodyY = -24 + bob;
    
    // BACK CAPE/HAIR (Layer 1)
    if(dir !== 2) { 
        if(cls === 'mage') {
            ctx.fillStyle = cHair;
            if(dir === 0) ctx.fillRect(-11, bodyY-12, 22, 22); 
            else ctx.fillRect(-8, bodyY-8, 10, 18); 
        }
        ctx.fillStyle = (cls==='mage') ? cDark : cSec; 
        if(dir === 0) ctx.fillRect(-10, bodyY+10, 20, 10);
        else ctx.fillRect(-9, bodyY+8, 6, 10);
    }

    // TORSO
    ctx.fillStyle = cMain;
    if(dir === 0 || dir === 2) { 
        ctx.fillRect(-9, bodyY, 18, 14); 
        ctx.fillStyle = cDark; ctx.fillRect(-9, bodyY+10, 18, 3); // Belt
        
        // Neck Shadow (Depth)
        ctx.fillStyle = 'rgba(0,0,0,0.15)'; ctx.fillRect(-5, bodyY, 10, 2);

        if(dir === 2) { // Front Details
            if(cls==='warrior') { // Armor Plate
                ctx.fillStyle = cSec; ctx.fillRect(-3, bodyY+2, 6, 8); ctx.fillRect(-6, bodyY+4, 12, 4);
                // Shine
                ctx.fillStyle = 'rgba(255,255,255,0.4)'; ctx.fillRect(-3, bodyY+2, 2, 2);
            }
            if(cls==='mage') { ctx.fillStyle = cAcc; ctx.fillRect(-2, bodyY, 4, 14); }
            if(cls==='rogue') { ctx.fillStyle = '#5d4037'; ctx.beginPath(); ctx.moveTo(-9, bodyY); ctx.lineTo(-6, bodyY); ctx.lineTo(9, bodyY+14); ctx.lineTo(6, bodyY+14); ctx.fill(); }
        }
    } else { // Side
        ctx.fillRect(-6, bodyY, 12, 14);
        ctx.fillStyle = cDark; ctx.fillRect(-6, bodyY+10, 12, 3);
    }

    // ============================
    // 3. DRAW HEAD & HAIR
    // ============================
    let headY = bodyY - 14;
    
    // A. FACE SKIN (Hidden on Back View)
    if(dir !== 0) {
        ctx.fillStyle = cSkin;
        ctx.fillRect(-8, headY, 16, 16);
    }

    // B. HAIR
    ctx.fillStyle = cHair;
    if (cls === 'warrior') {
        if (dir === 2) { ctx.fillRect(-9, headY, 2, 8); ctx.fillRect(7, headY, 2, 8); }
        else if (dir === 0) { ctx.fillRect(-8, headY+2, 16, 12); } 
        else { ctx.fillRect(-8, headY, 14, 14); }
    } 
    else if (cls === 'mage') {
        if (dir === 2) { ctx.fillRect(-11, headY-2, 5, 20); ctx.fillRect(6, headY-2, 5, 20); } 
        else if (dir !== 0) { ctx.fillRect(-6, headY-2, 12, 20); }
    } 
    else { // ROGUE
        if (dir === 2) { 
            ctx.fillRect(-9, headY, 18, 4); ctx.fillRect(-8, headY+2, 3, 3); 
            ctx.fillRect(0, headY+2, 4, 3); ctx.fillRect(6, headY+2, 2, 4);
            ctx.fillRect(-9, headY, 2, 10); ctx.fillRect(7, headY, 2, 10);
        } else if (dir === 0) { ctx.fillRect(-9, headY-2, 18, 16); } 
        else { ctx.fillRect(-8, headY, 14, 4); ctx.fillRect(-10, headY+4, 6, 10); }
    }

    // C. HAT / HELMET (With Shading)
    if(cls === 'warrior') { 
        ctx.fillStyle = cMain; 
        ctx.fillRect(-9, headY-5, 18, 10); 
        // Metallic Shine on Helmet
        ctx.fillStyle = cHigh; ctx.fillRect(-6, headY-4, 4, 3);

        if(dir === 0 || dir === 2) { 
            ctx.fillStyle = cMain; ctx.fillRect(-10, headY-2, 2, 14); ctx.fillRect(8, headY-2, 2, 14); 
            if(dir === 0) ctx.fillRect(-5, headY+2, 10, 8); 
        } else { ctx.fillStyle = cMain; ctx.fillRect(0, headY-2, 9, 14); }
        
        // Crest
        ctx.fillStyle = cSec; 
        if (dir !== 1 && dir !== 3) ctx.fillRect(-2, headY-8, 4, 16); 
        else { ctx.fillRect(-9, headY-8, 18, 4); ctx.fillRect(7, headY-8, 4, 16); }
    } 
    else if(cls === 'mage') { 
        ctx.fillStyle = cMain; 
        ctx.beginPath(); ctx.moveTo(-14, headY); ctx.lineTo(14, headY); ctx.lineTo(0, headY-20); ctx.fill();
        ctx.fillStyle = 'rgba(0,0,0,0.2)'; // Brim Shadow
        ctx.fillRect(-14, headY, 28, 2);
        ctx.fillStyle = cAcc; ctx.fillRect(-8, headY-2, 16, 2);
    } 
    else { // ROGUE CAP
        ctx.fillStyle = cSec; 
        if(dir === 2 || dir === 0) { 
            ctx.beginPath(); ctx.ellipse(0, headY, 10, 4, 0, 0, 6.28); ctx.fill();
            ctx.beginPath(); ctx.ellipse(0, headY-3, 9, 5, 0, 0, 6.28); ctx.fill();
            ctx.fillStyle = 'rgba(255,255,255,0.2)'; ctx.beginPath(); ctx.ellipse(-3, headY-5, 4, 2, 0, 0, 6.28); ctx.fill(); // Highlight
            ctx.strokeStyle = cAcc; ctx.lineWidth = 3; 
            ctx.beginPath(); ctx.moveTo(4, headY-3); ctx.quadraticCurveTo(12, headY-12, 8, headY-18); ctx.stroke();
        } else { 
            ctx.beginPath(); ctx.moveTo(-10, headY); ctx.lineTo(10, headY); ctx.lineTo(6, headY-5); ctx.lineTo(-8, headY-5); ctx.fill();
            ctx.strokeStyle = cAcc; ctx.lineWidth = 3; 
            ctx.beginPath(); ctx.moveTo(0, headY-3); ctx.quadraticCurveTo(-10, headY-8, -14, headY-2); ctx.stroke();
        }
    }

    // D. EYES
    if(dir !== 0) {
        ctx.fillStyle = (cls==='mage') ? cAcc : cEye; // Mage has Glowing Eyes?
        if(dir === 2) { ctx.fillRect(-5, headY+6, 3, 3); ctx.fillRect(2, headY+6, 3, 3); } 
        else { ctx.fillRect(3, headY+6, 3, 3); }
    }

    // E. SCARF
    if(cls === 'rogue') {
        ctx.fillStyle = cAcc; 
        if(dir===2 || dir===0) ctx.fillRect(-7, headY+12, 14, 4);
        else ctx.fillRect(-4, headY+12, 8, 4);
    }

    // ============================
    // 4. DRAW ARMS
    // ============================
    ctx.fillStyle = cMain;
    
    if(dir === 0 || dir === 2) { 
        let armS = (dir===2 && isMoving) ? -walk : 0;
        ctx.fillStyle = (cls==='warrior') ? cMain : cSec; 
        ctx.fillRect(-14, bodyY, 5, 5); ctx.fillRect(9, bodyY, 5, 5);

        // Arm Shadow (Under Shoulder)
        ctx.fillStyle = (cls==='warrior') ? cDark : cMain; 
        ctx.fillRect(-13, bodyY+3+armS, 4, 2); ctx.fillRect(9, bodyY+3-armS, 4, 2);

        ctx.fillStyle = (cls==='warrior') ? cMain : cSkin; 
        ctx.fillRect(-13, bodyY + 5 + armS, 4, 7); 
        ctx.fillRect(9, bodyY + 5 - armS, 4, 7);
        
        ctx.fillStyle = (cls==='mage') ? cSkin : cDark; 
        ctx.fillRect(-13, bodyY + 10 + armS, 4, 3);
        ctx.fillRect(9, bodyY + 10 - armS, 4, 3);

    } else { 
        ctx.fillStyle = (cls==='warrior') ? cMain : cSec;
        ctx.fillRect((walk*3), bodyY + 2, 4, 6);
        ctx.fillStyle = (cls==='warrior') ? cMain : cSkin;
        ctx.fillRect((walk*3), bodyY + 8, 4, 6);
    }

    // ============================
    // 5. CARRY ITEM
    // ============================
    if (S.carry && S.carry.icon) {
        ctx.save();
        if (dir === 3) ctx.scale(-1, 1); 
        ctx.font = "20px serif"; ctx.fillStyle = "#fff"; ctx.textAlign = "center";
        ctx.shadowColor="#000"; ctx.shadowBlur=4;
        ctx.fillText(S.carry.icon, 0, headY - 20 + bob);
        ctx.shadowBlur=0;
        ctx.restore();
    }

    ctx.restore();
}







function drawFarmMob(x, y, m) {
    let b = Math.sin(Date.now()/200)*2;
    if(m.name === 'Dog') {
        ctx.fillStyle = '#8d6e63';
        ctx.fillRect(x+15, y+25-b, 20, 15); // Body
        ctx.fillRect(x+30, y+20-b, 12, 12); // Head
        ctx.fillStyle = '#3e2723';
        ctx.fillRect(x+15, y+40-b, 5, 5); ctx.fillRect(x+30, y+40-b, 5, 5);
        ctx.fillRect(x+40, y+25-b, 3, 5); // Ear
    }
    if(m.name === 'Chicken') {
        ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(x+25, y+30-b, 10, 0, 6.28); ctx.fill();
        ctx.fillStyle = '#f39c12'; ctx.beginPath(); ctx.moveTo(x+35,y+28-b); ctx.lineTo(x+40,y+30-b); ctx.lineTo(x+35,y+32-b); ctx.fill();
        ctx.fillStyle = '#c0392b'; ctx.fillRect(x+22, y+20-b, 6, 4);
    }
    if(m.name === 'Cow') {
        ctx.fillStyle = '#fff'; ctx.fillRect(x+10, y+20-b, 30, 20);
        ctx.fillStyle = '#000'; ctx.fillRect(x+15, y+25-b, 10, 8); ctx.fillRect(x+30, y+22-b, 5, 5);
        ctx.fillStyle = '#fff'; ctx.fillRect(x+38, y+20-b, 10, 15); // Head
        ctx.fillStyle = '#000'; ctx.fillRect(x+38, y+20-b, 3, 15); ctx.fillRect(x+46, y+22-b, 2, 2);
    }
}

function drawMob(x, y, m) {
    let b = Math.sin(Date.now()/200)*3;
    // REPLACE THE OLD "let sc = ..." LINE WITH THIS BLOCK:
    let sc = 1.4; // Default size for normal mobs
    if (m.boss) {
        if (m.name === "Chaos Titan") sc = 3.0;       // Titan is Huge
        else if (m.name.includes("Dragon")) sc = 2.6; // Dragon is Very Big
        else if (m.name.includes("Hydra")) sc = 2.6;  // Hydra is Very Big
        else sc = 1.8;                                // Other bosses (Slime/Scorpion)
    }
     
    
    // Scale from the center of the tile
    ctx.save(); ctx.translate(x+25, y+25); ctx.scale(sc, sc); ctx.translate(-(x+25), -(y+25));

    let tint = null;
    const now = Date.now();
    if(m.status.burn > now) tint = '#e74c3c'; 
    else if(m.status.freeze > now) tint = '#4fc3f7'; 
    else if(m.status.poison > 0) tint = '#8e44ad'; 

    // --- HEALTH BAR & NAME (Moved UP to avoid overlapping the higher sprites) ---
    ctx.fillStyle='#fff'; ctx.font='bold 12px monospace'; ctx.strokeStyle='#000'; ctx.lineWidth=2;
    ctx.strokeText(m.name, x, y-35+b); ctx.fillText(m.name, x, y-35+b);
    ctx.fillStyle = '#444'; ctx.fillRect(x, y-30+b, 50, 6);
    ctx.fillStyle = '#e74c3c'; ctx.fillRect(x, y-30+b, 50*(Math.max(0,m.hp)/m.maxHp), 6);

    const drawEyes = (ex, ey) => {
        ctx.fillStyle='#000'; ctx.fillRect(ex, ey, 4, 4);
        ctx.fillStyle='#fff'; ctx.fillRect(ex+1, ey+1, 2, 2); 
    };

    // --- MONSTER DRAWING (All Y coordinates shifted -10px to -15px) ---

    if(m.name.includes('Boar')) {
        ctx.fillStyle= tint || '#8d6e63'; 
        ctx.beginPath(); ctx.ellipse(x+25, y+20-b, 20, 14, 0, 0, 6.28); ctx.fill(); // y+30 -> y+20
        ctx.fillStyle='#fff'; ctx.beginPath(); ctx.moveTo(x+10,y+25-b); ctx.lineTo(x+5,y+15-b); ctx.lineTo(x+15,y+20-b); ctx.fill(); 
        ctx.fillStyle= tint || '#3e2723'; 
        ctx.fillRect(x+15,y+28-b,4,6); ctx.fillRect(x+30,y+28-b,4,6); 
        drawEyes(x+12, y+18-b);
    }
    else if(m.name==='Ent') {
        ctx.fillStyle= tint || '#4e342e'; 
        ctx.fillRect(x+15, y+0-b, 20, 35); // y+10 -> y+0
        ctx.fillStyle= tint || '#76d7c4'; 
        ctx.beginPath(); ctx.arc(x+15, y-5-b, 10, 0, 6.28); ctx.fill(); 
        ctx.beginPath(); ctx.arc(x+35, y-5-b, 10, 0, 6.28); ctx.fill();
        ctx.beginPath(); ctx.arc(x+25, y-15-b, 12, 0, 6.28); ctx.fill();
        ctx.fillStyle = '#ffeb3b';
        ctx.fillRect(x+20, y+10-b, 3, 3); ctx.fillRect(x+26, y+10-b, 3, 3);
    }
    else if(m.name.includes('Scorpion')) {
        ctx.fillStyle= tint || '#212121'; 
        ctx.beginPath(); ctx.ellipse(x+25,y+25-b,15,10,0,0,6.28); ctx.fill(); // y+35 -> y+25
        ctx.lineWidth=3; ctx.strokeStyle= tint || '#212121'; 
        ctx.beginPath(); ctx.moveTo(x+35,y+20-b); ctx.quadraticCurveTo(x+50,y+0-b,x+35,y+0-b); ctx.stroke(); 
        ctx.fillStyle='#c0392b'; ctx.fillRect(x+33, y-2-b, 4,4); 
        ctx.fillStyle='#212121';
        ctx.beginPath(); ctx.arc(x+10, y+20-b, 5, 0, 6.28); ctx.fill();
        ctx.beginPath(); ctx.arc(x+40, y+20-b, 5, 0, 6.28); ctx.fill();
        drawEyes(x+20, y+25-b); drawEyes(x+28, y+25-b);
    }
    else if(m.name==='Mummy') {
        ctx.fillStyle= tint || '#e0e0e0'; 
        ctx.fillRect(x+18, y+5-b, 14, 30); // y+15 -> y+5
        ctx.strokeStyle = '#757575'; ctx.lineWidth=1; ctx.strokeRect(x+18, y+5-b, 14, 30);
        ctx.fillStyle= tint || '#9e9e9e'; 
        ctx.fillRect(x+18, y+10-b, 14, 2); ctx.fillRect(x+18, y+18-b, 14, 2);
        drawEyes(x+20, y+8-b); drawEyes(x+26, y+8-b);
    }
    else if(m.name==='Stone Golem') {
        ctx.fillStyle = tint || '#78909c'; 
        ctx.fillRect(x+15, y+5-b, 20, 25); // y+15 -> y+5
        ctx.fillStyle = '#546e7a';
        ctx.fillRect(x+10, y+8-b, 5, 20); ctx.fillRect(x+35, y+8-b, 5, 20);
        ctx.fillRect(x+18, y-5-b, 14, 10);
        ctx.fillStyle = '#00e5ff'; ctx.shadowColor='#00e5ff'; ctx.shadowBlur=5;
        ctx.fillRect(x+20, y-2-b, 4, 3); ctx.fillRect(x+26, y-2-b, 4, 3);
        ctx.shadowBlur=0;
    }
    else if(m.name==='Cinder Wolf') {
        ctx.fillStyle = tint || '#111';
        ctx.beginPath(); ctx.ellipse(x+25, y+20-b, 18, 10, 0, 0, 6.28); ctx.fill(); // y+30 -> y+20
        ctx.beginPath(); ctx.moveTo(x+35, y+15-b); ctx.lineTo(x+45, y+10-b); ctx.lineTo(x+40, y+25-b); ctx.fill();
        let f = Math.sin(Date.now()/50)*3;
        ctx.fillStyle = '#ff3d00'; ctx.shadowColor='#ff3d00'; ctx.shadowBlur=10;
        ctx.beginPath(); ctx.moveTo(x+10, y+15-b); ctx.lineTo(x+5, y+5-b+f); ctx.lineTo(x+15, y+10-b); ctx.fill(); 
        ctx.beginPath(); ctx.moveTo(x+20, y+10-b); ctx.lineTo(x+25, y+0-b-f); ctx.lineTo(x+30, y+10-b); ctx.fill(); 
        ctx.shadowBlur=0;
        ctx.fillStyle = '#f00'; ctx.fillRect(x+40, y+12-b, 2, 2);
    }




    // REPLACES THE CHAOS TITAN BLOCK (The Barbarian Design)
    else if(m.name === 'Chaos Titan') {
        // Animation: Heavy breathing (Shoulders rise and fall)
        let breath = Math.sin(Date.now() / 250) * 1.5;
        // Animation: Arm sway
        let sway = Math.sin(Date.now() / 400) * 2;

        // 1. THE GIANT CLUB (Held in back hand, resting on ground)
        // Drawn first so it is behind the body
        ctx.save();
        ctx.translate(x + 50, y + 25); 
        ctx.rotate(0.2 + sway * 0.05); 
        
        // Handle
        ctx.fillStyle = '#5d4037'; // Wood
        ctx.fillRect(-20, -10, 8, 50); 
        // Spiked Head
        ctx.fillStyle = '#212121'; // Iron
        ctx.fillRect(-25, -25, 18, 25);
        // Spikes
        ctx.fillStyle = '#cfd8dc';
        ctx.beginPath(); ctx.moveTo(-25, -15); ctx.lineTo(-30, -12); ctx.lineTo(-25, -10); ctx.fill();
        ctx.beginPath(); ctx.moveTo(-7, -20); ctx.lineTo(0, -18); ctx.lineTo(-7, -15); ctx.fill();
        ctx.beginPath(); ctx.moveTo(-16, -25); ctx.lineTo(-14, -32); ctx.lineTo(-12, -25); ctx.fill();
        ctx.restore();

        // 2. LEGS (Sturdy Stance)
        ctx.fillStyle = '#263238'; // Dark Pants
        // Left
        ctx.fillRect(x + 10, y + 35 - b, 12, 15);
        // Right
        ctx.fillRect(x + 35, y + 35 - b, 12, 15);
        // Boots
        ctx.fillStyle = '#111';
        ctx.fillRect(x + 8, y + 45 - b, 14, 5);
        ctx.fillRect(x + 35, y + 45 - b, 14, 5);

        // 3. LOINCLOTH (Fur)
        ctx.fillStyle = '#5d4037'; 
        ctx.beginPath();
        ctx.moveTo(x + 15, y + 35 - b);
        ctx.lineTo(x + 42, y + 35 - b);
        ctx.lineTo(x + 28, y + 48 - b + sway); // Swings slightly
        ctx.fill();

        // 4. TORSO (V-Shape Muscle)
        ctx.fillStyle = tint || '#37474f'; // Grey Skin
        ctx.beginPath();
        ctx.moveTo(x + 5, y + 10 - b + breath);  // Left Shoulder
        ctx.lineTo(x + 52, y + 10 - b + breath); // Right Shoulder
        ctx.lineTo(x + 35, y + 38 - b); // Right Waist
        ctx.lineTo(x + 22, y + 38 - b); // Left Waist
        ctx.fill();

        // 5. WAR PAINT (Red Stripes)
        ctx.fillStyle = '#b71c1c';
        ctx.beginPath();
        ctx.moveTo(x + 40, y + 12 - b + breath);
        ctx.lineTo(x + 30, y + 25 - b + breath);
        ctx.lineTo(x + 35, y + 25 - b + breath);
        ctx.fill();

        // 6. ARMOR: SPIKED PAULDRONS (Shoulders)
        ctx.fillStyle = '#111';
        // Left Pad
        ctx.beginPath(); ctx.moveTo(x+5, y+15-b+breath); ctx.lineTo(x-5, y+5-b+breath); ctx.lineTo(x+15, y+5-b+breath); ctx.fill();
        // Right Pad
        ctx.beginPath(); ctx.moveTo(x+52, y+15-b+breath); ctx.lineTo(x+62, y+5-b+breath); ctx.lineTo(x+42, y+5-b+breath); ctx.fill();
        // Spikes on pads
        ctx.fillStyle = '#cfd8dc';
        ctx.beginPath(); ctx.moveTo(x+5, y+5-b+breath); ctx.lineTo(x+5, y-5-b+breath); ctx.lineTo(x+10, y+5-b+breath); ctx.fill();

        // 7. ARMS (Muscular)
        ctx.fillStyle = tint || '#37474f';
        // Left Arm (Fist clenched)
        ctx.fillRect(x - 2, y + 15 - b + breath, 10, 20);
        ctx.fillStyle = '#111'; // Gauntlet
        ctx.fillRect(x - 4, y + 32 - b + breath, 14, 10);
        
        // Right Arm (Holding Club)
        ctx.fillStyle = tint || '#37474f';
        ctx.fillRect(x + 48, y + 15 - b + breath, 10, 20);
        ctx.fillStyle = '#111'; // Gauntlet
        ctx.fillRect(x + 46, y + 32 - b + breath, 14, 10);

        // 8. HEAD (Iron Helmet)
        // Small head relative to body = Look stronger
        let headY = y - 2 - b + breath;
        ctx.fillStyle = '#212121'; 
        ctx.fillRect(x + 20, headY, 18, 16);
        
        // Helmet Horns
        ctx.fillStyle = '#ffd700';
        ctx.beginPath(); ctx.moveTo(x+20, headY+5); ctx.lineTo(x+15, headY-5); ctx.lineTo(x+22, headY+2); ctx.fill();
        ctx.beginPath(); ctx.moveTo(x+38, headY+5); ctx.lineTo(x+43, headY-5); ctx.lineTo(x+36, headY+2); ctx.fill();

        // SINGLE GLOWING EYE SLIT (The Cyclops element, but menacing)
        ctx.fillStyle = '#000';
        ctx.fillRect(x + 24, headY + 5, 10, 4); // Visor slit
        
        ctx.fillStyle = '#ff1744'; // Red Glow
        ctx.shadowColor = '#f00'; ctx.shadowBlur = 10;
        ctx.fillRect(x + 27, headY + 5, 4, 4); // The Eye
        ctx.shadowBlur = 0;
    }






    else if(m.name.includes('Skeleton')) {
        ctx.fillStyle = tint || '#ddd';
        ctx.fillRect(x+20, y+0-b, 10, 10); ctx.fillRect(x+23, y+10-b, 4, 15); // y+10 -> y+0
        ctx.fillRect(x+18, y+12-b, 14, 2); ctx.fillRect(x+18, y+16-b, 14, 2); ctx.fillRect(x+18, y+20-b, 14, 2);
        ctx.fillRect(x+20, y+25-b, 3, 10); ctx.fillRect(x+27, y+25-b, 3, 10);
        ctx.fillStyle='#111'; ctx.fillRect(x+22, y+2-b, 2, 2); ctx.fillRect(x+26, y+2-b, 2, 2);
    }
    else if(m.name==='Bat') {
        ctx.fillStyle = tint || '#212121';
        ctx.fillRect(x+5, y+5-b, 10, 10); ctx.fillRect(x+15, y+10-b, 5, 8); // y+15 -> y+5
        ctx.fillRect(x+30, y+10-b, 5, 8); ctx.fillRect(x+35, y+5-b, 10, 10);
        ctx.fillRect(x+20, y+10-b, 10, 12); ctx.fillRect(x+20, y+8-b, 2, 4); ctx.fillRect(x+28, y+8-b, 2, 4);
        ctx.fillStyle='#f00'; ctx.fillRect(x+22, y+12-b, 2, 2); ctx.fillRect(x+26, y+12-b, 2, 2);
    }
    else if(m.name.includes('Basilisk')) {
         ctx.fillStyle = tint || '#27ae60'; ctx.fillRect(x+35, y+10-b, 12, 10); // y+20 -> y+10
         ctx.fillStyle = tint || '#1e8449'; ctx.fillRect(x+10, y+12-b, 25, 8);
         ctx.fillRect(x, y+14-b, 10, 4);
         ctx.fillStyle = '#f1c40f'; ctx.fillRect(x+15, y+8-b, 3, 4); ctx.fillRect(x+25, y+8-b, 3, 4);
         drawEyes(x+40, y+12-b);
    }
    else if(m.name==='Mosquito') {
         ctx.fillStyle = tint || '#555'; ctx.fillRect(x+22, y+10-b, 6, 15); // y+20 -> y+10
         ctx.fillStyle = 'rgba(200,200,200,0.6)'; ctx.fillRect(x+10, y+5-b, 12, 10); ctx.fillRect(x+28, y+5-b, 12, 10);
         ctx.fillStyle = '#f00'; ctx.fillRect(x+24, y+25-b, 2, 8);
         ctx.fillStyle = '#a93226'; ctx.fillRect(x+20, y+8-b, 4, 4); ctx.fillRect(x+26, y+8-b, 4, 4);
    }
    else if(m.name.includes('Magma')) {
        ctx.fillStyle = tint || '#bf360c'; ctx.fillRect(x+15, y+5-b, 20, 25); // y+15 -> y+5
        ctx.fillRect(x+10, y+10-b, 5, 15); ctx.fillRect(x+35, y+10-b, 5, 15);
        ctx.fillStyle = '#ff6f00'; ctx.fillRect(x+20, y+10-b, 10, 5); ctx.fillRect(x+22, y+20-b, 6, 5);
        ctx.fillStyle = '#ffd600'; ctx.fillRect(x+18, y+2-b, 4, 4); ctx.fillRect(x+28, y+2-b, 4, 4);
    }
    else if(m.name==='Fire Imp') {
        ctx.fillStyle = tint || '#d32f2f'; ctx.fillRect(x+20, y+15-b, 10, 15); ctx.fillRect(x+18, y+5-b, 14, 10); // y+25 -> y+15
        ctx.fillStyle = '#212121'; ctx.fillRect(x+18, y+0-b, 3, 5); ctx.fillRect(x+29, y+0-b, 3, 5);
        ctx.fillStyle = '#ffd700'; ctx.fillRect(x+35, y+5-b, 2, 25); ctx.fillRect(x+33, y+5-b, 6, 2);
        drawEyes(x+20, y+8-b); drawEyes(x+26, y+8-b);
    }
    else if(m.name.includes('Slime')) {
        let wobble = Math.sin(Date.now()/100)*2;
        ctx.fillStyle= tint || '#00bcd4'; 
        ctx.fillRect(x+15-wobble, y+15-wobble, 20+wobble*2, 15+wobble); // y+30 -> y+15
        drawEyes(x+18, y+17); drawEyes(x+28, y+17);
    }
    else if(m.name==='Goblin') {
        ctx.fillStyle= tint || '#c0392b'; 
        ctx.fillRect(x+15, y+15-b, 20, 20); ctx.fillRect(x+10, y+10-b, 30, 10); // y+25 -> y+15
        ctx.fillStyle= tint || '#a93226'; ctx.beginPath(); ctx.moveTo(x+10,y+15-b); ctx.lineTo(x+5,y+5-b); ctx.lineTo(x+15,y+10-b); ctx.fill();
        ctx.beginPath(); ctx.moveTo(x+40,y+15-b); ctx.lineTo(x+45,y+5-b); ctx.lineTo(x+35,y+10-b); ctx.fill();
        drawEyes(x+18, y+18-b); drawEyes(x+28, y+18-b);
    }



   // REPLACES THE OLD HYDRA/FROG BLOCK
    else if(m.name.includes('Hydra')) { 
        // 1. Animation Timer
        let t = Date.now() / 300;

        // 2. Main Body (The base at the bottom)
        ctx.fillStyle = tint || '#1b5e20'; // Dark Swamp Green
        ctx.beginPath(); 
        ctx.ellipse(x+25, y+35-b, 15, 8, 0, 0, 6.28); 
        ctx.fill();

        // 3. Draw 3 Heads
        // We define positions for Left, Center, Right heads
        let heads = [
            { ox: 10, oy: 10, offset: 0 },   // Left
            { ox: 25, oy: 5,  offset: 2 },   // Center (Highest)
            { ox: 40, oy: 10, offset: 4 }    // Right
        ];

        heads.forEach(h => {
            // Swaying motion
            let sway = Math.sin(t + h.offset) * 3;
            let headX = x + h.ox + sway;
            let headY = y + h.oy;

            // A. Draw Neck (Curve from Body to Head)
            ctx.strokeStyle = tint || '#2e7d32'; 
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(x+25, y+35-b); // Start at body center
            // Control point curves outward
            ctx.quadraticCurveTo(x + h.ox, y + 25 - b, headX, headY);
            ctx.stroke();

            // B. Draw Head
            ctx.fillStyle = tint || '#2ecc71'; // Lighter Green Head
            ctx.beginPath();
            ctx.ellipse(headX, headY, 6, 8, sway*0.1, 0, 6.28);
            ctx.fill();

            // C. Eyes (Red & menacing)
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(headX - 3, headY - 2, 2, 2);
            ctx.fillRect(headX + 1, headY - 2, 2, 2);
            
            // D. Tongue (Flicking)
            if (Math.sin(t * 3 + h.offset) > 0.8) {
                ctx.strokeStyle = '#e74c3c'; ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(headX, headY+5); ctx.lineTo(headX, headY+10); ctx.stroke();
            }
        });
    }






    // REPLACES THE RED DRAGON BLOCK
    else if(m.name.includes('Dragon')) {
        // Animation: Flapping wings
        let flap = Math.sin(Date.now() / 150) * 5;

        // 1. WINGS (Behind Body) - Dark Red
        ctx.fillStyle = '#8b0000'; 
        // Left Wing
        ctx.beginPath(); 
        ctx.moveTo(x+20, y+20-b); 
        ctx.lineTo(x+5, y-5-b+flap); 
        ctx.lineTo(x+25, y+15-b); 
        ctx.fill();
        
        // Right Wing
        ctx.beginPath(); 
        ctx.moveTo(x+30, y+20-b); 
        ctx.lineTo(x+45, y-5-b+flap); 
        ctx.lineTo(x+25, y+15-b); 
        ctx.fill();

        // 2. TAIL (Wags slightly)
        ctx.fillStyle = tint || '#c62828';
        ctx.beginPath(); 
        ctx.moveTo(x+25, y+35-b); 
        ctx.quadraticCurveTo(x+15, y+45-b, x+5+flap, y+40-b); 
        ctx.lineTo(x+20, y+35-b); 
        ctx.fill();

        // 3. BODY (Main Torso)
        ctx.fillStyle = tint || '#c62828'; // Red
        ctx.fillRect(x+15, y+15-b, 20, 25); 
        
        // Belly (Orange strips)
        ctx.fillStyle = '#ffcc80';
        ctx.fillRect(x+20, y+15-b, 10, 20);
        
        // Rib lines (Texture)
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(x+20, y+20-b, 10, 2); 
        ctx.fillRect(x+20, y+25-b, 10, 2); 
        ctx.fillRect(x+20, y+30-b, 10, 2);

        // 4. HEAD & NECK
        ctx.fillStyle = tint || '#c62828';
        // Neck connecting to body
        ctx.beginPath(); 
        ctx.moveTo(x+25, y+15-b); 
        ctx.lineTo(x+35, y+5-b); 
        ctx.lineTo(x+30, y+20-b); 
        ctx.fill();
        
        // Head Box
        ctx.fillRect(x+30, y+0-b, 15, 12);
        
        // Snout Tip (Darker)
        ctx.fillStyle = '#b71c1c';
        ctx.fillRect(x+40, y+4-b, 5, 8); 

        // Horn (Yellow)
        ctx.fillStyle = '#f1c40f';
        ctx.beginPath(); 
        ctx.moveTo(x+32, y+0-b); 
        ctx.lineTo(x+28, y-8-b); 
        ctx.lineTo(x+36, y+0-b); 
        ctx.fill();

        // Eye (Glowing Yellow)
        ctx.fillStyle = '#ffeb3b';
        ctx.fillRect(x+35, y+3-b, 4, 4);
    }






    else if(m.name.includes('Yeti') || m.name==='Ice Spirit') {
        if(m.name==='Ice Spirit') { ctx.fillStyle= tint || '#0288d1'; ctx.beginPath(); ctx.moveTo(x+25, y+0-b); ctx.lineTo(x+35, y+15-b); ctx.lineTo(x+25, y+30-b); ctx.lineTo(x+15, y+15-b); ctx.fill(); } // y+10 -> y+0
        else { ctx.fillStyle= tint || '#2196f3'; ctx.beginPath(); ctx.ellipse(x+25, y+15-b, 20, 22, 0, 0, 6.28); ctx.fill(); drawEyes(x+20, y+5-b); drawEyes(x+27, y+5-b); } // y+25 -> y+15
    }

    if(m.boss) { 
        ctx.fillStyle='#ffd700'; ctx.font='20px sans'; 
        let crownY = m.name==='Slime King' ? y+10-b : y-15-b; // y+20 -> y+10
        ctx.fillText('üëë', x+18, crownY); 
    }
    ctx.restore();
}







function drawNPC(x, y, n) {
    let b = Math.sin(Date.now()/300)*2;
    ctx.save(); ctx.translate(x+25, y+35); 
    ctx.scale(3.0, 3.0); 
    
    let hash = 0;
    for(let i=0; i<n.name.length; i++) hash = n.name.charCodeAt(i) + ((hash << 5) - hash);
    let hue = Math.abs(hash % 360);
    let clothColor = `hsl(${hue}, 60%, 50%)`;
    let hairColor = `hsl(${hue}, 40%, 30%)`;

    if(n.name === "Shummi") {
        ctx.fillStyle = '#f5cba7'; ctx.fillRect(-3, -7, 6, 5); 
        ctx.fillStyle = clothColor; 
        ctx.beginPath(); ctx.moveTo(-3, -2); ctx.lineTo(3, -2); ctx.lineTo(5, 8); ctx.lineTo(-5, 8); ctx.fill(); 
        ctx.fillStyle = hairColor;
        ctx.fillRect(-4, -9, 8, 4); 
        ctx.fillRect(-5, -6, 2, 2); ctx.fillRect(3, -6, 2, 2);
    }
  // --- NOAH (The French Artist) ---
    else if(n.name === "Noah") {
     // 1. LEGS (Dark Trousers)
        ctx.fillStyle = '#1a1a1a'; 
        ctx.fillRect(-4, 5, 3, 5); ctx.fillRect(1, 5, 3, 5);
        ctx.fillStyle = '#000'; // Shoes
        ctx.fillRect(-5, 9, 4, 2); ctx.fillRect(1, 9, 4, 2);

        // 2. TORSO (Striped Shirt)
        ctx.fillStyle = '#fff'; ctx.fillRect(-4, -2, 8, 7); // White Base
        ctx.fillStyle = '#1a237e'; // Blue Stripes
        ctx.fillRect(-4, -1, 8, 1); ctx.fillRect(-4, 1, 8, 1); ctx.fillRect(-4, 3, 8, 1);
        
        // 3. ARMS & PALETTE
        // Left Arm (Holding Palette)
        ctx.fillStyle = '#fff'; ctx.fillRect(-6, -2, 2, 4); 
        ctx.fillStyle = '#f5cba7'; ctx.fillRect(-6, 2, 2, 2); // Hand
        
        // THE PALETTE (Wooden Oval)
        ctx.fillStyle = '#d35400'; 
        ctx.beginPath(); ctx.ellipse(-7, 2, 3, 4, -0.2, 0, Math.PI*2); ctx.fill();
        // Paint Blobs
        ctx.fillStyle = '#e91e63'; ctx.fillRect(-8, 0, 1, 1); // Red
        ctx.fillStyle = '#f1c40f'; ctx.fillRect(-8, 2, 1, 1); // Yellow
        ctx.fillStyle = '#2980b9'; ctx.fillRect(-6, 4, 1, 1); // Blue
        
        // Right Arm (Holding Brush)
        ctx.fillStyle = '#fff'; ctx.fillRect(4, -2, 2, 4); 
        ctx.fillStyle = '#f5cba7'; ctx.fillRect(4, 2, 2, 2);
        ctx.fillStyle = '#a1887f'; ctx.fillRect(7, 1, 1, 4); // Brush Handle
        ctx.fillStyle = '#e91e63'; ctx.fillRect(7, 0, 1, 1); // Red Tip

        // 4. SCARF (Red)
        ctx.fillStyle = '#c0392b'; 
        ctx.fillRect(-3, -2, 6, 2); // Around neck
        ctx.fillRect(2, -1, 2, 4);  // Draping down

        // 5. HEAD
        ctx.fillStyle = '#f5cba7'; ctx.fillRect(-3, -7, 6, 5); // Face
        
        // Hair (No neck stain)
        ctx.fillStyle = '#212121'; 
        ctx.fillRect(-4, -8, 8, 2); // Top Hair (Under Brim)
        ctx.fillRect(-4, -7, 1, 4); // Left Sideburn
        ctx.fillRect(3, -7, 1, 4);  // Right Sideburn
        
        // Eyes (Asian Black Eyes) - FIXED POSITION
        ctx.fillStyle = '#000'; 
        ctx.fillRect(-2, -5, 1, 1); // Left Eye
        ctx.fillRect(1, -5, 1, 1);  // Right Eye (Moved closer to center to fix "strange" look)

        // Beret (Tilted)
        ctx.fillStyle = '#b71c1c'; 
        ctx.beginPath(); ctx.ellipse(1, -9, 7, 3, 0.3, 0, Math.PI*2); ctx.fill(); // Main Cap
        ctx.fillStyle = '#d32f2f'; // Lighter Top
        ctx.beginPath(); ctx.ellipse(1, -10, 5, 2, 0.3, 0, Math.PI*2); ctx.fill(); 
        ctx.fillStyle = '#111'; ctx.fillRect(0, -11, 2, 2); // Stem
    }


  // --- DORIS (Legendary Educator) ---
    else if(n.name === "Doris") {
        // 1. WINGS (Background Layer)
        ctx.save();
        ctx.translate(0, -2);
        ctx.fillStyle = '#f5f5f5'; ctx.shadowColor='#fff'; ctx.shadowBlur=5;
        // Geometric Feathers
        ctx.fillRect(-14, -6, 10, 2); ctx.fillRect(-12, -4, 8, 2); ctx.fillRect(-8, -2, 4, 2); 
        ctx.fillRect(4, -6, 10, 2);   ctx.fillRect(4, -4, 8, 2);   ctx.fillRect(4, -2, 4, 2);   
        ctx.shadowBlur=0;
        ctx.restore();

        // 2. LEGS & FEET
        ctx.fillStyle = '#ffcc80'; 
        ctx.fillRect(-3, 8, 2, 3); ctx.fillRect(1, 8, 2, 3);  
        ctx.fillStyle = '#111'; 
        ctx.fillRect(-4, 10, 3, 2); ctx.fillRect(1, 10, 3, 2);

        // 3. DRESS (Blue Suit)
        ctx.fillStyle = '#0277bd'; 
        ctx.fillRect(-4, 2, 8, 6); 
        ctx.fillStyle = '#039be5'; 
        ctx.fillRect(-4, -2, 8, 5);
        
        // 4. ARMS
        ctx.fillStyle = '#039be5'; ctx.fillRect(-6, -2, 2, 5); 
        ctx.fillStyle = '#ffe0b2'; ctx.fillRect(-6, 3, 2, 2); 
        ctx.fillStyle = '#039be5'; ctx.fillRect(4, -2, 2, 5);
        ctx.fillStyle = '#ffe0b2'; ctx.fillRect(4, 3, 2, 2); 

        // 5. NECKLACE (Elegant Short Pearls)
        ctx.fillStyle = '#ffffff'; // Pearl White
        // A simple curved string of pearls near the neck
        ctx.fillRect(-3, -2, 1, 1); 
        ctx.fillRect(-2, -1, 1, 1);
        ctx.fillRect(-1, 0, 2, 1); // Center dip
        ctx.fillRect(1, -1, 1, 1);
        ctx.fillRect(2, -2, 1, 1);

       // 6. HEAD & HAIR
        ctx.fillStyle = '#ffe0b2'; ctx.fillRect(-3, -7, 6, 5); // Face
        
        // Features
        ctx.fillStyle = '#d84315'; ctx.fillRect(-1, -3, 2, 1); // Smile (Lowered 1px)
        ctx.fillStyle = '#ffccbc'; ctx.fillRect(-3, -5, 1, 1); ctx.fillRect(2, -5, 1, 1); // Cheeks

        // Hair Art

        // Hair Art
        ctx.fillStyle = '#fff176'; 
        ctx.fillRect(-5, -11, 7, 4); // Left Mass 
        ctx.fillRect(2, -10, 3, 3);  // Right Mass 
        ctx.fillRect(-4, -7, 5, 2);  // Bang sweep
        ctx.fillRect(-6, -8, 2, 4);  // Left Curl 
        ctx.fillRect(4, -8, 2, 3);   // Right Curl 

        ctx.fillStyle = '#fbc02d';
        ctx.fillRect(-2, -10, 1, 2); // Part line
        
        ctx.fillStyle = '#b0bec5'; ctx.fillRect(-5, -5, 1, 2); ctx.fillRect(4, -5, 1, 2);
    }
    else if(n.gender === 'F') {




        ctx.fillStyle = hairColor; ctx.fillRect(-6, -8, 12, 12); 
        ctx.fillStyle = '#f5cba7'; ctx.fillRect(-3, -7, 6, 5); 
        ctx.fillStyle = clothColor;
        ctx.beginPath(); ctx.moveTo(-3, -2); ctx.lineTo(3, -2); ctx.lineTo(5, 8); ctx.lineTo(-5, 8); ctx.fill();
        ctx.fillStyle = hairColor; ctx.fillRect(-5, -7, 2, 8); ctx.fillRect(3, -7, 2, 8);
    } 
    else {
        ctx.fillStyle = '#f5cba7'; ctx.fillRect(-3, -7, 6, 5);
        ctx.fillStyle = hairColor; ctx.fillRect(-4, -9, 8, 3); ctx.fillRect(-4, -6, 1, 2); ctx.fillRect(3, -6, 1, 2);
        ctx.fillStyle = clothColor; ctx.fillRect(-4, -2, 8, 6);
        ctx.fillStyle = '#333'; ctx.fillRect(-3, 4, 2, 4); ctx.fillRect(1, 4, 2, 4);
    }
    ctx.fillStyle='#000'; ctx.fillRect(-2, -5, 1, 1); ctx.fillRect(1, -5, 1, 1);
    ctx.restore();
    
    ctx.fillStyle='#fff'; ctx.font='bold 16px monospace'; 
    ctx.shadowColor='#000'; ctx.shadowBlur=4; 
    ctx.fillText(n.name, x+5, y-15+b); 
    ctx.shadowBlur=0;
    
   // --- QUEST MARKER LOGIC ---
    let q = QUESTS[S.qStep];
    
    // Condition 1: Normal Main Quest
    let isMainQuest = (q && q.type==='talk' && q.target===n.name);
    
    // Condition 2: Epilogue (Boss Dead + Haven't talked yet + Is Noah or Doris)
    let isEpilogue = (S.bossDead && !S.epilogueSeen && (n.name === "Noah" || n.name === "Doris"));

    // Draw the Exclamation Mark if either condition is true
    if(isMainQuest || isEpilogue) {
        ctx.fillStyle='#e74c3c'; 
        ctx.font='bold 34px monospace'; 
        ctx.fillText('!', x+20, y-35+b); 
    }
}



function drawStruct(x, y, e) {
    let w = e.w * TILE, h = e.h * TILE;
    if(e.kind==='Fountain' || e.kind==='Healing Crystal') {
        ctx.fillStyle= e.kind==='Fountain' ? '#3498db' : '#2ecc71';
        ctx.beginPath(); ctx.arc(x+w/2, y+h-40, e.kind==='Fountain'?30:15, 0, 6.28); ctx.fill();
        ctx.fillStyle='#fff'; ctx.font='30px monospace'; ctx.fillText('‚úö', x+w/2-10, y+h-30);
    } else if(e.kind==='House' || e.kind==='TuckShop' || e.kind==='FarmHouse' || e.kind==='Church') {
        if(e.kind==='TuckShop') {
             ctx.fillStyle='#d35400'; ctx.fillRect(x+10, y+40, w-20, h-40); 
             ctx.fillStyle='#e67e22'; ctx.fillRect(x+20, y+80, 40, 40); 
             ctx.fillStyle='#34495e'; ctx.fillRect(x+w-70, y+h-60, 50, 60); 
             ctx.fillStyle='#c0392b'; ctx.beginPath(); ctx.moveTo(x, y+40); ctx.lineTo(x+w/2, y-10); ctx.lineTo(x+w, y+40); ctx.fill(); 
             ctx.fillStyle='#fff'; ctx.fillRect(x+30, y+50, w-60, 20);
             ctx.fillStyle='#000'; ctx.font='16px monospace'; ctx.fillText("RESTAURANT", x+50, y+65);
        } else if(e.kind==='FarmHouse') {
            let lvl = S.farm.houseLevel;
            ctx.fillStyle = '#5d4037'; ctx.fillRect(x+10, y+50, w-20, h-50); 
            ctx.fillStyle = '#c0392b'; 
            ctx.beginPath(); ctx.moveTo(x, y+50); ctx.lineTo(x+w/2, y); ctx.lineTo(x+w, y+50); ctx.fill();
            
            ctx.fillStyle = '#3e2723'; ctx.fillRect(x+w/2-25, y+h-60, 50, 60); 
            if(lvl === 2) {
                ctx.fillStyle = '#8d6e63'; ctx.fillRect(x+w-50, y+60, 40, 40); 
                ctx.fillStyle = '#81d4fa'; ctx.fillRect(x+w-45, y+65, 30, 30);
            }

        // --- FIXED VINTAGE CHURCH ---
        } else if (e.kind === 'Church') {
            const cx = x + w/2;
            const gy = y + h;
            
            // Dimensions
            const wallH = 140; 
            const wallTop = gy - wallH; // The top point of the wall
            const eaveY = wallTop + 40; // Where the roof slope starts

            // 1. STONE FOUNDATION
            ctx.fillStyle = '#546e7a';
            ctx.fillRect(x + 10, gy - 10, w - 20, 10);
            ctx.fillStyle = '#455a64';
            ctx.fillRect(x + 10, gy - 3, w - 20, 3);

            // 2. MAIN FA√áADE (The Fix: Draw shape, not just rect)
            ctx.fillStyle = '#b0bec5'; 
            ctx.beginPath();
            ctx.moveTo(x + 20, gy - 10);      // Bottom Left
            ctx.lineTo(x + 20, eaveY);        // Top Left (Eave height)
            ctx.lineTo(cx, wallTop);          // Peak
            ctx.lineTo(x + w - 20, eaveY);    // Top Right (Eave height)
            ctx.lineTo(x + w - 20, gy - 10);  // Bottom Right
            ctx.fill();

            // 3. TEXTURE: QUOINS (Corner Stones)
            ctx.fillStyle = '#90a4ae'; 
            for(let i = eaveY; i < gy - 20; i += 20) {
                ctx.fillRect(x + 20, i, 15, 8);      // Left
                ctx.fillRect(x + w - 35, i + 10, 15, 8); // Right
            }

            // 4. THE DOOR (1.5 Tiles High)
            const doorW = 60; 
            const doorH = 75;
            const doorX = cx - doorW/2;
            const doorY = gy - 10 - doorH;

            // Door Arch Frame
            ctx.fillStyle = '#78909c';
            ctx.beginPath();
            ctx.arc(cx, doorY, doorW/2 + 6, Math.PI, 0); 
            ctx.fillRect(doorX - 6, doorY, doorW + 12, doorH); 
            ctx.fill();

            // Wooden Doors
            ctx.fillStyle = '#3e2723'; 
            ctx.beginPath(); ctx.arc(cx, doorY, doorW/2, Math.PI, 0); 
            ctx.fillRect(doorX, doorY, doorW, doorH);
            ctx.fill();

            // Hinges
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(cx - 1, doorY - 20, 2, doorH + 20); // Split
            ctx.fillRect(doorX + 5, doorY + 20, 10, 4); 
            ctx.fillRect(doorX + doorW - 15, doorY + 20, 10, 4); 

            // 5. SIDE WINDOWS (Lancet)
            const winY = eaveY + 15;
            ctx.fillStyle = '#37474f'; 
            ctx.beginPath(); ctx.ellipse(x + 45, winY, 6, 20, 0, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(x + w - 45, winY, 6, 20, 0, 0, Math.PI*2); ctx.fill();
            // Glow
            ctx.fillStyle = '#0288d1'; ctx.beginPath(); ctx.ellipse(x + 45, winY+5, 3, 10, 0, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#0288d1'; ctx.beginPath(); ctx.ellipse(x + w - 45, winY+5, 3, 10, 0, 0, Math.PI*2); ctx.fill();

            // 6. ROOF (The Fix: Overhangs correctly now)
            ctx.fillStyle = '#263238'; 
            ctx.beginPath();
            ctx.moveTo(x, eaveY + 10);
            ctx.lineTo(cx, wallTop - 10); // Slight peak overlap
            ctx.lineTo(x + w, eaveY + 10);
            ctx.fill();
            
            // Roof Trim
            ctx.strokeStyle = '#37474f'; ctx.lineWidth = 4; ctx.lineJoin = 'round';
            ctx.beginPath(); ctx.moveTo(x+5, eaveY+10); ctx.lineTo(cx, wallTop-10); ctx.lineTo(x+w-5, eaveY+10); ctx.stroke();

            // 7. BELL TOWER (Sitting on top)
            const towerW = 50;
            const towerBaseY = wallTop - 20;
            const towerTopY = y + 20; 
            
            // Base
            ctx.fillStyle = '#90a4ae'; 
            ctx.fillRect(cx - towerW/2, towerBaseY, towerW, 60);
            
            // Tower Roof
            ctx.fillStyle = '#263238';
            ctx.beginPath();
            ctx.moveTo(cx - towerW/2 - 5, towerBaseY);
            ctx.lineTo(cx, towerTopY);
            ctx.lineTo(cx + towerW/2 + 5, towerBaseY);
            ctx.fill();

            // Vent
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(cx - 10, towerBaseY + 15, 20, 25);
            ctx.fillStyle = '#546e7a'; 
            ctx.fillRect(cx - 10, towerBaseY + 20, 20, 2);
            ctx.fillRect(cx - 10, towerBaseY + 28, 20, 2);

            // 8. ROSE WINDOW (Centered under tower)
            const roseY = eaveY - 10;
            ctx.fillStyle = '#455a64'; ctx.beginPath(); ctx.arc(cx, roseY, 16, 0, 6.28); ctx.fill();
            ctx.fillStyle = '#1565c0'; ctx.beginPath(); ctx.arc(cx, roseY, 12, 0, 6.28); ctx.fill();
            ctx.strokeStyle = '#90a4ae'; ctx.lineWidth = 2; 
            ctx.beginPath(); ctx.moveTo(cx-12, roseY); ctx.lineTo(cx+12, roseY); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(cx, roseY-12); ctx.lineTo(cx, roseY+12); ctx.stroke();

            // 9. CROSS
            ctx.fillStyle = '#111'; 
            ctx.fillRect(cx - 2, y, 4, 30);  
            ctx.fillRect(cx - 10, y + 10, 20, 4);
            ctx.fillStyle = '#ffd700'; ctx.fillRect(cx-2, y, 4, 4); // Gold Tip

        } else {
            ctx.fillStyle='#795548'; ctx.fillRect(x+10, y+40, w-20, h-40); 
            ctx.fillStyle='#5d4037'; ctx.fillRect(x+w/2-20, y+h-50, 40, 50); 
            ctx.fillStyle='#c0392b'; ctx.beginPath(); ctx.moveTo(x, y+40); ctx.lineTo(x+w/2, y); ctx.lineTo(x+w, y+40); ctx.fill(); 
        }
    } else if (e.kind === 'ShippingBin') {
        ctx.fillStyle='#5d4037'; ctx.fillRect(x+5, y+10, 40, 30);
        ctx.fillStyle='#3e2723'; ctx.fillRect(x+10, y+15, 30, 20);
        ctx.fillStyle='#fff'; ctx.font='12px monospace'; ctx.fillText("BIN", x+15, y+30);
    } else if (e.kind === 'Chest') {
        ctx.fillStyle='#f39c12'; ctx.fillRect(x+5, y+15, 40, 30);
        ctx.fillStyle='#d35400'; ctx.fillRect(x+5, y+15, 40, 8); 
        ctx.fillStyle='#000'; ctx.fillRect(x+22, y+25, 6, 8); 
    } else {
        ctx.fillStyle='#444'; ctx.fillRect(x,y,w,h); ctx.strokeStyle='#222'; ctx.lineWidth=3; ctx.strokeRect(x,y,w,h);
    }
}

function drawEnv(x, y, k) {
    let px = x, py = y; 
    ctx.strokeStyle = 'rgba(0,0,0,0.5)'; ctx.lineWidth=2;
    if(k.includes('tree')) { 
        ctx.fillStyle='#5d4037'; ctx.fillRect(px+20, py+35, 10, 15); 
        ctx.fillStyle = k==='tree_f' ? '#145a32' : '#2ecc71'; 
        ctx.beginPath(); ctx.arc(px+25, py+25, 22, 0, 6.28); ctx.fill(); ctx.stroke();
    }
    else if(k==='flower') { ctx.fillStyle='#e91e63'; ctx.beginPath(); ctx.arc(px+25,py+35,4,0,6.28); ctx.fill(); }
    else if(k==='cactus') { ctx.fillStyle='#27ae60'; ctx.fillRect(px+22, py+15, 6, 35); ctx.fillRect(px+12, py+25, 26, 6); }
    else if(k==='ice_crystal') { ctx.fillStyle='#d6eaf8'; ctx.beginPath(); ctx.moveTo(px+10,py+45); ctx.lineTo(px+25,py+10); ctx.lineTo(px+40,py+45); ctx.fill(); }
    else { ctx.fillStyle='#7f8c8d'; ctx.beginPath(); ctx.arc(px+25,py+40,8,0,6.28); ctx.fill(); }
}






// --- PASTE THIS NEW FUNCTION ---
function lightning(x1, y1, x2, y2, isHeavy=false) {
    // Helper to make a jagged path
    const makePath = (sx, sy, ex, ey, displacement) => {
        let path = [];
        let currX = sx*TILE-S.cam.x; let currY = sy*TILE-S.cam.y;
        let destX = ex*TILE-S.cam.x; let destY = ey*TILE-S.cam.y;
        let dist = Math.hypot(destX-currX, destY-currY);
        let steps = Math.max(4, Math.floor(dist / 15)); 

        path.push({x:currX, y:currY});
        for(let i=1; i<steps; i++) {
            let t = i / steps;
            let nx = currX + (destX - currX) * t;
            let ny = currY + (destY - currY) * t;
            // Jitter
            nx += (Math.random() - 0.5) * displacement; 
            ny += (Math.random() - 0.5) * displacement;
            path.push({x:nx, y:ny});
        }
        path.push({x:destX, y:destY});
        return path;
    };

    let mainSegs = makePath(x1, y1, x2, y2, 40); // Main bolt: High jitter

    // If Heavy, generate branches
    let branches = [];
    if(isHeavy) {
        // Create 3 random branches splitting off the main bolt
        for(let k=0; k<3; k++) {
            let startNode = mainSegs[Math.floor(mainSegs.length * (0.3 + Math.random()*0.4))];
            if(startNode) {
                // Branch goes downwards and outwards
                let endX = x2 + (Math.random()-0.5)*8;
                let endY = y2 + (Math.random()*5);
                // Convert back to world coords for the helper, then to screen
                // Quick hack: just map relative pixel offsets
                let bx = startNode.x + (Math.random()-0.5)*150;
                let by = startNode.y + 100 + Math.random()*100;
                
                branches.push(makePath(startNode.x/TILE + S.cam.x/TILE, startNode.y/TILE + S.cam.y/TILE, 
                                       x2 + (Math.random()-0.5)*6, y2, 30));
            }
        }
    }

    S.lighting.push({
        segs: mainSegs, 
        branches: branches,
        life: 25,         // Lasts longer (fades out)
        maxLife: 25,
        type: isHeavy ? 'heavy_storm' : 'normal' 
    });
}

// ------------------------------





function popText(x, y, txt, c, outline=false, small=false) {
    let d = document.createElement('div'); 
    d.className='float-txt'; d.innerText=txt; d.style.color=c;
    if(small) { d.style.fontSize = "24px"; }
    let rect = cvs.getBoundingClientRect();
    d.style.left = ((x*TILE - S.cam.x) + rect.left + 25) + 'px';
    d.style.top = ((y*TILE - S.cam.y) + rect.top) + 'px';
    document.body.appendChild(d); setTimeout(()=>d.remove(), 800);
}
function part(x, y, c, n, s=3, type='norm') { 
    if(S.parts.length>400) return;
    for(let i=0;i<n;i++) S.parts.push({
        x:x+(Math.random()-.5), y:y+(Math.random()-.5), 
        vx:(Math.random()-.5)*0.1, vy:(Math.random()-.5)*0.1, 
        c, life:type.includes('cloud')?50:20+Math.random()*10, s:s+Math.random()*2, type
    }); 
}





function drawStyledMinimap() {
    // 1. Clear Background (Transparent)
    miniCtx.clearRect(0, 0, MAP_S, MAP_S);

    // 2. Define The Zones
    const islands = [
        [25, 25, 18, '#a5d6a7', '#2e7d32'], // 1. Grass
        [75, 25, 16, '#66bb6a', '#1b5e20'], // 2. Forest
        [125, 25, 16, '#fff59d', '#fbc02d'], // 3. Sand
        [125, 75, 16, '#cfd8dc', '#455a64'], // 4. Ruins
        [75, 75, 16, '#bcaaa4', '#5d4037'], // 5. Swamp
        [25, 75, 16, '#e1f5fe', '#90a4ae'], // 6. Snow
        [25, 125, 16, '#ffab91', '#d84315'], // 7. Lava
        [75, 125, 16, '#9fa8da', '#283593'], // 8. Void
    ];

    // 3. Draw Roads (Original Solid Style)
    miniCtx.strokeStyle = '#d7ccc8'; 
    miniCtx.lineWidth = 4;
    miniCtx.lineCap = 'round';
    miniCtx.setLineDash([]); // Ensure solid lines

    miniCtx.beginPath();
    miniCtx.moveTo(25, 25); 
    miniCtx.lineTo(125, 25);
    miniCtx.lineTo(125, 75);
    miniCtx.lineTo(25, 75);
    miniCtx.lineTo(25, 125);
    miniCtx.lineTo(75, 125); 
    
    // Fake Road (If Unlocked)
    if (S.bossDead) miniCtx.lineTo(135, 135);
    
    miniCtx.stroke();

    // 4. Draw Islands (Original Colors)
    islands.forEach(isle => {
        let x = isle[0], y = isle[1], r = isle[2];
        miniCtx.beginPath();
        miniCtx.arc(x, y, r, 0, 6.28);
        
        // Original Inner Color
        miniCtx.fillStyle = isle[3]; 
        miniCtx.fill();
        
        // Original Border Color
        miniCtx.lineWidth = 3; 
        miniCtx.strokeStyle = isle[4]; 
        miniCtx.stroke();
    });

    // 5. Fake Island (If Unlocked)
    if (S.bossDead) {
        miniCtx.beginPath();
        miniCtx.arc(135, 135, 16, 0, 6.28); 
        miniCtx.fillStyle = '#a5d6a7'; 
        miniCtx.fill();
        miniCtx.lineWidth = 3;
        miniCtx.strokeStyle = '#2e7d32'; 
        miniCtx.stroke();
    }
}






// --- GAME OVER & MENU LOGIC ---

function triggerGameOver(killerName) {
    if (S.gameOver) return; // Prevent double death
    S.gameOver = true;
    S.run = false; // STOP the game loop
    
    S.audio.play('over'); // AUDIO

    // Show Death Screen
    document.getElementById('death-screen').style.display = 'flex';
    document.getElementById('death-msg').innerText = killerName || "Unknown Force";
}

function returnToMenu() {
    S.audio.play('esc'); 
    
    // --- STOP MUSIC ---
    if(S.audio.bgm) { S.audio.bgm.pause(); S.audio.bgm = null; S.audio.currentBgmKey = null; }

    // 1. Hide Death Screen and Game UI
    document.getElementById('death-screen').style.display = 'none';
    document.getElementById('hud-top').style.display = 'none';
    document.getElementById('quest-panel').style.display = 'none';
    
    // 2. Clear Skills (Visual only)
    let bar = document.getElementById('skill-bar');
    if(bar) bar.innerHTML = ''; 
    
    // 3. Show Main Menu
    document.getElementById('main-menu').style.display = 'block';
    Menu.goto('home'); // Go to title
    
    // 4. Reset Logic Flags
    S.gameOver = false;
    S.run = false; 
}












// --- NEW PORTRAIT SYSTEM (Direct Canvas Draw) ---

function drawPortrait(canvasId, name) {
    const cvs = document.getElementById(canvasId);
    if(!cvs) return;
    const ctx = cvs.getContext('2d');
    
    // Clear previous drawing
    ctx.clearRect(0, 0, cvs.width, cvs.height);
    ctx.save();

    // 1. GLOBAL HIGH-DPI SCALING (3x Resolution)
    ctx.scale(3, 3); 

    if (name === "Noah") {
        // ============================================
        // NOAH (FINAL: Original Scarf, Smooth & Slightly Narrower Shoulders)
        // ============================================
        
        // 1. Setup Position
        ctx.translate(250, 300); 
        ctx.scale(7.0, 7.0); 

        // ============================================
        // 2. UPPER BODY (Narrower & Smooth)
        // ============================================
        ctx.save(); // Start Clipping Mask

        // --- A. Define The Silhouette ---
        ctx.beginPath();
        
        // Collar (Y=5)
        ctx.moveTo(-4, 5);
        
        // Left Shoulder (Moved in: x=-9 instead of -10)
        ctx.lineTo(-9, 6); 
        // Curve (Control point moved in to -10.5)
        ctx.quadraticCurveTo(-10.5, 6.2, -10.5, 9); 
        
        // Left Sleeve (Straight down)
        ctx.lineTo(-10.5, 13); // Outer Sleeve
        ctx.lineTo(-7.5, 12);  // Inner Sleeve
        
        // Left Torso Side
        ctx.lineTo(-7, 15);    // Waist
        
        // Bottom Hem
        ctx.lineTo(7, 15);
        
        // Right Torso Side
        ctx.lineTo(7, 12);
        
        // Right Sleeve
        ctx.lineTo(7.5, 12);   // Inner Sleeve
        ctx.lineTo(10.5, 13);  // Outer Sleeve
        ctx.lineTo(10.5, 9);   // Top of Arm
        
        // Right Shoulder (Curve gently back)
        ctx.quadraticCurveTo(10.5, 6.2, 9, 6); 
        
        // Right Collar
        ctx.lineTo(4, 5);
        
        ctx.closePath();

        // --- B. Fill Base Color ---
        ctx.fillStyle = '#ffffff';
        ctx.fill();

        // --- C. Apply Clip ---
        ctx.clip();

        // --- D. Draw Stripes ---
        ctx.fillStyle = '#1a237e'; 
        ctx.fillRect(-15, 7, 30, 1.5);  
        ctx.fillRect(-15, 10, 30, 1.5); 
        ctx.fillRect(-15, 13, 30, 1.5); 

        ctx.restore(); // End Clipping

        // ============================================
        // 3. ARMS & HANDS (Aligned to new width)
        // ============================================
        
        // Left Hand
        ctx.fillStyle = '#f5cba7'; 
        ctx.fillRect(-10.5, 13, 3, 3); // Moved inward
        
        // Right Hand 
        ctx.fillStyle = '#f5cba7'; 
        ctx.fillRect(7.5, 13, 3, 3); // Moved inward

        // ============================================
        // 4. SCARF (EXACT ORIGINAL POSITION)
        // ============================================
        ctx.fillStyle = '#c0392b';  // Red
        
        // Main Loop
        ctx.beginPath(); 
        ctx.moveTo(-5, 6); 
        ctx.quadraticCurveTo(0, 10, 5, 6); 
        ctx.lineTo(5, 3); 
        ctx.lineTo(-5, 3); 
        ctx.fill();
        
        // Scarf Drop
        ctx.fillStyle = '#b71c1c'; 
        ctx.fillRect(2, 6, 3, 5); 

        // ============================================
        // 5. HEAD & FACE
        // ============================================
        ctx.fillStyle = '#f5cba7'; ctx.fillRect(-5, -7, 10, 10); 
        ctx.fillRect(-6, -4, 1, 4); ctx.fillRect(5, -4, 1, 4);   
        
        // Nose
        ctx.fillStyle = '#e0b293'; ctx.fillRect(-1, -2, 2, 1); ctx.fillRect(0, -3, 1, 2);
        
        // Eyes
        ctx.fillStyle = '#111'; 
        ctx.fillRect(-3, -4.5, 1, 1); 
        ctx.fillRect(2, -4.5, 1, 1);
        
        // Hair (Bangs)
        ctx.fillStyle = '#111'; 
        ctx.fillRect(-4, -6, 3, 1); ctx.fillRect(1, -6, 3, 1); 

        // Mouth (Smile)
        ctx.fillStyle = '#d84315'; 
        ctx.fillRect(-1, 0.5, 2, 0.5); 
        ctx.fillRect(-1.5, 0, 0.5, 0.5); 
        ctx.fillRect(1, 0, 0.5, 0.5);    
        
        // Hair Back/Sides
        ctx.fillStyle = '#3e2723'; 
        ctx.fillRect(-5, -10, 10, 3); ctx.fillRect(-6, -9, 2, 4); 
        ctx.fillRect(-6, -6, 2, 5); ctx.fillRect(4, -6, 2, 5); ctx.fillRect(-1, -8, 2, 1);

        // ============================================
        // 6. BERET
        // ============================================
        ctx.fillStyle = '#b71c1c'; 
        ctx.beginPath(); ctx.ellipse(1, -9, 9, 4, 0.2, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#d32f2f'; 
        ctx.beginPath(); ctx.ellipse(2, -10, 6, 2, 0.2, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#111'; ctx.fillRect(1, -12, 2, 2); 

        // ============================================
        // 7. ACCESSORIES
        // ============================================
        
       // Brush (Left Hand) - Shifted UP significantly
        ctx.fillStyle = '#8d6e63'; 
        ctx.fillRect(-9.5, 8, 1, 8); // Handle (Y=8 to 16, passes through hand at 13)
        ctx.fillStyle = '#e91e63'; 
        ctx.fillRect(-9.5, 7, 1, 1); // Tip (Y=7, well above hand)

        // Palette (Right Hand)
        ctx.save(); 
        ctx.translate(8.5, 14); 
        ctx.rotate(-0.5);
        ctx.fillStyle = '#d35400'; ctx.beginPath(); ctx.ellipse(0, 0, 4, 6, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.arc(-1, -2, 1.5, 0, 6.28); ctx.fill();
        ctx.fillStyle = '#e91e63'; ctx.beginPath(); ctx.arc(1, 0, 1.5, 0, 6.28); ctx.fill();
        ctx.fillStyle = '#2980b9'; ctx.beginPath(); ctx.arc(0, 2, 1.5, 0, 6.28); ctx.fill();
        ctx.restore(); 
    }



 else if (name === "Doris") {
        // ============================================
        // DORIS (Fixed Wings & Realistic Trumpet)
        // ============================================
        ctx.translate(150, 80); 
        ctx.scale(1.35, 1.35);   
        ctx.translate(-75, -75); 
        
        const cx = 75; 

        // 1. WINGS (Fixed: Attached to Back)
        ctx.save();
        const drawWing = (wx, wy, flip) => {
            ctx.save();
            ctx.translate(wx, wy);
            ctx.scale(flip, 1); 
            
            let wg = ctx.createLinearGradient(0, 0, 60, 50);
            wg.addColorStop(0, "#ffffff");
            wg.addColorStop(1, "#cfd8dc");

            ctx.fillStyle = wg;
            ctx.shadowColor = "rgba(255, 255, 255, 0.6)"; ctx.shadowBlur = 10;
            
            ctx.beginPath();
            // Root starts at (0,0) which we position right behind the shoulder blade
            ctx.moveTo(0, 0); 
            // Arch UP and OUT (High shoulder arch)
            ctx.quadraticCurveTo(10, -35, 60, -20); 
            // Wing Tip
            ctx.quadraticCurveTo(75, 0, 60, 20); 
            // Feathers (Scallops)
            ctx.quadraticCurveTo(55, 25, 50, 20); 
            ctx.quadraticCurveTo(45, 35, 35, 30); 
            ctx.quadraticCurveTo(30, 40, 20, 35); 
            // Return to lower back
            ctx.quadraticCurveTo(10, 45, 0, 10);   
            ctx.fill();
            
            ctx.restore();
        };
        // Move anchors IN (x=60, x=90) and UP (y=85) to hide connection behind body
        drawWing(60, 85, -1);
        drawWing(90, 85, 1);
        ctx.restore();

        // 2. HAIR BASE
        let hairBase = ctx.createLinearGradient(0, 40, 0, 100);
        hairBase.addColorStop(0, "#fff9c4"); hairBase.addColorStop(1, "#f0f4c3"); 
        ctx.fillStyle = hairBase;
        ctx.beginPath();
        ctx.moveTo(45, 92);
        ctx.quadraticCurveTo(35, 88, 38, 78);  ctx.quadraticCurveTo(30, 68, 35, 55);  ctx.quadraticCurveTo(28, 42, 45, 38);
        ctx.quadraticCurveTo(55, 28, 65, 32);  ctx.quadraticCurveTo(75, 25, 85, 32);  ctx.quadraticCurveTo(95, 28, 105, 38);
        ctx.quadraticCurveTo(122, 42, 115, 55); ctx.quadraticCurveTo(120, 68, 112, 78); ctx.quadraticCurveTo(115, 88, 105, 92);
        ctx.quadraticCurveTo(75, 100, 45, 92);
        ctx.fill();

        // 3. NECK
        ctx.fillStyle = "#d7ccc8"; ctx.fillRect(62, 90, 26, 20); 
        ctx.fillStyle = "#ffccbc"; ctx.fillRect(64, 90, 22, 18);

        // 4. CLOTHES (SMOOTH SHOULDERS)
        ctx.fillStyle = "#1565c0"; 
        ctx.beginPath();
        ctx.moveTo(30, 150); // Bottom Left Arm
        
        // Left Shoulder: Curves smoothly from arm up to collar
        ctx.quadraticCurveTo(30, 105, 60, 112);
        
        // Neck Dip
        ctx.quadraticCurveTo(75, 125, 90, 112);
        
        // Right Shoulder: Curves smoothly from collar down to arm
        ctx.quadraticCurveTo(120, 105, 120, 150);
        
        ctx.lineTo(30, 150); // Close bottom
        ctx.fill();

        // White Shirt V
        ctx.fillStyle = "#fff";
        ctx.beginPath(); ctx.moveTo(75, 135); ctx.lineTo(60, 112); ctx.lineTo(90, 112); ctx.fill();

        // Lapels (Adjusted to follow the new curve)
        ctx.fillStyle = "#0d47a1";
        // Left Lapel
        ctx.beginPath(); ctx.moveTo(38, 115); ctx.quadraticCurveTo(48, 112, 60, 112); ctx.lineTo(75, 135); ctx.fill(); 
        // Right Lapel
        ctx.beginPath(); ctx.moveTo(112, 115); ctx.quadraticCurveTo(102, 112, 90, 112); ctx.lineTo(75, 135); ctx.fill(); 

        // Buttons
        ctx.fillStyle = "#ffd700";
        ctx.beginPath(); ctx.arc(75, 140, 2.5, 0, 6.28); ctx.fill();
        ctx.beginPath(); ctx.arc(75, 148, 2.5, 0, 6.28); ctx.fill();

        // 5. NECKLACE
        ctx.fillStyle = "#fff"; ctx.shadowBlur = 5; ctx.shadowColor = "#eee";
        for(let i=0; i<9; i++) {
            let px = 60 + (i * 3.8); let py = 108 + Math.sin(i * 0.4) * 3;
            ctx.beginPath(); ctx.arc(px, py, 2.5, 0, Math.PI*2); ctx.fill();
        }
        ctx.shadowBlur = 0;

        // 6. FACE
        let skinGrad = ctx.createRadialGradient(cx, 75, 5, cx, 75, 45);
        skinGrad.addColorStop(0, "#fff3e0"); skinGrad.addColorStop(0.5, "#ffccbc"); skinGrad.addColorStop(1, "#d7ccc8");   
        ctx.fillStyle = skinGrad;
        ctx.beginPath(); ctx.moveTo(50, 65); ctx.quadraticCurveTo(47, 90, 62, 102); ctx.quadraticCurveTo(cx, 105, 88, 102); 
        ctx.quadraticCurveTo(103, 90, 100, 65); ctx.quadraticCurveTo(cx, 50, 50, 65); ctx.fill();

        // 7. FEATURES
        const paintEye = (ex, ey) => {
            ctx.fillStyle = "rgba(141, 110, 99, 0.3)"; ctx.beginPath(); ctx.ellipse(ex, ey - 2, 7, 4, Math.PI, 0, Math.PI); ctx.fill();
            ctx.fillStyle = "rgba(210, 190, 180, 0.15)"; ctx.beginPath(); ctx.arc(ex, ey, 8, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = "#fdfdfe"; ctx.beginPath(); ctx.ellipse(ex, ey, 5.5, 3, 0, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = "#546e7a"; ctx.beginPath(); ctx.arc(ex, ey, 2.5, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = "#1a1a1a"; ctx.beginPath(); ctx.arc(ex, ey, 1.2, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = "#ffffff"; ctx.beginPath(); ctx.arc(ex - 1, ey - 1, 0.8, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = "#263238"; ctx.lineWidth = 1.5; ctx.lineCap = "round";
            ctx.beginPath(); ctx.moveTo(ex - 5, ey); ctx.quadraticCurveTo(ex, ey - 4.5, ex + 6, ey - 0.5); ctx.stroke();
        };
        paintEye(64, 74); paintEye(86, 74); 

        ctx.strokeStyle = "rgba(141, 110, 99, 0.6)"; ctx.lineWidth=2;
        ctx.beginPath(); ctx.moveTo(59, 68); ctx.quadraticCurveTo(65, 66, 71, 69); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(79, 69); ctx.quadraticCurveTo(85, 66, 91, 68); ctx.stroke();

        ctx.fillStyle = "#fff3e0";
        ctx.beginPath(); ctx.moveTo(cx - 2, 65); ctx.lineTo(cx + 2, 65); ctx.lineTo(cx + 2, 85); ctx.lineTo(cx + 6, 85);
        ctx.quadraticCurveTo(cx, 94, cx - 6, 85); ctx.lineTo(cx - 2, 85); ctx.lineTo(cx - 2, 65); ctx.fill();
        ctx.fillStyle = "#ffe9d7";
        ctx.beginPath(); ctx.moveTo(cx + 1, 65); ctx.lineTo(cx + 2, 65); ctx.lineTo(cx + 2, 85); ctx.lineTo(cx + 6, 85);
        ctx.quadraticCurveTo(cx + 1, 93, cx, 94); ctx.quadraticCurveTo(cx + 3, 90, cx + 3, 85); ctx.lineTo(cx + 1, 85); ctx.lineTo(cx + 1, 65); ctx.fill();
        ctx.strokeStyle = "#ffdccb"; ctx.lineWidth = 1.5; ctx.lineCap = "round";
        ctx.beginPath(); ctx.moveTo(71, 85); ctx.quadraticCurveTo(65, 87, 63, 92); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(79, 85); ctx.quadraticCurveTo(85, 87, 87, 92); ctx.stroke();

        const addBlush = (bx, by) => {
            let bGrad = ctx.createRadialGradient(bx, by, 0, bx, by, 15);
            bGrad.addColorStop(0, "rgba(229, 115, 115, 0.14)"); bGrad.addColorStop(0.5, "rgba(229, 115, 115, 0.05)"); bGrad.addColorStop(1, "rgba(229, 115, 115, 0)"); 
            ctx.fillStyle = bGrad; ctx.beginPath(); ctx.ellipse(bx, by, 15, 10, 0, 0, Math.PI*2); ctx.fill();
        };
        addBlush(58, 85); addBlush(92, 85);

        let lipGrad = ctx.createLinearGradient(0, 90, 0, 96);
        lipGrad.addColorStop(0, "#c2185b"); lipGrad.addColorStop(1, "#f48fb1"); 
        ctx.fillStyle = lipGrad;
        ctx.beginPath(); ctx.moveTo(67, 92); ctx.quadraticCurveTo(cx, 96, 83, 92); ctx.quadraticCurveTo(cx, 100, 67, 92); ctx.fill();
        
        let blush = ctx.createRadialGradient(cx, 85, 1, cx, 85, 20);
        blush.addColorStop(0, "rgba(244, 143, 177, 0.0)"); blush.addColorStop(1, "rgba(244, 143, 177, 0)");
        ctx.fillStyle = blush; ctx.fillRect(45, 80, 60, 20);

        // 8. CURLY HAIR
        let seed = 1234;
        const myRandom = () => { let x = Math.sin(seed++) * 10000; return x - Math.floor(x); };
        const drawStaticCurl = (x, y, r, color) => {
            ctx.beginPath(); ctx.strokeStyle = color; ctx.lineWidth = 1.3; ctx.lineCap = "round";
            ctx.arc(x, y, r, 0, Math.PI * 1.5); ctx.stroke();
        };
        for(let i=0; i<1600; i++) {
            let angle = myRandom() * Math.PI * 2; let dist = myRandom() * 45; 
            let hx = 75 + Math.cos(angle) * (dist * 0.9); let hy = 60 + Math.sin(angle) * (dist * 0.7);
            if (hy > 58 && hx > 48 && hx < 102) continue; 
            if (hy < 35 || hy > 95) continue; 
            let col = (i%3===0) ? "#fff9c4" : (i%3===1) ? "#fff59d" : "#ffffff";
            drawStaticCurl(hx, hy, 1.5 + myRandom()*2.5, col);
        }
        for(let j=0; j<40; j++) {
            let bx = 55 + (j*1.2); let by = 55 + Math.sin(j*0.5)*5; drawStaticCurl(bx, by, 2, "#fff9c4");
        }

        // 9. TRUMPET (REALISTIC SHAPE)
        ctx.save();
        // Position: In Hands
        ctx.translate(65, 135); 
        ctx.rotate(-0.4); 
        
        let brass = ctx.createLinearGradient(0, -5, 0, 10);
        brass.addColorStop(0, "#fbc02d"); 
        brass.addColorStop(0.4, "#fff59d"); 
        brass.addColorStop(0.6, "#fdd835"); 
        brass.addColorStop(1, "#f57f17"); 

        ctx.fillStyle = brass;
        
        // A. Bell Flare (Left)
        ctx.beginPath();
        ctx.moveTo(-10, -8);
        ctx.quadraticCurveTo(5, 0, -10, 8); 
        ctx.lineTo(-25, 4);
        ctx.lineTo(-25, -4);
        ctx.fill();

        // B. Main Tubing (Long Rectangle)
        ctx.fillRect(-25, -3, 60, 6);

        // C. Valve Block (Middle)
        ctx.fillRect(0, -8, 15, 16); // The Casing
        // Valve Stems (Buttons)
        ctx.fillStyle = "#fff176";
        ctx.fillRect(2, -11, 3, 3);
        ctx.fillRect(6, -11, 3, 3);
        ctx.fillRect(10, -11, 3, 3);

        // D. Loop (Bottom pipe)
        ctx.strokeStyle = "#f9a825"; ctx.lineWidth = 4;
        ctx.beginPath(); ctx.moveTo(-15, 3); ctx.quadraticCurveTo(-20, 10, 0, 10); ctx.lineTo(30, 10); ctx.quadraticCurveTo(40, 10, 35, 3); ctx.stroke();

        ctx.restore();

        // Hands & Earrings
        ctx.fillStyle = "#ffccbc";
        ctx.beginPath(); ctx.ellipse(58, 140, 6, 8, 0.6, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(92, 142, 6, 8, -0.6, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "#fff"; ctx.shadowColor="#fff"; ctx.shadowBlur=4;
        ctx.beginPath(); ctx.arc(46, 85, 3.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(104, 85, 3.5, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur=0;
    }
    ctx.restore();
}




function showChat(name, txt, isIntro = false) {
    const stdBox = document.getElementById('rpg-chat');
    const spBox = document.getElementById('special-chat');
    
    const stdName = document.getElementById('chat-name');
    const stdText = document.getElementById('chat-text');
    
    const spName = document.getElementById('sp-name');
    const spText = document.getElementById('sp-text');

    // 1. Reset Everything (Hide both boxes)
    stdBox.style.display = 'none'; stdBox.style.opacity = 0;
    spBox.style.display = 'none'; spBox.style.opacity = 0;
    
    // 2. Remove old positioning classes to prevent conflicts
    spBox.classList.remove('talk-noah', 'talk-doris');

    // 3. LOGIC SWITCH: Check if it is Noah or Doris
    if ((name === "Noah" || name === "Doris") && !isIntro) {
        
        spBox.style.display = 'flex';
        // Small delay to allow display:flex to render before opacity fade-in
        setTimeout(() => spBox.style.opacity = 1, 10);

        spName.innerText = name;
        spText.innerText = txt;

        const cn = document.getElementById('canvas-noah');
        const cd = document.getElementById('canvas-doris');
        
        // Hide both portraits first
        if(cn) cn.style.display = 'none';
        if(cd) cd.style.display = 'none';

        // --- APPLY SPECIFIC LAYOUT ---
        if(name === "Noah") {
            spBox.classList.add('talk-noah'); // Activate Noah CSS
            if(cn) { cn.style.display = 'block'; drawPortrait('canvas-noah', 'Noah'); }
        } 
        else if(name === "Doris") {
            spBox.classList.add('talk-doris'); // Activate Doris CSS
            if(cd) { cd.style.display = 'block'; drawPortrait('canvas-doris', 'Doris'); }
        }

    } else {
        // STANDARD BOX (For everyone else)
        stdBox.style.display = 'flex';
        setTimeout(() => stdBox.style.opacity = 1, 10);
        stdName.innerText = name;
        stdText.innerText = txt;
    }
    
    // Auto-close timer
    if(S.chatTo) clearTimeout(S.chatTo);
    S.chatTo = setTimeout(() => { 
        stdBox.style.opacity = 0; spBox.style.opacity = 0;
        setTimeout(() => { stdBox.style.display = 'none'; spBox.style.display = 'none'; }, 200);
    }, 3500 + txt.length * 50); 
}










</script>
</body>
</html>